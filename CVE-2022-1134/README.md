# Property Access & Inline Caching

- Inline caching speeds up propety access

- Ignition Interpreter collects data for function run which is used by TurboFan to generate optimized machine code

- Object map stores many important information such as memory layout of object. If 2 objects have similar structures, they will have similar maps and hence the way their propeties are accessed will be similar enough for v8 to optimise

- Read more here on inline caching: [JavaScript engine fundamentals: Shapes and Inline Caches](https://mathiasbynens.be/notes/shapes-ics), [super inline caching](https://v8.dev/blog/fast-super), [Short and seemingly useless article on inline caching](https://javascript.plainenglish.io/v8-engine-and-inline-caching-in-javascript-fef80054a551)

- There are 2 kinds of properties: keyed and named (think of a[1] vs a.x)

- Bytecode generation for is handled by various IGNITION_HANDLERs: IGNITION_HANDLER calls LoadIC_BytecodeHandler which then generates bytecode based on feedback collected thus far. For property access bytecode generation:

    1. If the function is being called for the first time and hence has no feedback, then the bytecode generated and run will be the inefficient property access

        > In the meantime, feedback is collected and optimized property access handlers **for that particular object's map** are cached

    2. If not, the LoadIC_BytecodeHandler will try to find for cached optimized property access handler

        > If it is not found/or somehow the the propety access fails, then v8 will report cache miss and use inefficient property access 

        > If it found then use cached optimized property access handler

    3. When a cache miss occurs, LoadIC_Miss() is called 

        > Creates and caches a new optimized handler to be used when the same property access is called
        
        > LoadIC -> LoadIC::Load -> UpdateCaches -> ComputeHandler

        > ComputeHandler uses the type of property access determined by object map to determine how to create the handler

- Tl;dr, when we are inline caching to optimize property accesses, need to ensure that the assumptions made when handler is created and used remains the same for each property access

# Refresher on super()

- Extends is used to denote the parent class that the child class will inherit its methods from, and super is used to reference the parent classes constructor method as per this [article](https://dev.to/mconner89/creating-child-classes-using-super-and-extends-o0i)

- Use [w3schools](https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_class_extends) example to play around with it

- d8.exe

    ```
    d8> class B {  m() {    return super.prop;  }}B.prototype.__proto__ = {get prop() {return this.x}};var b = new B();b.x = 1;b.m()
    1
    d8> %DebugPrint(B)
    DebugPrint: 000001D74490DAB1: [Function]
    - map: 0x00b1d560c1b1 <Map(HOLEY_ELEMENTS)> [FastProperties]
    - prototype: 0x0237b55842a1 <JSFunction (sfi = 000001ACB5104DE9)>
    - elements: 0x0270b3882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
    - function prototype: 0x01d74490db31 <B map = 000000B1D560C3E1>
    - initial_map: 0x00b1d560c391 <Map(HOLEY_ELEMENTS)>
    - shared_info: 0x0237b55a2139 <SharedFunctionInfo B>
    - name: 0x0237b55a2019 <String[1]: B>
    - formal_parameter_count: 0
    - kind: DefaultBaseConstructor
    - context: 0x0237b55a2531 <ScriptContext[5]>
    - code: 0x0208f078ca81 <Code BUILTIN InterpreterEntryTrampoline>
    - interpreted
    - bytecode: 00000237B55A2A39
    - source code:
    - properties: 0x0270b3882cf1 <FixedArray[0]> {
        #length: 0x01acb5119779 <AccessorInfo> (const accessor descriptor)
        #prototype: 0x01acb51197e9 <AccessorInfo> (const accessor descriptor)
        0x0270b3886729 <Symbol: (class_positions_symbol)>: 0x01d74490d9a1 <Tuple2 0, 42> (const data descriptor)
        #name: 0x01acb5119709 <AccessorInfo> (const accessor descriptor)
    }

    - feedback vector: 00000237B55A2A79: [FeedbackVector] in OldSpace
    - map: 0x0270b3882c91 <Map>
    - length: 0 (empty)
    000000B1D560C1B1: [Map]
    - type: JS_FUNCTION_TYPE
    - instance size: 64
    - inobject properties: 0
    - elements kind: HOLEY_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - stable_map
    - callable
    - constructor
    - has_prototype_slot
    - prototype_map
    - prototype info: 0
    - prototype_validity cell: 0x01acb5102201 <Cell value= 1>
    - instance descriptors (own) #4: 0x01d74490db69 <DescriptorArray[14]>
    - layout descriptor: 0000000000000000
    - prototype: 0x0237b55842a1 <JSFunction (sfi = 000001ACB5104DE9)>
    - constructor: 0x0237b55844c1 <JSFunction Function (sfi = 000001ACB510F9F9)>
    - dependent code: 0x0270b3882391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0

    class B {  m() {    return super.prop;  }}
    d8> %DebugPrint(B.prototype)
    DebugPrint: 000001D74490DB31: [JS_OBJECT_TYPE]
    - map: 0x00b1d560c3e1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
    - prototype: 0x01d74490dc39 <Object map = 000000B1D560C341>
    - elements: 0x0270b3882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
    - properties: 0x01d74490ddb1 <NameDictionary[29]> {
    #constructor: 0x01d74490dab1 <JSFunction B (sfi = 00000237B55A2139)> (data, dict_index: 1, attrs: [W_C])
    #m: 0x01d74490daf1 <JSFunction m (sfi = 00000237B55A2191)> (data, dict_index: 2, attrs: [W_C])
    }
    000000B1D560C3E1: [Map]
    - type: JS_OBJECT_TYPE
    - instance size: 56
    - inobject properties: 4
    - elements kind: HOLEY_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - dictionary_map
    - may_have_interesting_symbols
    - prototype_map
    - prototype info: 0x0237b55a2aa1 <PrototypeInfo>
    - prototype_validity cell: 0x0237b55a2b11 <Cell value= 0>
    - instance descriptors (own) #0: 0x0270b3882321 <DescriptorArray[2]>
    - layout descriptor: 0000000000000000
    - prototype: 0x01d74490dc39 <Object map = 000000B1D560C341>
    - constructor: 0x01d74490dab1 <JSFunction B (sfi = 00000237B55A2139)>
    - dependent code: 0x0270b3882391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0

    {constructor: class B {  m() {    return super.prop;  }}, m: m() {    return super.prop;  }}
    d8> %DebugPrint(B.prototype.__proto__)
    DebugPrint: 000001D74490DC39: [JS_OBJECT_TYPE]
    - map: 0x00b1d560c4d1 <Map(HOLEY_ELEMENTS)> [FastProperties]
    - prototype: 0x0237b5584229 <Object map = 000000B1D56022F1>
    - elements: 0x0270b3882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
    - properties: 0x0270b3884761 <PropertyArray[0]> {
        #prop: 0x0237b55a29a1 <AccessorPair> (const accessor descriptor)
    }
    000000B1D560C4D1: [Map]
    - type: JS_OBJECT_TYPE
    - instance size: 24
    - inobject properties: 0
    - elements kind: HOLEY_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - stable_map
    - may_have_interesting_symbols
    - prototype_map
    - prototype info: 0x0237b55a2ad9 <PrototypeInfo>
    - prototype_validity cell: 0x01acb5102201 <Cell value= 1>
    - instance descriptors (own) #1: 0x0237b55a62a9 <DescriptorArray[5]>
    - layout descriptor: 0000000000000000
    - prototype: 0x0237b5584229 <Object map = 000000B1D56022F1>
    - constructor: 0x0237b5584261 <JSFunction Object (sfi = 000001ACB510ED51)>
    - dependent code: 0x0270b3882391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0

    {get prop() {return this.x}}
    ```

- Insights from `what_is_super.html`:

    ![](./super_and_inheritance.png)

    - We can see how the Object's prototype will store the classes it extended from and the `__proto__` will store the parent's functions

- Important case study:

    ```
    class B {
        m() {
            return super.length;
        }
    }

    var b = new B();
    B.prototype.__proto__ = new Int8Array(1);
    b.m();  //<---- throw TypeError
    ```

    > VM618:6 Uncaught TypeError: 
    > 
    > Method get TypedArray.prototype.length called on incompatible receiver [object Object] 
    >
    > at get length (<anonymous>)
    >
    > at B.m (<anonymous>:6:18)
    >
    > at <anonymous>:15:3

    - We are able to run `B.prototype.__proto__.length` but not `B.m()` which indirectly does the same thing due to prevention of type confusion (retrieving length of JSObject using the algorithm for JSArray)

    - Receiver refers to `var b = new B()`

# Super + IC = SuperIC

- When optimising property access via super, super inline caching is used

- GetNamedPropertyFromSuper -> LoadSuperIC -> HandleLoadICHandlerCase -> call_handler 

- Level of complication: parent property vs receiver property. Assumptions made during property access optimization should apply to both receiver and parent

- lookup_start_object refers to parent while home_object refers to receiver

- The vulnerability is found in HandleLoadICHandlerCase, where we could use the receiver object instead of the parent object
