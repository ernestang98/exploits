https://issues.chromium.org/issues/40061500

https://chromium-review.googlesource.com/c/v8/v8/+/3988924

https://chromium-review.googlesource.com/c/v8/v8/+/3845636

# Ubercage

### Sandboxifying Backing Stores

- Backing Stores are used to create Arbitrary R/W and RCE primitives, and historically stored as 64bit pointers and are easily read using compressed read/write primitives

- One feature of Ubercage sandboxifies the backing stores - instead of storing the actual pointer itself, we store indices which can be resolved to the respective backing store

- In order to bypass this and still create RCE without arbitrary R/W primitives, we can use JIT Spraying/Shellcoding

# Ubercage Escapes

We will be going through 

### JIT Spraying/Shellcoding

- This technique bypasses W^X protection on JIT Functions and WASM spaces.

- It is stable on x86_64 based OSes (Windows and some families of Linux) until CPT was introduced, where the code pointers are replaced by indices and only accessible via the code pointer table.

- In CVE-2018-17463, we briefly went through the possibility of bypassing W^X protection on JIT-ed functions but did not dive into it due to the fact that we could get away with abusing WASM spaces

- The introduction of W^X protection on WASM spaces (from Chrome 100 and onwards up till before Chrome 110 for Windows) did not deter us from continue using WASM to RCE due to the fact that we could still create arbitrary r/w primitives by bitmap flipping the appropriate locations in chrome in order to disable the protection ([wasm_write_protect_code_memory](https://medium.com/deno-the-complete-reference/v8-flags-supported-by-deno-f5f7a946dadb)). Verified the versions manually... 

- I'm guessing the reason why WASM was set back to RWX from chrome 110 onwards was due to maybe the belief that because of Ubercage and the sandboxifying of arraybuffer backing stores, they wouldn't need to implement the W^X protection on WASM spaces and hence removed it to improve efficiency (an interpreted waste of setting the WASM space from RW- to R-X and vice versa)

- In Chrome 103, arraybuffer backingstores were sandboxed and in order to access the backingstore, you would need to find the base location of the v8 sandbox and add it with index*0x100 (as per the [documentation](https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit), this base location is found in r14). Given that in a typical chrome bug, it is unlikely for us to leak this value, we need to be creative in obtaining our RCE.

    ![](./Advent%20of%20Ubercage/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)

- Looking at how JIT-ed functions work when returning floats, we observe that we can smuggle shellcode inside floats as seen in CVE-2018-17463, we need to note that:

    1. The maximum length of each instruction needs to be lesser or equal to 6 bytes (cause we also need to jump to our next float)

    2. In Windows, where we need to craft Position Independent shellcode, jumping and calling is a pain but still possible

    3. We need to make sure that each float is unique if not V8 will optimise the way the floats are passed around (instead of generating the 8 byte integer, it will simply play around with the float registers with the duplicate values)

- `jit_spraying.py` is a script which will generate the appropriate Uint8Array which we can later convert to a float array

- Here, we are able to bypass the W^X protections implemented without needing any arbitrary r/w primitives

### CPT

Introduced in Chrome 117?

https://docs.google.com/document/d/1CPs5PutbnmI-c5g7e_Td9CNGh5BvpLleKCqUnqmD82k/edit#heading=h.xzptrog8pyxf

https://groups.google.com/g/v8-reviews/c/bLrgEfZNGZ4

6 July 2023

- most likely introduced in chrome 115?

- last version without CPT should be in chrome 114

- somehow we can still JIT spray till chrome 116 so Chrome 117 i guess

- but doesnt rly matter cause we can continue abusing the shit out of WASM on windows from Chrome 110

### TPT

https://groups.google.com/g/v8-reviews/c/QQq003iyBIw

https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/wasm-objects.h;l=322;bpv=1;bpt=0;drc=084bd3d7565254a023c8f517a7e8b5f9e0aaa732;dlc=2da1da50d99e28407b66fdb59935f1d5d16b3281

https://chromium.googlesource.com/v8/v8.git/+/caef66d2fd750fd01100aed04e33530e20e442bc%5E%21/#F0

https://chromium.googlesource.com/v8/v8.git/+log/1fbb9881419d2c7c278a6013df6c8ca16344dbd9..7ca8cf1710353b309b30a27873709a2500585ad0?n=1000&pretty=fuller


EPT -> CPT-> TPT

july 2022 ->  December 2022/July 2023 -> October 2023/December 2023


https://docs.google.com/document/d/1V3sxltuFjjhp_6grGHgfqZNK57qfzGzme0QTk0IXDHk/edit#heading=h.xzptrog8pyxf

https://docs.google.com/document/d/1CPs5PutbnmI-c5g7e_Td9CNGh5BvpLleKCqUnqmD82k/edit

https://docs.google.com/document/d/1IrvzL4uX_Zv0k2Iakdp_q_z33bj-qlYF5IesGpXW0fM/edit



### CVE-2023-4096


### Todo

- CVE-2023-2033 Chrome 110/109 if can

- CVE-2023-4096 Chrome 115

- CVE-2024-0517 Chrome 120

- TPT Experiments

- EPT Experiments

- Build DiceCTF